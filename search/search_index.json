{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dynamixel Hardware Interface #","title":"Home"},{"location":"#dynamixel-hardware-interface","text":"","title":"Dynamixel Hardware Interface"},{"location":"doxygen/markdown/Classes/","text":"Classes # namespace dynamixel_hardware_interface class Address class AddressTableBase base class for address table class class DynamixelHardwareInterface Hardware interface for the dynamixel motor. class MotorBase Base class for controlling dynamixel motor. struct Result Struct describes the command result. namespace address_tables class XW540_T260 namespace motors class XW540_T260 Updated on 5 May 2021 at 09:17:41 UTC","title":"Classes"},{"location":"doxygen/markdown/Classes/#classes","text":"namespace dynamixel_hardware_interface class Address class AddressTableBase base class for address table class class DynamixelHardwareInterface Hardware interface for the dynamixel motor. class MotorBase Base class for controlling dynamixel motor. struct Result Struct describes the command result. namespace address_tables class XW540_T260 namespace motors class XW540_T260 Updated on 5 May 2021 at 09:17:41 UTC","title":"Classes"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/","text":"dynamixel_hardware_interface::Address # Public Functions # Name bool exists () const Address (uint16_t address, PacketByteSize byte_size) Address () Public Attributes # Name const PacketByteSize byte_size const uint16_t address Public Functions Documentation # function exists # inline bool exists () const function Address # inline Address ( uint16_t address , PacketByteSize byte_size ) function Address # inline Address () Public Attributes Documentation # variable byte_size # const PacketByteSize byte_size ; variable address # const uint16_t address ; Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface::Address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#dynamixel_hardware_interfaceaddress","text":"","title":"dynamixel_hardware_interface::Address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#public-functions","text":"Name bool exists () const Address (uint16_t address, PacketByteSize byte_size) Address ()","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#public-attributes","text":"Name const PacketByteSize byte_size const uint16_t address","title":"Public Attributes"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#function-exists","text":"inline bool exists () const","title":"function exists"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#function-address","text":"inline Address ( uint16_t address , PacketByteSize byte_size )","title":"function Address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#function-address_1","text":"inline Address ()","title":"function Address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#variable-byte_size","text":"const PacketByteSize byte_size ;","title":"variable byte_size"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#variable-address","text":"const uint16_t address ; Updated on 5 May 2021 at 09:17:41 UTC","title":"variable address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/","text":"dynamixel_hardware_interface::AddressTableBase # base class for address table class #include <address_table_base.hpp> Inherited by dynamixel_hardware_interface::address_tables::XW540_T260 Public Functions # Name Address getAddress (const Operation & operaiton) const Get address of which operation you want to execute. bool addressExists (const Operation & operation) const Check the address exists or not. AddressTableBase ( Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE) Construct a new Address Table Base object, each parameter describes the address of the operation. Public Functions Documentation # function getAddress # inline Address getAddress ( const Operation & operaiton ) const Get address of which operation you want to execute. Parameters : operaiton operation you want to execute Returns : boost::none operation is not supported uint16_t address of the operation you want to execute function addressExists # inline bool addressExists ( const Operation & operation ) const Check the address exists or not. Parameters : operation operation you want to execute Return : true address exist false address does not exist function AddressTableBase # inline explicit AddressTableBase ( Address ADDR_TORQUE_ENABLE , Address ADDR_GOAL_POSITION , Address ADDR_MOVING_SPEED , Address ADDR_PRESENT_POSITION , Address ADDR_PRESENT_SPEED , Address ADDR_PRESENT_LOAD , Address ADDR_PRESENT_VOLTAGE , Address ADDR_PRESENT_TEMPERATURE ) Construct a new Address Table Base object, each parameter describes the address of the operation. Parameters : ADDR_TORQUE_ENABLE If this value is boost::none, writing torque_enable command address exists. ADDR_GOAL_POSITION If this value is boost::none, writing goal_position command address exists. ADDR_MOVING_SPEED If this value is boost::none, writing moving_speed command address exists. ADDR_PRESENT_POSITION If this value is boost::none, reading present_position command address exists. ADDR_PRESENT_SPEED If this value is boost::none, reading present_speed command address exists. ADDR_PRESENT_LOAD If this value is boost::none, reading present_load command address exists. ADDR_PRESENT_VOLTAGE If this value is boost::none, reading present_voltage command address exists. ADDR_PRESENT_TEMPERATURE If this value is boost::none, reading present_tempelature command address exists. Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface::AddressTableBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#dynamixel_hardware_interfaceaddresstablebase","text":"base class for address table class #include <address_table_base.hpp> Inherited by dynamixel_hardware_interface::address_tables::XW540_T260","title":"dynamixel_hardware_interface::AddressTableBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#public-functions","text":"Name Address getAddress (const Operation & operaiton) const Get address of which operation you want to execute. bool addressExists (const Operation & operation) const Check the address exists or not. AddressTableBase ( Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE) Construct a new Address Table Base object, each parameter describes the address of the operation.","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#function-getaddress","text":"inline Address getAddress ( const Operation & operaiton ) const Get address of which operation you want to execute. Parameters : operaiton operation you want to execute Returns : boost::none operation is not supported uint16_t address of the operation you want to execute","title":"function getAddress"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#function-addressexists","text":"inline bool addressExists ( const Operation & operation ) const Check the address exists or not. Parameters : operation operation you want to execute Return : true address exist false address does not exist","title":"function addressExists"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#function-addresstablebase","text":"inline explicit AddressTableBase ( Address ADDR_TORQUE_ENABLE , Address ADDR_GOAL_POSITION , Address ADDR_MOVING_SPEED , Address ADDR_PRESENT_POSITION , Address ADDR_PRESENT_SPEED , Address ADDR_PRESENT_LOAD , Address ADDR_PRESENT_VOLTAGE , Address ADDR_PRESENT_TEMPERATURE ) Construct a new Address Table Base object, each parameter describes the address of the operation. Parameters : ADDR_TORQUE_ENABLE If this value is boost::none, writing torque_enable command address exists. ADDR_GOAL_POSITION If this value is boost::none, writing goal_position command address exists. ADDR_MOVING_SPEED If this value is boost::none, writing moving_speed command address exists. ADDR_PRESENT_POSITION If this value is boost::none, reading present_position command address exists. ADDR_PRESENT_SPEED If this value is boost::none, reading present_speed command address exists. ADDR_PRESENT_LOAD If this value is boost::none, reading present_load command address exists. ADDR_PRESENT_VOLTAGE If this value is boost::none, reading present_voltage command address exists. ADDR_PRESENT_TEMPERATURE If this value is boost::none, reading present_tempelature command address exists. Updated on 5 May 2021 at 09:17:41 UTC","title":"function AddressTableBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/","text":"dynamixel_hardware_interface::DynamixelHardwareInterface # Hardware interface for the dynamixel motor. #include <dynamixel_hardware_interface.hpp> Inherits from hardware_interface::BaseInterface< hardware_interface::SystemInterface > Public Functions # Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type write () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type stop () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type start () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type read () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector< hardware_interface::StateInterface > export_state_interfaces () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector< hardware_interface::CommandInterface > export_command_interfaces () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type configure (const hardware_interface::HardwareInfo & info) override Public Functions Documentation # function write # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type write () override function stop # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type stop () override function start # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type start () override function read # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type read () override function export_state_interfaces # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: StateInterface > export_state_interfaces () override function export_command_interfaces # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: CommandInterface > export_command_interfaces () override function configure # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type configure ( const hardware_interface :: HardwareInfo & info ) override Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface::DynamixelHardwareInterface"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#dynamixel_hardware_interfacedynamixelhardwareinterface","text":"Hardware interface for the dynamixel motor. #include <dynamixel_hardware_interface.hpp> Inherits from hardware_interface::BaseInterface< hardware_interface::SystemInterface >","title":"dynamixel_hardware_interface::DynamixelHardwareInterface"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#public-functions","text":"Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type write () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type stop () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type start () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type read () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector< hardware_interface::StateInterface > export_state_interfaces () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector< hardware_interface::CommandInterface > export_command_interfaces () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type configure (const hardware_interface::HardwareInfo & info) override","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-write","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type write () override","title":"function write"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-stop","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type stop () override","title":"function stop"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-start","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type start () override","title":"function start"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-read","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type read () override","title":"function read"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-export_state_interfaces","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: StateInterface > export_state_interfaces () override","title":"function export_state_interfaces"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-export_command_interfaces","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: CommandInterface > export_command_interfaces () override","title":"function export_command_interfaces"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-configure","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type configure ( const hardware_interface :: HardwareInfo & info ) override Updated on 5 May 2021 at 09:17:41 UTC","title":"function configure"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/","text":"dynamixel_hardware_interface::MotorBase # Base class for controlling dynamixel motor. #include <motor_base.hpp> Inherited by dynamixel_hardware_interface::motors::XW540_T260 Public Functions # Name ~MotorBase () Destroy the Motor Base object. virtual Result updateJointPosition () Execute update joint position command to the motor. virtual Result torqueEnable (bool enable) Execute torqu_enabled command to the motor. virtual Result setGoalPosition (double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. bool operationSupports (const Operation & operation) Check the operation is support in your motor. virtual std::vector< Operation > getSupportedOperations () Get list of supported Operations in your motor. virtual double getJointPosition () const Get current joint position of the motor. virtual double getGoalPosition () const Get current goal position of the motor. virtual Result configure () Configure dynamixel motor. virtual void appendStateInterfaces (std::vector< hardware_interface::StateInterface > & interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces (std::vector< hardware_interface::CommandInterface > & interfaces) Append command interface described in the URDF file. template \\<typename AddressTable > MotorBase (const SupportedMotors & motor_type, const std::string & joint_name, const bool enable_dummy, const AddressTable & table, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Construct a new Motor Base object. Protected Functions # Name template \\<typename T > T radianToPosition (double radian) const uint16_t radianToPosition (double radian) const virtual void radianToPosition (double radian, uint8_t & value) const virtual void radianToPosition (double radian, uint16_t & value) const virtual void radianToPosition (double radian, uint32_t & value) const virtual double positionToRadian (const uint8_t position) const virtual double positionToRadian (const uint16_t position) const virtual double positionToRadian (const uint32_t position) const Result getResult (int communication_result, uint8_t packet_error) MotorBase () Construct a new Motor Base object. Public Attributes # Name const SupportedMotors motor_type Describe the type of the motor. const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication. Protected Attributes # Name std::shared_ptr< dynamixel::PortHandler > port_handler_ std::shared_ptr< dynamixel::PacketHandler > packet_handler_ double joint_position_ double goal_position_ std::shared_ptr< AddressTableBase > address_table_ Public Functions Documentation # function ~MotorBase # ~ MotorBase () Destroy the Motor Base object. function updateJointPosition # virtual Result updateJointPosition () Execute update joint position command to the motor. Return : Result result of the command. function torqueEnable # virtual Result torqueEnable ( bool enable ) Execute torqu_enabled command to the motor. Parameters : enable if true, enable torque. Return : Result result of the command. function setGoalPosition # virtual Result setGoalPosition ( double goal_position ) Execute goal_position command to the motor. Parameters : goal_position goal position angle in radian. Return : Result result of the command. function setCurrentGoalPosition # inline virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. Return : Result result of the command. function operationSupports # bool operationSupports ( const Operation & operation ) Check the operation is support in your motor. Parameters : operation Operation which you want to execute. Return : true Operation supports. false Operation does not support. function getSupportedOperations # virtual std :: vector < Operation > getSupportedOperations () Get list of supported Operations in your motor. Return : std::vector List of supported operations. function getJointPosition # inline virtual double getJointPosition () const Get current joint position of the motor. Return : double Current joint position of the motor in radian. function getGoalPosition # inline virtual double getGoalPosition () const Get current goal position of the motor. Return : double Current goal position of the motor in radian. function configure # virtual Result configure () Configure dynamixel motor. Return : Result result of the configuration. function appendStateInterfaces # virtual void appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ) Append state interface described in the URDF file. Parameters : interfaces List of state interface. function appendCommandInterfaces # virtual void appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ) Append command interface described in the URDF file. Parameters : interfaces List of command interface. function MotorBase # template < typename AddressTable > inline MotorBase ( const SupportedMotors & motor_type , const std :: string & joint_name , const bool enable_dummy , const AddressTable & table , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) Construct a new Motor Base object. Parameters : motor_type Type of the motor. joint_name Name of the joint which the motor is attaching to. enable_dummy If true, you can communicate with virtual dinamixel motor. table address table of the motor. baudrate Baudrate of the serial communication. id Id of the dynamixel motor. port_handler Port handler class of the dynamixel sdk. packet_handler Packet handler class of the dynamixel sdk Template Parameters : AddressTable address table type of the motor. Protected Functions Documentation # function radianToPosition # template < typename T > inline T radianToPosition ( double radian ) const function radianToPosition # uint16_t radianToPosition ( double radian ) const function radianToPosition # inline virtual void radianToPosition ( double radian , uint8_t & value ) const function radianToPosition # inline virtual void radianToPosition ( double radian , uint16_t & value ) const function radianToPosition # inline virtual void radianToPosition ( double radian , uint32_t & value ) const function positionToRadian # virtual double positionToRadian ( const uint8_t position ) const function positionToRadian # virtual double positionToRadian ( const uint16_t position ) const function positionToRadian # virtual double positionToRadian ( const uint32_t position ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::positionToRadian function getResult # Result getResult ( int communication_result , uint8_t packet_error ) function MotorBase # MotorBase () Construct a new Motor Base object. Public Attributes Documentation # variable motor_type # const SupportedMotors motor_type ; Describe the type of the motor. variable joint_name # const std :: string joint_name ; Name of the joint which the motor is attaching to. variable id # const uint8_t id ; Id of the dynamixel motor. variable enable_dummy # const bool enable_dummy ; If true, you can communicate with virtual dinamixel motor. variable baudrate # const int baudrate ; Baudrate of the serial communication. Protected Attributes Documentation # variable port_handler_ # std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; variable packet_handler_ # std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; variable joint_position_ # double joint_position_ ; variable goal_position_ # double goal_position_ ; variable address_table_ # std :: shared_ptr < AddressTableBase > address_table_ ; Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface::MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#dynamixel_hardware_interfacemotorbase","text":"Base class for controlling dynamixel motor. #include <motor_base.hpp> Inherited by dynamixel_hardware_interface::motors::XW540_T260","title":"dynamixel_hardware_interface::MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#public-functions","text":"Name ~MotorBase () Destroy the Motor Base object. virtual Result updateJointPosition () Execute update joint position command to the motor. virtual Result torqueEnable (bool enable) Execute torqu_enabled command to the motor. virtual Result setGoalPosition (double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. bool operationSupports (const Operation & operation) Check the operation is support in your motor. virtual std::vector< Operation > getSupportedOperations () Get list of supported Operations in your motor. virtual double getJointPosition () const Get current joint position of the motor. virtual double getGoalPosition () const Get current goal position of the motor. virtual Result configure () Configure dynamixel motor. virtual void appendStateInterfaces (std::vector< hardware_interface::StateInterface > & interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces (std::vector< hardware_interface::CommandInterface > & interfaces) Append command interface described in the URDF file. template \\<typename AddressTable > MotorBase (const SupportedMotors & motor_type, const std::string & joint_name, const bool enable_dummy, const AddressTable & table, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Construct a new Motor Base object.","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#protected-functions","text":"Name template \\<typename T > T radianToPosition (double radian) const uint16_t radianToPosition (double radian) const virtual void radianToPosition (double radian, uint8_t & value) const virtual void radianToPosition (double radian, uint16_t & value) const virtual void radianToPosition (double radian, uint32_t & value) const virtual double positionToRadian (const uint8_t position) const virtual double positionToRadian (const uint16_t position) const virtual double positionToRadian (const uint32_t position) const Result getResult (int communication_result, uint8_t packet_error) MotorBase () Construct a new Motor Base object.","title":"Protected Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#public-attributes","text":"Name const SupportedMotors motor_type Describe the type of the motor. const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication.","title":"Public Attributes"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#protected-attributes","text":"Name std::shared_ptr< dynamixel::PortHandler > port_handler_ std::shared_ptr< dynamixel::PacketHandler > packet_handler_ double joint_position_ double goal_position_ std::shared_ptr< AddressTableBase > address_table_","title":"Protected Attributes"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-motorbase","text":"~ MotorBase () Destroy the Motor Base object.","title":"function ~MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-updatejointposition","text":"virtual Result updateJointPosition () Execute update joint position command to the motor. Return : Result result of the command.","title":"function updateJointPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-torqueenable","text":"virtual Result torqueEnable ( bool enable ) Execute torqu_enabled command to the motor. Parameters : enable if true, enable torque. Return : Result result of the command.","title":"function torqueEnable"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-setgoalposition","text":"virtual Result setGoalPosition ( double goal_position ) Execute goal_position command to the motor. Parameters : goal_position goal position angle in radian. Return : Result result of the command.","title":"function setGoalPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-setcurrentgoalposition","text":"inline virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. Return : Result result of the command.","title":"function setCurrentGoalPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-operationsupports","text":"bool operationSupports ( const Operation & operation ) Check the operation is support in your motor. Parameters : operation Operation which you want to execute. Return : true Operation supports. false Operation does not support.","title":"function operationSupports"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-getsupportedoperations","text":"virtual std :: vector < Operation > getSupportedOperations () Get list of supported Operations in your motor. Return : std::vector List of supported operations.","title":"function getSupportedOperations"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-getjointposition","text":"inline virtual double getJointPosition () const Get current joint position of the motor. Return : double Current joint position of the motor in radian.","title":"function getJointPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-getgoalposition","text":"inline virtual double getGoalPosition () const Get current goal position of the motor. Return : double Current goal position of the motor in radian.","title":"function getGoalPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-configure","text":"virtual Result configure () Configure dynamixel motor. Return : Result result of the configuration.","title":"function configure"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-appendstateinterfaces","text":"virtual void appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ) Append state interface described in the URDF file. Parameters : interfaces List of state interface.","title":"function appendStateInterfaces"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-appendcommandinterfaces","text":"virtual void appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ) Append command interface described in the URDF file. Parameters : interfaces List of command interface.","title":"function appendCommandInterfaces"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-motorbase_1","text":"template < typename AddressTable > inline MotorBase ( const SupportedMotors & motor_type , const std :: string & joint_name , const bool enable_dummy , const AddressTable & table , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) Construct a new Motor Base object. Parameters : motor_type Type of the motor. joint_name Name of the joint which the motor is attaching to. enable_dummy If true, you can communicate with virtual dinamixel motor. table address table of the motor. baudrate Baudrate of the serial communication. id Id of the dynamixel motor. port_handler Port handler class of the dynamixel sdk. packet_handler Packet handler class of the dynamixel sdk Template Parameters : AddressTable address table type of the motor.","title":"function MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition","text":"template < typename T > inline T radianToPosition ( double radian ) const","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition_1","text":"uint16_t radianToPosition ( double radian ) const","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition_2","text":"inline virtual void radianToPosition ( double radian , uint8_t & value ) const","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition_3","text":"inline virtual void radianToPosition ( double radian , uint16_t & value ) const","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition_4","text":"inline virtual void radianToPosition ( double radian , uint32_t & value ) const","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-positiontoradian","text":"virtual double positionToRadian ( const uint8_t position ) const","title":"function positionToRadian"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-positiontoradian_1","text":"virtual double positionToRadian ( const uint16_t position ) const","title":"function positionToRadian"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-positiontoradian_2","text":"virtual double positionToRadian ( const uint32_t position ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::positionToRadian","title":"function positionToRadian"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-getresult","text":"Result getResult ( int communication_result , uint8_t packet_error )","title":"function getResult"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-motorbase_2","text":"MotorBase () Construct a new Motor Base object.","title":"function MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-motor_type","text":"const SupportedMotors motor_type ; Describe the type of the motor.","title":"variable motor_type"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-joint_name","text":"const std :: string joint_name ; Name of the joint which the motor is attaching to.","title":"variable joint_name"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-id","text":"const uint8_t id ; Id of the dynamixel motor.","title":"variable id"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-enable_dummy","text":"const bool enable_dummy ; If true, you can communicate with virtual dinamixel motor.","title":"variable enable_dummy"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-baudrate","text":"const int baudrate ; Baudrate of the serial communication.","title":"variable baudrate"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-port_handler_","text":"std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ;","title":"variable port_handler_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-packet_handler_","text":"std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ;","title":"variable packet_handler_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-joint_position_","text":"double joint_position_ ;","title":"variable joint_position_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-goal_position_","text":"double goal_position_ ;","title":"variable goal_position_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-address_table_","text":"std :: shared_ptr < AddressTableBase > address_table_ ; Updated on 5 May 2021 at 09:17:41 UTC","title":"variable address_table_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/","text":"dynamixel_hardware_interface::address_tables::XW540_T260 # Inherits from dynamixel_hardware_interface::AddressTableBase Public Functions # Name XW540_T260 () Additional inherited members # Public Functions inherited from dynamixel_hardware_interface::AddressTableBase Name Address getAddress (const Operation & operaiton) const Get address of which operation you want to execute. bool addressExists (const Operation & operation) const Check the address exists or not. AddressTableBase ( Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE) Construct a new Address Table Base object, each parameter describes the address of the operation. Public Functions Documentation # function XW540_T260 # inline XW540_T260 () Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface::address_tables::XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/#dynamixel_hardware_interfaceaddress_tablesxw540_t260","text":"Inherits from dynamixel_hardware_interface::AddressTableBase","title":"dynamixel_hardware_interface::address_tables::XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/#public-functions","text":"Name XW540_T260 ()","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/#additional-inherited-members","text":"Public Functions inherited from dynamixel_hardware_interface::AddressTableBase Name Address getAddress (const Operation & operaiton) const Get address of which operation you want to execute. bool addressExists (const Operation & operation) const Check the address exists or not. AddressTableBase ( Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE) Construct a new Address Table Base object, each parameter describes the address of the operation.","title":"Additional inherited members"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/#function-xw540_t260","text":"inline XW540_T260 () Updated on 5 May 2021 at 09:17:41 UTC","title":"function XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/","text":"dynamixel_hardware_interface::motors::XW540_T260 # Inherits from dynamixel_hardware_interface::MotorBase Public Functions # Name virtual double positionToRadian (const uint32_t position) const override XW540_T260 (const std::string joint_name, bool enable_dummy, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Additional inherited members # Public Functions inherited from dynamixel_hardware_interface::MotorBase Name ~MotorBase () Destroy the Motor Base object. virtual Result updateJointPosition () Execute update joint position command to the motor. virtual Result torqueEnable (bool enable) Execute torqu_enabled command to the motor. virtual Result setGoalPosition (double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. bool operationSupports (const Operation & operation) Check the operation is support in your motor. virtual std::vector< Operation > getSupportedOperations () Get list of supported Operations in your motor. virtual double getJointPosition () const Get current joint position of the motor. virtual double getGoalPosition () const Get current goal position of the motor. virtual Result configure () Configure dynamixel motor. virtual void appendStateInterfaces (std::vector< hardware_interface::StateInterface > & interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces (std::vector< hardware_interface::CommandInterface > & interfaces) Append command interface described in the URDF file. MotorBase (const SupportedMotors & motor_type, const std::string & joint_name, const bool enable_dummy, const AddressTable & table, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Construct a new Motor Base object. Protected Functions inherited from dynamixel_hardware_interface::MotorBase Name T radianToPosition (double radian) const uint16_t radianToPosition (double radian) const virtual void radianToPosition (double radian, uint8_t & value) const virtual void radianToPosition (double radian, uint16_t & value) const virtual void radianToPosition (double radian, uint32_t & value) const Result getResult (int communication_result, uint8_t packet_error) MotorBase () Construct a new Motor Base object. Public Attributes inherited from dynamixel_hardware_interface::MotorBase Name const SupportedMotors motor_type Describe the type of the motor. const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication. Protected Attributes inherited from dynamixel_hardware_interface::MotorBase Name std::shared_ptr< dynamixel::PortHandler > port_handler_ std::shared_ptr< dynamixel::PacketHandler > packet_handler_ double joint_position_ double goal_position_ std::shared_ptr< AddressTableBase > address_table_ Public Functions Documentation # function positionToRadian # inline virtual double positionToRadian ( const uint32_t position ) const override Reimplements : dynamixel_hardware_interface::MotorBase::positionToRadian function XW540_T260 # inline explicit XW540_T260 ( const std :: string joint_name , bool enable_dummy , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface::motors::XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#dynamixel_hardware_interfacemotorsxw540_t260","text":"Inherits from dynamixel_hardware_interface::MotorBase","title":"dynamixel_hardware_interface::motors::XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#public-functions","text":"Name virtual double positionToRadian (const uint32_t position) const override XW540_T260 (const std::string joint_name, bool enable_dummy, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler)","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#additional-inherited-members","text":"Public Functions inherited from dynamixel_hardware_interface::MotorBase Name ~MotorBase () Destroy the Motor Base object. virtual Result updateJointPosition () Execute update joint position command to the motor. virtual Result torqueEnable (bool enable) Execute torqu_enabled command to the motor. virtual Result setGoalPosition (double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. bool operationSupports (const Operation & operation) Check the operation is support in your motor. virtual std::vector< Operation > getSupportedOperations () Get list of supported Operations in your motor. virtual double getJointPosition () const Get current joint position of the motor. virtual double getGoalPosition () const Get current goal position of the motor. virtual Result configure () Configure dynamixel motor. virtual void appendStateInterfaces (std::vector< hardware_interface::StateInterface > & interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces (std::vector< hardware_interface::CommandInterface > & interfaces) Append command interface described in the URDF file. MotorBase (const SupportedMotors & motor_type, const std::string & joint_name, const bool enable_dummy, const AddressTable & table, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Construct a new Motor Base object. Protected Functions inherited from dynamixel_hardware_interface::MotorBase Name T radianToPosition (double radian) const uint16_t radianToPosition (double radian) const virtual void radianToPosition (double radian, uint8_t & value) const virtual void radianToPosition (double radian, uint16_t & value) const virtual void radianToPosition (double radian, uint32_t & value) const Result getResult (int communication_result, uint8_t packet_error) MotorBase () Construct a new Motor Base object. Public Attributes inherited from dynamixel_hardware_interface::MotorBase Name const SupportedMotors motor_type Describe the type of the motor. const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication. Protected Attributes inherited from dynamixel_hardware_interface::MotorBase Name std::shared_ptr< dynamixel::PortHandler > port_handler_ std::shared_ptr< dynamixel::PacketHandler > packet_handler_ double joint_position_ double goal_position_ std::shared_ptr< AddressTableBase > address_table_","title":"Additional inherited members"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#function-positiontoradian","text":"inline virtual double positionToRadian ( const uint32_t position ) const override Reimplements : dynamixel_hardware_interface::MotorBase::positionToRadian","title":"function positionToRadian"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#function-xw540_t260","text":"inline explicit XW540_T260 ( const std :: string joint_name , bool enable_dummy , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) Updated on 5 May 2021 at 09:17:41 UTC","title":"function XW540_T260"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/","text":"dynamixel_hardware_interface::Result # Struct describes the command result. #include <motor_base.hpp> Public Functions # Name Result (const std::string & description, bool success) Construct a new Result object. Public Attributes # Name const bool success If true, command execute successfully. const std::string description Description of the result. Public Functions Documentation # function Result # inline Result ( const std :: string & description , bool success ) Construct a new Result object. Parameters : description Description of the result. success If true, command execute successfully. Public Attributes Documentation # variable success # const bool success ; If true, command execute successfully. variable description # const std :: string description ; Description of the result. Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface::Result"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#dynamixel_hardware_interfaceresult","text":"Struct describes the command result. #include <motor_base.hpp>","title":"dynamixel_hardware_interface::Result"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#public-functions","text":"Name Result (const std::string & description, bool success) Construct a new Result object.","title":"Public Functions"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#public-attributes","text":"Name const bool success If true, command execute successfully. const std::string description Description of the result.","title":"Public Attributes"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#function-result","text":"inline Result ( const std :: string & description , bool success ) Construct a new Result object. Parameters : description Description of the result. success If true, command execute successfully.","title":"function Result"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#variable-success","text":"const bool success ; If true, command execute successfully.","title":"variable success"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#variable-description","text":"const std :: string description ; Description of the result. Updated on 5 May 2021 at 09:17:41 UTC","title":"variable description"},{"location":"doxygen/markdown/Examples/","text":"Examples # Updated on 5 May 2021 at 09:17:41 UTC","title":"Examples"},{"location":"doxygen/markdown/Examples/#examples","text":"Updated on 5 May 2021 at 09:17:41 UTC","title":"Examples"},{"location":"doxygen/markdown/Files/","text":"Files # dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. Updated on 5 May 2021 at 09:17:41 UTC","title":"Files"},{"location":"doxygen/markdown/Files/#files","text":"dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. Updated on 5 May 2021 at 09:17:41 UTC","title":"Files"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp # Base class for the address tabele. More... Namespaces # Name dynamixel_hardware_interface Classes # Name class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address Detailed Description # Base class for the address tabele. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ #include <boost/optional.hpp> #include <cmath> #include <dynamixel_hardware_interface/constants.hpp> #include <limits> namespace dynamixel_hardware_interface { class Address { public : Address ( uint16_t address , PacketByteSize byte_size ) : address ( address ), byte_size ( byte_size ) {} Address () : address ( 0 ), byte_size ( PacketByteSize :: INVALID ) {} const uint16_t address ; const PacketByteSize byte_size ; bool exists () const { if ( byte_size == PacketByteSize :: INVALID ) { return false ; } return true ; } }; class AddressTableBase { public : explicit AddressTableBase ( Address ADDR_TORQUE_ENABLE , Address ADDR_GOAL_POSITION , Address ADDR_MOVING_SPEED , Address ADDR_PRESENT_POSITION , Address ADDR_PRESENT_SPEED , Address ADDR_PRESENT_LOAD , Address ADDR_PRESENT_VOLTAGE , Address ADDR_PRESENT_TEMPERATURE ) : ADDR_TORQUE_ENABLE ( ADDR_TORQUE_ENABLE ), ADDR_GOAL_POSITION ( ADDR_GOAL_POSITION ), ADDR_MOVING_SPEED ( ADDR_MOVING_SPEED ), ADDR_PRESENT_POSITION ( ADDR_PRESENT_POSITION ), ADDR_PRESENT_SPEED ( ADDR_PRESENT_SPEED ), ADDR_PRESENT_LOAD ( ADDR_PRESENT_LOAD ), ADDR_PRESENT_VOLTAGE ( ADDR_PRESENT_VOLTAGE ), ADDR_PRESENT_TEMPERATURE ( ADDR_PRESENT_TEMPERATURE ) { } Address getAddress ( const Operation & operaiton ) const { switch ( operaiton ) { case Operation :: TORQUE_ENABLE : return ADDR_TORQUE_ENABLE ; case Operation :: GOAL_POSITION : return ADDR_GOAL_POSITION ; case Operation :: MOVING_SPEED : return ADDR_MOVING_SPEED ; case Operation :: PRESENT_POSITION : return ADDR_PRESENT_POSITION ; case Operation :: PRESENT_SPEED : return ADDR_PRESENT_SPEED ; case Operation :: PRESENT_LOAD : return ADDR_PRESENT_LOAD ; case Operation :: PRESENT_VOLTAGE : return ADDR_PRESENT_VOLTAGE ; case Operation :: PRESENT_TEMPERATURE : return ADDR_PRESENT_TEMPERATURE ; default : return Address (); } } bool addressExists ( const Operation & operation ) const { return getAddress ( operation ). exists (); } private : AddressTableBase () = delete ; const Address ADDR_TORQUE_ENABLE ; const Address ADDR_GOAL_POSITION ; const Address ADDR_MOVING_SPEED ; const Address ADDR_PRESENT_POSITION ; const Address ADDR_PRESENT_SPEED ; const Address ADDR_PRESENT_LOAD ; const Address ADDR_PRESENT_VOLTAGE ; const Address ADDR_PRESENT_TEMPERATURE ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfaceaddress_table_basehpp","text":"Base class for the address tabele. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/#classes","text":"Name class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address","title":"Classes"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/#detailed-description","text":"Base class for the address tabele. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ #include <boost/optional.hpp> #include <cmath> #include <dynamixel_hardware_interface/constants.hpp> #include <limits> namespace dynamixel_hardware_interface { class Address { public : Address ( uint16_t address , PacketByteSize byte_size ) : address ( address ), byte_size ( byte_size ) {} Address () : address ( 0 ), byte_size ( PacketByteSize :: INVALID ) {} const uint16_t address ; const PacketByteSize byte_size ; bool exists () const { if ( byte_size == PacketByteSize :: INVALID ) { return false ; } return true ; } }; class AddressTableBase { public : explicit AddressTableBase ( Address ADDR_TORQUE_ENABLE , Address ADDR_GOAL_POSITION , Address ADDR_MOVING_SPEED , Address ADDR_PRESENT_POSITION , Address ADDR_PRESENT_SPEED , Address ADDR_PRESENT_LOAD , Address ADDR_PRESENT_VOLTAGE , Address ADDR_PRESENT_TEMPERATURE ) : ADDR_TORQUE_ENABLE ( ADDR_TORQUE_ENABLE ), ADDR_GOAL_POSITION ( ADDR_GOAL_POSITION ), ADDR_MOVING_SPEED ( ADDR_MOVING_SPEED ), ADDR_PRESENT_POSITION ( ADDR_PRESENT_POSITION ), ADDR_PRESENT_SPEED ( ADDR_PRESENT_SPEED ), ADDR_PRESENT_LOAD ( ADDR_PRESENT_LOAD ), ADDR_PRESENT_VOLTAGE ( ADDR_PRESENT_VOLTAGE ), ADDR_PRESENT_TEMPERATURE ( ADDR_PRESENT_TEMPERATURE ) { } Address getAddress ( const Operation & operaiton ) const { switch ( operaiton ) { case Operation :: TORQUE_ENABLE : return ADDR_TORQUE_ENABLE ; case Operation :: GOAL_POSITION : return ADDR_GOAL_POSITION ; case Operation :: MOVING_SPEED : return ADDR_MOVING_SPEED ; case Operation :: PRESENT_POSITION : return ADDR_PRESENT_POSITION ; case Operation :: PRESENT_SPEED : return ADDR_PRESENT_SPEED ; case Operation :: PRESENT_LOAD : return ADDR_PRESENT_LOAD ; case Operation :: PRESENT_VOLTAGE : return ADDR_PRESENT_VOLTAGE ; case Operation :: PRESENT_TEMPERATURE : return ADDR_PRESENT_TEMPERATURE ; default : return Address (); } } bool addressExists ( const Operation & operation ) const { return getAddress ( operation ). exists (); } private : AddressTableBase () = delete ; const Address ADDR_TORQUE_ENABLE ; const Address ADDR_GOAL_POSITION ; const Address ADDR_MOVING_SPEED ; const Address ADDR_PRESENT_POSITION ; const Address ADDR_PRESENT_SPEED ; const Address ADDR_PRESENT_LOAD ; const Address ADDR_PRESENT_VOLTAGE ; const Address ADDR_PRESENT_TEMPERATURE ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/constants_8hpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp # Header for defineing constant values. More... Namespaces # Name dynamixel_hardware_interface Defines # Name GENERATE_ENUM_ITERATOR (T, LAST_VALUE) Detailed Description # Header for defineing constant values. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Macro Documentation # define GENERATE_ENUM_ITERATOR # #define GENERATE_ENUM_ITERATOR( T , LAST_VALUE ) inline T operator ++ ( T & x ) { return x = ( T )( std :: underlying_type < T >:: type ( x ) + 1 ); } \\ inline T operator * ( T c ) { return c ; } \\ inline T begin ( T ) { return static_cast < T > ( 0 ); } \\ inline T end ( T ) \\ { \\ T l = T :: LAST_VALUE ; \\ return l ; \\ } Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ #include <cmath> #include <cstdint> #include <stdexcept> #include <string> namespace dynamixel_hardware_interface { constexpr double PROTOCOL_VERSION = 2.0 ; constexpr int DXL_HOME_POSITION = 0 ; // value range:0 ~ 1023 constexpr double DXL_MAX_POSITION = 1023.0 ; constexpr double DXL_MAX_POSITION_DEGREES = 300.0 ; constexpr double TO_RADIANS = ( DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION ) * M_PI / 180.0 ; constexpr double TO_DXL_POS = 1.0 / TO_RADIANS ; constexpr double TO_SPEED_REV_PER_MIN = 0.111 ; constexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI ; constexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0 ; constexpr double TO_LOAD_PERCENT = 0.1 ; constexpr double TO_VOLTAGE = 0.1 ; constexpr double PULSE_RESOLUTION = 4096 ; #define GENERATE_ENUM_ITERATOR(T, LAST_VALUE) \\ inline T operator++(T & x) { return x = (T)(std::underlying_type<T>::type(x) + 1); } \\ inline T operator*(T c) { return c; } \\ inline T begin(T) { return static_cast<T>(0); } \\ inline T end(T) \\ { \\ T l = T::LAST_VALUE; \\ return l; \\ } enum class Operation { TORQUE_ENABLE , GOAL_POSITION , MOVING_SPEED , PRESENT_POSITION , PRESENT_SPEED , PRESENT_LOAD , PRESENT_VOLTAGE , PRESENT_TEMPERATURE }; GENERATE_ENUM_ITERATOR ( Operation , PRESENT_TEMPERATURE ) enum class SupportedMotors { XW540_T260 , INVALID }; GENERATE_ENUM_ITERATOR ( SupportedMotors , INVALID ) enum class PacketByteSize { ONE_BYTE , TWO_BYTE , FOUR_BYTE , INVALID }; GENERATE_ENUM_ITERATOR ( PacketByteSize , INVALID ) } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp"},{"location":"doxygen/markdown/Files/constants_8hpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfaceconstantshpp","text":"Header for defineing constant values. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp"},{"location":"doxygen/markdown/Files/constants_8hpp/#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/constants_8hpp/#defines","text":"Name GENERATE_ENUM_ITERATOR (T, LAST_VALUE)","title":"Defines"},{"location":"doxygen/markdown/Files/constants_8hpp/#detailed-description","text":"Header for defineing constant values. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/constants_8hpp/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"doxygen/markdown/Files/constants_8hpp/#define-generate_enum_iterator","text":"#define GENERATE_ENUM_ITERATOR( T , LAST_VALUE ) inline T operator ++ ( T & x ) { return x = ( T )( std :: underlying_type < T >:: type ( x ) + 1 ); } \\ inline T operator * ( T c ) { return c ; } \\ inline T begin ( T ) { return static_cast < T > ( 0 ); } \\ inline T end ( T ) \\ { \\ T l = T :: LAST_VALUE ; \\ return l ; \\ }","title":"define GENERATE_ENUM_ITERATOR"},{"location":"doxygen/markdown/Files/constants_8hpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ #include <cmath> #include <cstdint> #include <stdexcept> #include <string> namespace dynamixel_hardware_interface { constexpr double PROTOCOL_VERSION = 2.0 ; constexpr int DXL_HOME_POSITION = 0 ; // value range:0 ~ 1023 constexpr double DXL_MAX_POSITION = 1023.0 ; constexpr double DXL_MAX_POSITION_DEGREES = 300.0 ; constexpr double TO_RADIANS = ( DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION ) * M_PI / 180.0 ; constexpr double TO_DXL_POS = 1.0 / TO_RADIANS ; constexpr double TO_SPEED_REV_PER_MIN = 0.111 ; constexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI ; constexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0 ; constexpr double TO_LOAD_PERCENT = 0.1 ; constexpr double TO_VOLTAGE = 0.1 ; constexpr double PULSE_RESOLUTION = 4096 ; #define GENERATE_ENUM_ITERATOR(T, LAST_VALUE) \\ inline T operator++(T & x) { return x = (T)(std::underlying_type<T>::type(x) + 1); } \\ inline T operator*(T c) { return c; } \\ inline T begin(T) { return static_cast<T>(0); } \\ inline T end(T) \\ { \\ T l = T::LAST_VALUE; \\ return l; \\ } enum class Operation { TORQUE_ENABLE , GOAL_POSITION , MOVING_SPEED , PRESENT_POSITION , PRESENT_SPEED , PRESENT_LOAD , PRESENT_VOLTAGE , PRESENT_TEMPERATURE }; GENERATE_ENUM_ITERATOR ( Operation , PRESENT_TEMPERATURE ) enum class SupportedMotors { XW540_T260 , INVALID }; GENERATE_ENUM_ITERATOR ( SupportedMotors , INVALID ) enum class PacketByteSize { ONE_BYTE , TWO_BYTE , FOUR_BYTE , INVALID }; GENERATE_ENUM_ITERATOR ( PacketByteSize , INVALID ) } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src # Files # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfacesrc","text":"","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. Updated on 5 May 2021 at 09:17:41 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_928fd2f9e5178dedf5db7221eddd41a5/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors # Files # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors"},{"location":"doxygen/markdown/Files/dir_928fd2f9e5178dedf5db7221eddd41a5/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacemotors","text":"","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors"},{"location":"doxygen/markdown/Files/dir_928fd2f9e5178dedf5db7221eddd41a5/#files","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. Updated on 5 May 2021 at 09:17:41 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface # Directories # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors Files # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interface","text":"","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b/#directories","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors","title":"Directories"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b/#files","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. Updated on 5 May 2021 at 09:17:41 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include # Directories # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceinclude","text":"","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23/#directories","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface Updated on 5 May 2021 at 09:17:41 UTC","title":"Directories"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp # Class implementation of the hardware interface for the Dynamixel motor. More... Namespaces # Name dynamixel_hardware_interface Detailed Description # Class implementation of the hardware interface for the Dynamixel motor. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/dynamixel_hardware_interface.hpp> #include <memory> #include <string> #include <vector> namespace dynamixel_hardware_interface { hardware_interface :: return_type DynamixelHardwareInterface::configure ( const hardware_interface :: HardwareInfo & info ) { if ( configure_default ( info ) != hardware_interface :: return_type :: OK ) { return hardware_interface :: return_type :: ERROR ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"configure hardware \" + info . name ); for ( const auto hardware_parameter : info_ . hardware_parameters ) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"hardware parameter : \" << hardware_parameter . first << \" = \" << hardware_parameter . second ); } port_name_ = getHardwareParameter < std :: string > ( \"port_name\" ); baudrate_ = getHardwareParameter < int > ( \"baudrate\" ); RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"initialize port handler\" ); port_handler_ = std :: shared_ptr < dynamixel :: PortHandler > ( dynamixel :: PortHandler :: getPortHandler ( port_name_ . c_str ())); RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"initialize packet handler\" ); packet_handler_ = std :: shared_ptr < dynamixel :: PacketHandler > ( dynamixel :: PacketHandler :: getPacketHandler ( PROTOCOL_VERSION )); if ( ! getHardwareParameter < bool > ( \"enable_dummy\" )) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"serial port : \" << port_handler_ -> getPortName ()); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"baudrate : \" << port_handler_ -> getBaudRate ()); if ( port_handler_ -> openPort ()) { RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"open serial port succeed\" ); } else { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"open serial port failed\" ); return hardware_interface :: return_type :: ERROR ; } } RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"configure each motors\" ); for ( const auto joint : info . joints ) { std :: shared_ptr < MotorBase > motor ; try { motor = constructMotorInstance ( joint ); } catch ( const std :: runtime_error & e ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), e . what ()); return hardware_interface :: return_type :: ERROR ; } const auto result = motor -> configure (); if ( ! result . success ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } motors_ . emplace_back ( motor ); } return hardware_interface :: return_type :: OK ; } std :: vector < hardware_interface :: StateInterface > DynamixelHardwareInterface :: export_state_interfaces () { std :: vector < hardware_interface :: StateInterface > state_interfaces = {}; for ( const auto motor : motors_ ) { motor -> appendStateInterfaces ( state_interfaces ); } RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), state_interfaces . size () << \" state interfaces exported.\" ); return state_interfaces ; } std :: vector < hardware_interface :: CommandInterface > DynamixelHardwareInterface :: export_command_interfaces () { std :: vector < hardware_interface :: CommandInterface > command_interfaces = {}; for ( const auto motor : motors_ ) { motor -> appendCommandInterfaces ( command_interfaces ); } RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), command_interfaces . size () << \" command interfaces exported.\" ); return command_interfaces ; } SupportedMotors DynamixelHardwareInterface :: strToSupportMotorsEnum ( const std :: string & motor_type ) const { if ( motor_type == \"XW540-T260\" ) { return SupportedMotors :: XW540_T260 ; } return SupportedMotors :: INVALID ; } std :: shared_ptr < MotorBase > DynamixelHardwareInterface :: constructMotorInstance ( const hardware_interface :: ComponentInfo & info ) const { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"constructing motor instance : \" << info . name ); for ( const auto parameter : info . parameters ) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"parameter \" << parameter . first << \" : \" << parameter . second ); } if ( info . type == \"joint\" ) { const auto motor_type = strToSupportMotorsEnum ( getParameter < std :: string > ( \"motor_type\" , info )); if ( motor_type == SupportedMotors :: INVALID ) { throw std :: runtime_error ( \"failed to construct motor instance, motor type is invalid\" ); } const auto id = static_cast < uint8_t > ( getParameter < int > ( \"id\" , info )); switch ( motor_type ) { case SupportedMotors :: XW540_T260 : return std :: make_shared < motors :: XW540_T260 > ( info . name , getHardwareParameter < bool > ( \"enable_dummy\" ), baudrate_ , id , port_handler_ , packet_handler_ ); break ; default : break ; } } throw std :: runtime_error ( \"failed to construct motor instance\" ); } hardware_interface :: return_type DynamixelHardwareInterface :: start () { status_ = hardware_interface :: status :: STARTED ; return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: stop () { return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: read () { for ( const auto motor : motors_ ) { if ( motor -> operationSupports ( Operation :: PRESENT_POSITION )) { const auto result = motor -> updateJointPosition (); if ( result . success ) { motor -> getJointPosition (); } else { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } } } return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: write () { for ( const auto motor : motors_ ) { if ( motor -> operationSupports ( Operation :: GOAL_POSITION )) { motor -> setCurrentGoalPosition (); } } return hardware_interface :: return_type :: OK ; } } // namespace dynamixel_hardware_interface #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS ( dynamixel_hardware_interface :: DynamixelHardwareInterface , hardware_interface :: SystemInterface ) Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfacesrcdynamixel_hardware_interfacecpp","text":"Class implementation of the hardware interface for the Dynamixel motor. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp/#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp/#detailed-description","text":"Class implementation of the hardware interface for the Dynamixel motor. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/dynamixel_hardware_interface.hpp> #include <memory> #include <string> #include <vector> namespace dynamixel_hardware_interface { hardware_interface :: return_type DynamixelHardwareInterface::configure ( const hardware_interface :: HardwareInfo & info ) { if ( configure_default ( info ) != hardware_interface :: return_type :: OK ) { return hardware_interface :: return_type :: ERROR ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"configure hardware \" + info . name ); for ( const auto hardware_parameter : info_ . hardware_parameters ) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"hardware parameter : \" << hardware_parameter . first << \" = \" << hardware_parameter . second ); } port_name_ = getHardwareParameter < std :: string > ( \"port_name\" ); baudrate_ = getHardwareParameter < int > ( \"baudrate\" ); RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"initialize port handler\" ); port_handler_ = std :: shared_ptr < dynamixel :: PortHandler > ( dynamixel :: PortHandler :: getPortHandler ( port_name_ . c_str ())); RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"initialize packet handler\" ); packet_handler_ = std :: shared_ptr < dynamixel :: PacketHandler > ( dynamixel :: PacketHandler :: getPacketHandler ( PROTOCOL_VERSION )); if ( ! getHardwareParameter < bool > ( \"enable_dummy\" )) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"serial port : \" << port_handler_ -> getPortName ()); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"baudrate : \" << port_handler_ -> getBaudRate ()); if ( port_handler_ -> openPort ()) { RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"open serial port succeed\" ); } else { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"open serial port failed\" ); return hardware_interface :: return_type :: ERROR ; } } RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"configure each motors\" ); for ( const auto joint : info . joints ) { std :: shared_ptr < MotorBase > motor ; try { motor = constructMotorInstance ( joint ); } catch ( const std :: runtime_error & e ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), e . what ()); return hardware_interface :: return_type :: ERROR ; } const auto result = motor -> configure (); if ( ! result . success ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } motors_ . emplace_back ( motor ); } return hardware_interface :: return_type :: OK ; } std :: vector < hardware_interface :: StateInterface > DynamixelHardwareInterface :: export_state_interfaces () { std :: vector < hardware_interface :: StateInterface > state_interfaces = {}; for ( const auto motor : motors_ ) { motor -> appendStateInterfaces ( state_interfaces ); } RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), state_interfaces . size () << \" state interfaces exported.\" ); return state_interfaces ; } std :: vector < hardware_interface :: CommandInterface > DynamixelHardwareInterface :: export_command_interfaces () { std :: vector < hardware_interface :: CommandInterface > command_interfaces = {}; for ( const auto motor : motors_ ) { motor -> appendCommandInterfaces ( command_interfaces ); } RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), command_interfaces . size () << \" command interfaces exported.\" ); return command_interfaces ; } SupportedMotors DynamixelHardwareInterface :: strToSupportMotorsEnum ( const std :: string & motor_type ) const { if ( motor_type == \"XW540-T260\" ) { return SupportedMotors :: XW540_T260 ; } return SupportedMotors :: INVALID ; } std :: shared_ptr < MotorBase > DynamixelHardwareInterface :: constructMotorInstance ( const hardware_interface :: ComponentInfo & info ) const { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"constructing motor instance : \" << info . name ); for ( const auto parameter : info . parameters ) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"parameter \" << parameter . first << \" : \" << parameter . second ); } if ( info . type == \"joint\" ) { const auto motor_type = strToSupportMotorsEnum ( getParameter < std :: string > ( \"motor_type\" , info )); if ( motor_type == SupportedMotors :: INVALID ) { throw std :: runtime_error ( \"failed to construct motor instance, motor type is invalid\" ); } const auto id = static_cast < uint8_t > ( getParameter < int > ( \"id\" , info )); switch ( motor_type ) { case SupportedMotors :: XW540_T260 : return std :: make_shared < motors :: XW540_T260 > ( info . name , getHardwareParameter < bool > ( \"enable_dummy\" ), baudrate_ , id , port_handler_ , packet_handler_ ); break ; default : break ; } } throw std :: runtime_error ( \"failed to construct motor instance\" ); } hardware_interface :: return_type DynamixelHardwareInterface :: start () { status_ = hardware_interface :: status :: STARTED ; return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: stop () { return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: read () { for ( const auto motor : motors_ ) { if ( motor -> operationSupports ( Operation :: PRESENT_POSITION )) { const auto result = motor -> updateJointPosition (); if ( result . success ) { motor -> getJointPosition (); } else { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } } } return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: write () { for ( const auto motor : motors_ ) { if ( motor -> operationSupports ( Operation :: GOAL_POSITION )) { motor -> setCurrentGoalPosition (); } } return hardware_interface :: return_type :: OK ; } } // namespace dynamixel_hardware_interface #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS ( dynamixel_hardware_interface :: DynamixelHardwareInterface , hardware_interface :: SystemInterface ) Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp # Hardware interface class for dynamixel motor. More... Namespaces # Name dynamixel_hardware_interface Classes # Name class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor. Detailed Description # Hardware interface class for dynamixel motor. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ #include <dynamixel_hardware_interface/visiblity_control.h> #include <dynamixel_sdk/dynamixel_sdk.h> #include <dynamixel_hardware_interface/motors/motors.hpp> #include <hardware_interface/base_interface.hpp> #include <hardware_interface/handle.hpp> #include <hardware_interface/hardware_info.hpp> #include <hardware_interface/system_interface.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_status_values.hpp> #include <memory> #include <rclcpp/rclcpp.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { class DynamixelHardwareInterface : public hardware_interface :: BaseInterface < hardware_interface :: SystemInterface > { public : RCLCPP_SHARED_PTR_DEFINITIONS ( DynamixelHardwareInterface ) DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type configure ( const hardware_interface :: HardwareInfo & info ) override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: StateInterface > export_state_interfaces () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: CommandInterface > export_command_interfaces () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type start () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type stop () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type read () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type write () override ; private : std :: string port_name_ ; int baudrate_ ; SupportedMotors strToSupportMotorsEnum ( const std :: string & motor_type ) const ; template < typename T > T getParameter ( const std :: string key , const hardware_interface :: ComponentInfo & info ) const { T param ; getParameter ( key , info , param ); return param ; } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , std :: string & parameter ) const { try { parameter = info . parameters . at ( key ); } catch ( std :: out_of_range & e ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"parameter : \" << key << \" does not exist.\" ); } } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , int & parameter ) const { std :: string param_string ; getParameter ( key , info , param_string ); parameter = std :: stoi ( param_string ); } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , bool & parameter ) const { parameter = false ; std :: string param_string ; getParameter ( key , info , param_string ); if ( param_string == \"true\" || param_string == \"True\" ) { parameter = true ; } } template < typename T > T getHardwareParameter ( const std :: string key ) const { T param ; getHardwareParameter ( key , param ); return param ; } void getHardwareParameter ( const std :: string & key , std :: string & parameter ) const { try { parameter = info_ . hardware_parameters . at ( key ); } catch ( std :: out_of_range & e ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"hardware parameter : \" << key << \" does not exist.\" ); } } void getHardwareParameter ( const std :: string & key , int & parameter ) const { std :: string param_string ; getHardwareParameter ( key , param_string ); parameter = std :: stoi ( param_string ); } void getHardwareParameter ( const std :: string & key , bool & parameter ) const { parameter = false ; std :: string param_string ; getHardwareParameter ( key , param_string ); if ( param_string == \"true\" || param_string == \"True\" ) { parameter = true ; } } std :: shared_ptr < MotorBase > constructMotorInstance ( const hardware_interface :: ComponentInfo & info ) const ; std :: vector < std :: shared_ptr < MotorBase >> motors_ ; std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacedynamixel_hardware_interfacehpp","text":"Hardware interface class for dynamixel motor. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/#classes","text":"Name class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor.","title":"Classes"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/#detailed-description","text":"Hardware interface class for dynamixel motor. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ #include <dynamixel_hardware_interface/visiblity_control.h> #include <dynamixel_sdk/dynamixel_sdk.h> #include <dynamixel_hardware_interface/motors/motors.hpp> #include <hardware_interface/base_interface.hpp> #include <hardware_interface/handle.hpp> #include <hardware_interface/hardware_info.hpp> #include <hardware_interface/system_interface.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_status_values.hpp> #include <memory> #include <rclcpp/rclcpp.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { class DynamixelHardwareInterface : public hardware_interface :: BaseInterface < hardware_interface :: SystemInterface > { public : RCLCPP_SHARED_PTR_DEFINITIONS ( DynamixelHardwareInterface ) DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type configure ( const hardware_interface :: HardwareInfo & info ) override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: StateInterface > export_state_interfaces () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: CommandInterface > export_command_interfaces () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type start () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type stop () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type read () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type write () override ; private : std :: string port_name_ ; int baudrate_ ; SupportedMotors strToSupportMotorsEnum ( const std :: string & motor_type ) const ; template < typename T > T getParameter ( const std :: string key , const hardware_interface :: ComponentInfo & info ) const { T param ; getParameter ( key , info , param ); return param ; } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , std :: string & parameter ) const { try { parameter = info . parameters . at ( key ); } catch ( std :: out_of_range & e ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"parameter : \" << key << \" does not exist.\" ); } } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , int & parameter ) const { std :: string param_string ; getParameter ( key , info , param_string ); parameter = std :: stoi ( param_string ); } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , bool & parameter ) const { parameter = false ; std :: string param_string ; getParameter ( key , info , param_string ); if ( param_string == \"true\" || param_string == \"True\" ) { parameter = true ; } } template < typename T > T getHardwareParameter ( const std :: string key ) const { T param ; getHardwareParameter ( key , param ); return param ; } void getHardwareParameter ( const std :: string & key , std :: string & parameter ) const { try { parameter = info_ . hardware_parameters . at ( key ); } catch ( std :: out_of_range & e ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"hardware parameter : \" << key << \" does not exist.\" ); } } void getHardwareParameter ( const std :: string & key , int & parameter ) const { std :: string param_string ; getHardwareParameter ( key , param_string ); parameter = std :: stoi ( param_string ); } void getHardwareParameter ( const std :: string & key , bool & parameter ) const { parameter = false ; std :: string param_string ; getHardwareParameter ( key , param_string ); if ( param_string == \"true\" || param_string == \"True\" ) { parameter = true ; } } std :: shared_ptr < MotorBase > constructMotorInstance ( const hardware_interface :: ComponentInfo & info ) const ; std :: vector < std :: shared_ptr < MotorBase >> motors_ ; std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/motor__base_8cpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp # Implementation of the motor class. More... Namespaces # Name dynamixel_hardware_interface Detailed Description # Implementation of the motor class. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/motor_base.hpp> #include <dynamixel_hardware_interface/util.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_type_values.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { MotorBase ::~ MotorBase () {} bool MotorBase :: operationSupports ( const Operation & operation ) { const auto address = address_table_ -> getAddress ( operation ); if ( ! address . exists ()) { return false ; } return true ; } std :: vector < Operation > MotorBase :: getSupportedOperations () { std :: vector < Operation > ret = {}; for ( const auto operation : Operation ()) { const auto address = address_table_ -> getAddress ( operation ); if ( address . exists ()) { ret . emplace_back ( operation ); } } return ret ; } uint16_t MotorBase :: radianToPosition ( double radian ) const { return radian * TO_DXL_POS + DXL_HOME_POSITION ; } double MotorBase :: positionToRadian ( const uint8_t position ) const { return static_cast < double > ( position ) / static_cast < double > ( 256 ) * M_PI * 2 ; } double MotorBase :: positionToRadian ( const uint16_t position ) const { return static_cast < double > ( position ) / static_cast < double > ( 65536 ) * M_PI * 2 ; } double MotorBase :: positionToRadian ( const uint32_t position ) const { return static_cast < double > ( position ) / static_cast < double > ( 4294967296 ) * M_PI * 2 ; } Result MotorBase :: getResult ( int communication_result , uint8_t packet_error ) { if ( communication_result != COMM_SUCCESS ) { return Result ( std :: string ( packet_handler_ -> getTxRxResult ( communication_result )), false ); } if ( packet_error != 0 ) { return Result ( std :: string ( packet_handler_ -> getRxPacketError ( packet_error )), true ); } return Result ( \"\" , true ); } Result MotorBase :: configure () { if ( address_table_ -> addressExists ( Operation :: PRESENT_POSITION )) { joint_position_ = 0 ; } if ( address_table_ -> addressExists ( Operation :: GOAL_POSITION )) { goal_position_ = 0 ; } return Result ( \"\" , true ); } void MotorBase :: appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ) { for ( const auto operation : Operation ()) { if ( address_table_ -> addressExists ( operation )) { switch ( operation ) { case Operation :: PRESENT_POSITION : interfaces . emplace_back ( hardware_interface :: StateInterface ( joint_name , hardware_interface :: HW_IF_POSITION , & joint_position_ )); break ; default : break ; } } } } void MotorBase :: appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ) { for ( const auto operation : Operation ()) { if ( address_table_ -> addressExists ( operation )) { switch ( operation ) { case Operation :: GOAL_POSITION : interfaces . emplace_back ( hardware_interface :: CommandInterface ( joint_name , hardware_interface :: HW_IF_POSITION , & goal_position_ )); break ; default : break ; } } } } Result MotorBase :: torqueEnable ( bool enable ) { const auto address = address_table_ -> getAddress ( Operation :: TORQUE_ENABLE ); if ( ! address . exists ()) { return Result ( \"TORQUE_ENABLE operation does not support in \" + toString ( motor_type ), false ); } uint8_t error = 0 ; const auto result = packet_handler_ -> write1ByteTxRx ( port_handler_ . get (), id , address . address , enable , & error ); return getResult ( result , error ); } Result MotorBase :: setGoalPosition ( double goal_position ) { goal_position_ = goal_position ; const auto address = address_table_ -> getAddress ( Operation :: GOAL_POSITION ); if ( ! address . exists ()) { return Result ( \"TORQUE_ENABLE operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_position_ = goal_position_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { const auto result = packet_handler_ -> write1ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint8_t > ( goal_position_ ), & error ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { const auto result = packet_handler_ -> write2ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint16_t > ( goal_position_ ), & error ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { const auto result = packet_handler_ -> write4ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint32_t > ( goal_position_ ), & error ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } Result MotorBase :: updateJointPosition () { const auto address = address_table_ -> getAddress ( Operation :: PRESENT_POSITION ); if ( ! address . exists ()) { return Result ( \"PRESENT_POSITION operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_position_ = goal_position_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { uint8_t present_position = 0 ; const auto result = packet_handler_ -> read1ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { uint16_t present_position = 0 ; const auto result = packet_handler_ -> read2ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { uint32_t present_position = 0 ; const auto result = packet_handler_ -> read4ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } } // namespace dynamixel_hardware_interface Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp"},{"location":"doxygen/markdown/Files/motor__base_8cpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfacesrcmotor_basecpp","text":"Implementation of the motor class. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp"},{"location":"doxygen/markdown/Files/motor__base_8cpp/#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/motor__base_8cpp/#detailed-description","text":"Implementation of the motor class. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/motor__base_8cpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/motor_base.hpp> #include <dynamixel_hardware_interface/util.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_type_values.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { MotorBase ::~ MotorBase () {} bool MotorBase :: operationSupports ( const Operation & operation ) { const auto address = address_table_ -> getAddress ( operation ); if ( ! address . exists ()) { return false ; } return true ; } std :: vector < Operation > MotorBase :: getSupportedOperations () { std :: vector < Operation > ret = {}; for ( const auto operation : Operation ()) { const auto address = address_table_ -> getAddress ( operation ); if ( address . exists ()) { ret . emplace_back ( operation ); } } return ret ; } uint16_t MotorBase :: radianToPosition ( double radian ) const { return radian * TO_DXL_POS + DXL_HOME_POSITION ; } double MotorBase :: positionToRadian ( const uint8_t position ) const { return static_cast < double > ( position ) / static_cast < double > ( 256 ) * M_PI * 2 ; } double MotorBase :: positionToRadian ( const uint16_t position ) const { return static_cast < double > ( position ) / static_cast < double > ( 65536 ) * M_PI * 2 ; } double MotorBase :: positionToRadian ( const uint32_t position ) const { return static_cast < double > ( position ) / static_cast < double > ( 4294967296 ) * M_PI * 2 ; } Result MotorBase :: getResult ( int communication_result , uint8_t packet_error ) { if ( communication_result != COMM_SUCCESS ) { return Result ( std :: string ( packet_handler_ -> getTxRxResult ( communication_result )), false ); } if ( packet_error != 0 ) { return Result ( std :: string ( packet_handler_ -> getRxPacketError ( packet_error )), true ); } return Result ( \"\" , true ); } Result MotorBase :: configure () { if ( address_table_ -> addressExists ( Operation :: PRESENT_POSITION )) { joint_position_ = 0 ; } if ( address_table_ -> addressExists ( Operation :: GOAL_POSITION )) { goal_position_ = 0 ; } return Result ( \"\" , true ); } void MotorBase :: appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ) { for ( const auto operation : Operation ()) { if ( address_table_ -> addressExists ( operation )) { switch ( operation ) { case Operation :: PRESENT_POSITION : interfaces . emplace_back ( hardware_interface :: StateInterface ( joint_name , hardware_interface :: HW_IF_POSITION , & joint_position_ )); break ; default : break ; } } } } void MotorBase :: appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ) { for ( const auto operation : Operation ()) { if ( address_table_ -> addressExists ( operation )) { switch ( operation ) { case Operation :: GOAL_POSITION : interfaces . emplace_back ( hardware_interface :: CommandInterface ( joint_name , hardware_interface :: HW_IF_POSITION , & goal_position_ )); break ; default : break ; } } } } Result MotorBase :: torqueEnable ( bool enable ) { const auto address = address_table_ -> getAddress ( Operation :: TORQUE_ENABLE ); if ( ! address . exists ()) { return Result ( \"TORQUE_ENABLE operation does not support in \" + toString ( motor_type ), false ); } uint8_t error = 0 ; const auto result = packet_handler_ -> write1ByteTxRx ( port_handler_ . get (), id , address . address , enable , & error ); return getResult ( result , error ); } Result MotorBase :: setGoalPosition ( double goal_position ) { goal_position_ = goal_position ; const auto address = address_table_ -> getAddress ( Operation :: GOAL_POSITION ); if ( ! address . exists ()) { return Result ( \"TORQUE_ENABLE operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_position_ = goal_position_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { const auto result = packet_handler_ -> write1ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint8_t > ( goal_position_ ), & error ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { const auto result = packet_handler_ -> write2ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint16_t > ( goal_position_ ), & error ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { const auto result = packet_handler_ -> write4ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint32_t > ( goal_position_ ), & error ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } Result MotorBase :: updateJointPosition () { const auto address = address_table_ -> getAddress ( Operation :: PRESENT_POSITION ); if ( ! address . exists ()) { return Result ( \"PRESENT_POSITION operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_position_ = goal_position_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { uint8_t present_position = 0 ; const auto result = packet_handler_ -> read1ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { uint16_t present_position = 0 ; const auto result = packet_handler_ -> read2ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { uint32_t present_position = 0 ; const auto result = packet_handler_ -> read4ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } } // namespace dynamixel_hardware_interface Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/motor__base_8hpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp # base class of the dynamixel motor More... Namespaces # Name dynamixel_hardware_interface Classes # Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor. Detailed Description # base class of the dynamixel motor Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ #include <dynamixel_sdk/dynamixel_sdk.h> #include <dynamixel_hardware_interface/address_table_base.hpp> #include <dynamixel_hardware_interface/constants.hpp> #include <hardware_interface/base_interface.hpp> #include <hardware_interface/handle.hpp> #include <hardware_interface/hardware_info.hpp> #include <hardware_interface/system_interface.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_status_values.hpp> #include <limits> #include <memory> #include <rclcpp/rclcpp.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { struct Result { const std :: string description ; const bool success ; Result ( const std :: string & description , bool success ) : description ( description ), success ( success ) { } }; class MotorBase { public : const SupportedMotors motor_type ; const std :: string joint_name ; const bool enable_dummy ; const int baudrate ; const uint8_t id ; template < typename AddressTable > MotorBase ( const SupportedMotors & motor_type , const std :: string & joint_name , const bool enable_dummy , const AddressTable & table , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) : motor_type ( motor_type ), joint_name ( joint_name ), enable_dummy ( enable_dummy ), baudrate ( baudrate ), id ( id ), port_handler_ ( port_handler ), packet_handler_ ( packet_handler ), joint_position_ ( std :: numeric_limits < double >:: quiet_NaN ()), goal_position_ ( std :: numeric_limits < double >:: quiet_NaN ()) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"start constructing motor instance\" ); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"joint_name : \" << joint_name ); address_table_ = std :: make_shared < AddressTableBase > ( table ); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"end constructing motor instance\" ); } ~ MotorBase (); bool operationSupports ( const Operation & operation ); virtual std :: vector < Operation > getSupportedOperations (); virtual Result configure (); virtual Result torqueEnable ( bool enable ); virtual Result setGoalPosition ( double goal_position ); virtual Result setCurrentGoalPosition () { return setGoalPosition ( goal_position_ ); } virtual double getJointPosition () const { return joint_position_ ; } virtual double getGoalPosition () const { return goal_position_ ; } virtual Result updateJointPosition (); virtual void appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ); virtual void appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ); protected : MotorBase () = delete ; Result getResult ( int communication_result , uint8_t packet_error ); template < typename T > T radianToPosition ( double radian ) const { T value ; radianToPosition ( radian , value ); return value ; } uint16_t radianToPosition ( double radian ) const ; virtual double positionToRadian ( const uint8_t position ) const ; virtual double positionToRadian ( const uint16_t position ) const ; virtual double positionToRadian ( const uint32_t position ) const ; virtual void radianToPosition ( double radian , uint8_t & value ) const { value = static_cast < uint8_t > (( radian / M_PI ) * 256 ); } virtual void radianToPosition ( double radian , uint16_t & value ) const { value = static_cast < uint16_t > (( radian / M_PI ) * 65536 ); } virtual void radianToPosition ( double radian , uint32_t & value ) const { value = static_cast < uint32_t > (( radian / M_PI ) * 4294967296 ); } std :: shared_ptr < AddressTableBase > address_table_ ; std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; double joint_position_ ; double goal_position_ ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp"},{"location":"doxygen/markdown/Files/motor__base_8hpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacemotor_basehpp","text":"base class of the dynamixel motor More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp"},{"location":"doxygen/markdown/Files/motor__base_8hpp/#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/motor__base_8hpp/#classes","text":"Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor.","title":"Classes"},{"location":"doxygen/markdown/Files/motor__base_8hpp/#detailed-description","text":"base class of the dynamixel motor Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/motor__base_8hpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ #include <dynamixel_sdk/dynamixel_sdk.h> #include <dynamixel_hardware_interface/address_table_base.hpp> #include <dynamixel_hardware_interface/constants.hpp> #include <hardware_interface/base_interface.hpp> #include <hardware_interface/handle.hpp> #include <hardware_interface/hardware_info.hpp> #include <hardware_interface/system_interface.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_status_values.hpp> #include <limits> #include <memory> #include <rclcpp/rclcpp.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { struct Result { const std :: string description ; const bool success ; Result ( const std :: string & description , bool success ) : description ( description ), success ( success ) { } }; class MotorBase { public : const SupportedMotors motor_type ; const std :: string joint_name ; const bool enable_dummy ; const int baudrate ; const uint8_t id ; template < typename AddressTable > MotorBase ( const SupportedMotors & motor_type , const std :: string & joint_name , const bool enable_dummy , const AddressTable & table , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) : motor_type ( motor_type ), joint_name ( joint_name ), enable_dummy ( enable_dummy ), baudrate ( baudrate ), id ( id ), port_handler_ ( port_handler ), packet_handler_ ( packet_handler ), joint_position_ ( std :: numeric_limits < double >:: quiet_NaN ()), goal_position_ ( std :: numeric_limits < double >:: quiet_NaN ()) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"start constructing motor instance\" ); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"joint_name : \" << joint_name ); address_table_ = std :: make_shared < AddressTableBase > ( table ); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"end constructing motor instance\" ); } ~ MotorBase (); bool operationSupports ( const Operation & operation ); virtual std :: vector < Operation > getSupportedOperations (); virtual Result configure (); virtual Result torqueEnable ( bool enable ); virtual Result setGoalPosition ( double goal_position ); virtual Result setCurrentGoalPosition () { return setGoalPosition ( goal_position_ ); } virtual double getJointPosition () const { return joint_position_ ; } virtual double getGoalPosition () const { return goal_position_ ; } virtual Result updateJointPosition (); virtual void appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ); virtual void appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ); protected : MotorBase () = delete ; Result getResult ( int communication_result , uint8_t packet_error ); template < typename T > T radianToPosition ( double radian ) const { T value ; radianToPosition ( radian , value ); return value ; } uint16_t radianToPosition ( double radian ) const ; virtual double positionToRadian ( const uint8_t position ) const ; virtual double positionToRadian ( const uint16_t position ) const ; virtual double positionToRadian ( const uint32_t position ) const ; virtual void radianToPosition ( double radian , uint8_t & value ) const { value = static_cast < uint8_t > (( radian / M_PI ) * 256 ); } virtual void radianToPosition ( double radian , uint16_t & value ) const { value = static_cast < uint16_t > (( radian / M_PI ) * 65536 ); } virtual void radianToPosition ( double radian , uint32_t & value ) const { value = static_cast < uint32_t > (( radian / M_PI ) * 4294967296 ); } std :: shared_ptr < AddressTableBase > address_table_ ; std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; double joint_position_ ; double goal_position_ ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/motors_8hpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp # Header for including all motor types. More... Detailed Description # Header for including all motor types. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ #include <dynamixel_hardware_interface/motors/xw540_t260.hpp> #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp"},{"location":"doxygen/markdown/Files/motors_8hpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacemotorsmotorshpp","text":"Header for including all motor types. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp"},{"location":"doxygen/markdown/Files/motors_8hpp/#detailed-description","text":"Header for including all motor types. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/motors_8hpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ #include <dynamixel_hardware_interface/motors/xw540_t260.hpp> #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/util_8cpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp # implementation of the utility function. More... Namespaces # Name dynamixel_hardware_interface Detailed Description # implementation of the utility function. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/util.hpp> namespace dynamixel_hardware_interface { const std :: string toString ( const SupportedMotors motor ) { switch ( motor ) { case SupportedMotors :: XW540_T260 : return \"XW540-T260\" ; break ; case SupportedMotors :: INVALID : throw std :: runtime_error ( \"invalid moter type\" ); break ; } return \"\" ; } } // namespace dynamixel_hardware_interface Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp"},{"location":"doxygen/markdown/Files/util_8cpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfacesrcutilcpp","text":"implementation of the utility function. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp"},{"location":"doxygen/markdown/Files/util_8cpp/#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/util_8cpp/#detailed-description","text":"implementation of the utility function. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/util_8cpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/util.hpp> namespace dynamixel_hardware_interface { const std :: string toString ( const SupportedMotors motor ) { switch ( motor ) { case SupportedMotors :: XW540_T260 : return \"XW540-T260\" ; break ; case SupportedMotors :: INVALID : throw std :: runtime_error ( \"invalid moter type\" ); break ; } return \"\" ; } } // namespace dynamixel_hardware_interface Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/util_8hpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp # utility functions More... Namespaces # Name dynamixel_hardware_interface Detailed Description # utility functions Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ #include <dynamixel_hardware_interface/constants.hpp> namespace dynamixel_hardware_interface { const std :: string toString ( const SupportedMotors motor ); } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp"},{"location":"doxygen/markdown/Files/util_8hpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfaceutilhpp","text":"utility functions More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp"},{"location":"doxygen/markdown/Files/util_8hpp/#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/util_8hpp/#detailed-description","text":"utility functions Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/util_8hpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ #include <dynamixel_hardware_interface/constants.hpp> namespace dynamixel_hardware_interface { const std :: string toString ( const SupportedMotors motor ); } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/visiblity__control_8h/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h # Header file to control visibility. More... Defines # Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_LOCAL DYNAMIXEL_HARDWARE_INTERFACE_IMPORT DYNAMIXEL_HARDWARE_INTERFACE_EXPORT Detailed Description # Header file to control visibility. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Macro Documentation # define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE # #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC # #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL # #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT # #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT # #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\"))) Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ #define DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ // This logic was borrowed (then namespaced) from the examples on the gcc wiki: // https://gcc.gnu.org/wiki/Visibility #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((dllexport)) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __attribute__((dllimport)) #else #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __declspec(dllexport) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __declspec(dllimport) #endif #ifdef DYNAMIXEL_HARDWARE_INTERFACE_BUILDING_DLL #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_EXPORT #else #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_IMPORT #endif #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL #else #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\"))) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT #if __GNUC__ >= 4 #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC __attribute__((visibility(\"default\"))) #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL __attribute__((visibility(\"hidden\"))) #else #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL #endif #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE #endif #endif // DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacevisiblity_controlh","text":"Header file to control visibility. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#defines","text":"Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_LOCAL DYNAMIXEL_HARDWARE_INTERFACE_IMPORT DYNAMIXEL_HARDWARE_INTERFACE_EXPORT","title":"Defines"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#detailed-description","text":"Header file to control visibility. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#macro-documentation","text":"","title":"Macro Documentation"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_public_type","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE","title":"define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_public","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC","title":"define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_local","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL","title":"define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_import","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT","title":"define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_export","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\")))","title":"define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ #define DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ // This logic was borrowed (then namespaced) from the examples on the gcc wiki: // https://gcc.gnu.org/wiki/Visibility #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((dllexport)) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __attribute__((dllimport)) #else #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __declspec(dllexport) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __declspec(dllimport) #endif #ifdef DYNAMIXEL_HARDWARE_INTERFACE_BUILDING_DLL #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_EXPORT #else #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_IMPORT #endif #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL #else #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\"))) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT #if __GNUC__ >= 4 #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC __attribute__((visibility(\"default\"))) #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL __attribute__((visibility(\"hidden\"))) #else #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL #endif #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE #endif #endif // DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp # Class definition for the Dynamixel XW540-T260 motor. More... Namespaces # Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables dynamixel_hardware_interface Classes # Name class dynamixel_hardware_interface::motors::XW540_T260 class dynamixel_hardware_interface::address_tables::XW540_T260 Detailed Description # Class definition for the Dynamixel XW540-T260 motor. See : https://emanual.robotis.com/docs/en/dxl/x/xw540-t260/ Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ #include <cmath> #include <dynamixel_hardware_interface/address_table_base.hpp> #include <dynamixel_hardware_interface/motor_base.hpp> #include <limits> #include <memory> #include <string> namespace dynamixel_hardware_interface { namespace address_tables { class XW540_T260 : public AddressTableBase { public : XW540_T260 () : AddressTableBase ( Address ( 64 , PacketByteSize :: ONE_BYTE ), Address ( 116 , PacketByteSize :: FOUR_BYTE ), Address (), Address ( 132 , PacketByteSize :: FOUR_BYTE ), Address ( 128 , PacketByteSize :: FOUR_BYTE ), Address (), Address (), Address ( 146 , PacketByteSize :: ONE_BYTE )) { } }; } // namespace address_tables namespace motors { class XW540_T260 : public MotorBase { public : explicit XW540_T260 ( const std :: string joint_name , bool enable_dummy , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) : MotorBase ( SupportedMotors :: XW540_T260 , joint_name , enable_dummy , address_tables :: XW540_T260 (), baudrate , id , port_handler , packet_handler ) { } double positionToRadian ( const uint32_t position ) const override { return static_cast < double > ( position ) / static_cast < double > ( 4096 ) * M_PI * 2 ; return 0 ; } }; } // namespace motors } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacemotorsxw540_t260hpp","text":"Class definition for the Dynamixel XW540-T260 motor. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/#namespaces","text":"Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/#classes","text":"Name class dynamixel_hardware_interface::motors::XW540_T260 class dynamixel_hardware_interface::address_tables::XW540_T260","title":"Classes"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/#detailed-description","text":"Class definition for the Dynamixel XW540-T260 motor. See : https://emanual.robotis.com/docs/en/dxl/x/xw540-t260/ Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/#source-code","text":"// Copyright (c) 2019 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ #include <cmath> #include <dynamixel_hardware_interface/address_table_base.hpp> #include <dynamixel_hardware_interface/motor_base.hpp> #include <limits> #include <memory> #include <string> namespace dynamixel_hardware_interface { namespace address_tables { class XW540_T260 : public AddressTableBase { public : XW540_T260 () : AddressTableBase ( Address ( 64 , PacketByteSize :: ONE_BYTE ), Address ( 116 , PacketByteSize :: FOUR_BYTE ), Address (), Address ( 132 , PacketByteSize :: FOUR_BYTE ), Address ( 128 , PacketByteSize :: FOUR_BYTE ), Address (), Address (), Address ( 146 , PacketByteSize :: ONE_BYTE )) { } }; } // namespace address_tables namespace motors { class XW540_T260 : public MotorBase { public : explicit XW540_T260 ( const std :: string joint_name , bool enable_dummy , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) : MotorBase ( SupportedMotors :: XW540_T260 , joint_name , enable_dummy , address_tables :: XW540_T260 (), baudrate , id , port_handler , packet_handler ) { } double positionToRadian ( const uint32_t position ) const override { return static_cast < double > ( position ) / static_cast < double > ( 4096 ) * M_PI * 2 ; return 0 ; } }; } // namespace motors } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ Updated on 5 May 2021 at 09:17:41 UTC","title":"Source code"},{"location":"doxygen/markdown/Modules/","text":"Modules # Updated on 5 May 2021 at 09:17:41 UTC","title":"Modules"},{"location":"doxygen/markdown/Modules/#modules","text":"Updated on 5 May 2021 at 09:17:41 UTC","title":"Modules"},{"location":"doxygen/markdown/Namespaces/","text":"Namespaces # namespace dynamixel_hardware_interface namespace address_tables namespace motors Updated on 5 May 2021 at 09:17:41 UTC","title":"Namespaces"},{"location":"doxygen/markdown/Namespaces/#namespaces","text":"namespace dynamixel_hardware_interface namespace address_tables namespace motors Updated on 5 May 2021 at 09:17:41 UTC","title":"Namespaces"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/","text":"dynamixel_hardware_interface # Namespaces # Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables Classes # Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor. class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor. class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address Types # Name enum SupportedMotors { XW540_T260, INVALID } Enum class of the supported motor. enum PacketByteSize { TWO_BYTE, ONE_BYTE, INVALID, FOUR_BYTE } enum Operation { TORQUE_ENABLE, PRESENT_VOLTAGE, PRESENT_TEMPERATURE, PRESENT_SPEED, PRESENT_POSITION, PRESENT_LOAD, MOVING_SPEED, GOAL_POSITION } Enum class of the commands. Functions # Name const std::string toString (const SupportedMotors motor) Attributes # Name constexpr double TO_VOLTAGE constexpr double TO_SPEED_REV_PER_MIN constexpr double TO_SPEED_RAD_PER_SEC constexpr double TO_SPEED_RAD_PER_MIN constexpr double TO_RADIANS constexpr double TO_LOAD_PERCENT constexpr double TO_DXL_POS constexpr double PULSE_RESOLUTION constexpr double PROTOCOL_VERSION constexpr double DXL_MAX_POSITION_DEGREES constexpr double DXL_MAX_POSITION constexpr int DXL_HOME_POSITION Types Documentation # enum SupportedMotors # Enumerator Value Description XW540_T260 Robotis xw540-t260 motor. INVALID Invalid motor type. Enum class of the supported motor. enum PacketByteSize # Enumerator Value Description TWO_BYTE ONE_BYTE INVALID FOUR_BYTE enum Operation # Enumerator Value Description TORQUE_ENABLE PRESENT_VOLTAGE PRESENT_TEMPERATURE PRESENT_SPEED PRESENT_POSITION PRESENT_LOAD MOVING_SPEED GOAL_POSITION Enum class of the commands. Functions Documentation # function toString # const std :: string toString ( const SupportedMotors motor ) Attributes Documentation # variable TO_VOLTAGE # constexpr double TO_VOLTAGE = 0.1 ; variable TO_SPEED_REV_PER_MIN # constexpr double TO_SPEED_REV_PER_MIN = 0.111 ; variable TO_SPEED_RAD_PER_SEC # constexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0 ; variable TO_SPEED_RAD_PER_MIN # constexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI ; variable TO_RADIANS # constexpr double TO_RADIANS = ( DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION ) * M_PI / 180.0 ; variable TO_LOAD_PERCENT # constexpr double TO_LOAD_PERCENT = 0.1 ; variable TO_DXL_POS # constexpr double TO_DXL_POS = 1.0 / TO_RADIANS ; variable PULSE_RESOLUTION # constexpr double PULSE_RESOLUTION = 4096 ; variable PROTOCOL_VERSION # constexpr double PROTOCOL_VERSION = 2.0 ; variable DXL_MAX_POSITION_DEGREES # constexpr double DXL_MAX_POSITION_DEGREES = 300.0 ; variable DXL_MAX_POSITION # constexpr double DXL_MAX_POSITION = 1023.0 ; variable DXL_HOME_POSITION # constexpr int DXL_HOME_POSITION = 0 ; Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#dynamixel_hardware_interface","text":"","title":"dynamixel_hardware_interface"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#namespaces","text":"Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables","title":"Namespaces"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#classes","text":"Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor. class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor. class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address","title":"Classes"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#types","text":"Name enum SupportedMotors { XW540_T260, INVALID } Enum class of the supported motor. enum PacketByteSize { TWO_BYTE, ONE_BYTE, INVALID, FOUR_BYTE } enum Operation { TORQUE_ENABLE, PRESENT_VOLTAGE, PRESENT_TEMPERATURE, PRESENT_SPEED, PRESENT_POSITION, PRESENT_LOAD, MOVING_SPEED, GOAL_POSITION } Enum class of the commands.","title":"Types"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#functions","text":"Name const std::string toString (const SupportedMotors motor)","title":"Functions"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#attributes","text":"Name constexpr double TO_VOLTAGE constexpr double TO_SPEED_REV_PER_MIN constexpr double TO_SPEED_RAD_PER_SEC constexpr double TO_SPEED_RAD_PER_MIN constexpr double TO_RADIANS constexpr double TO_LOAD_PERCENT constexpr double TO_DXL_POS constexpr double PULSE_RESOLUTION constexpr double PROTOCOL_VERSION constexpr double DXL_MAX_POSITION_DEGREES constexpr double DXL_MAX_POSITION constexpr int DXL_HOME_POSITION","title":"Attributes"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#types-documentation","text":"","title":"Types Documentation"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#enum-supportedmotors","text":"Enumerator Value Description XW540_T260 Robotis xw540-t260 motor. INVALID Invalid motor type. Enum class of the supported motor.","title":"enum SupportedMotors"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#enum-packetbytesize","text":"Enumerator Value Description TWO_BYTE ONE_BYTE INVALID FOUR_BYTE","title":"enum PacketByteSize"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#enum-operation","text":"Enumerator Value Description TORQUE_ENABLE PRESENT_VOLTAGE PRESENT_TEMPERATURE PRESENT_SPEED PRESENT_POSITION PRESENT_LOAD MOVING_SPEED GOAL_POSITION Enum class of the commands.","title":"enum Operation"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#function-tostring","text":"const std :: string toString ( const SupportedMotors motor )","title":"function toString"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_voltage","text":"constexpr double TO_VOLTAGE = 0.1 ;","title":"variable TO_VOLTAGE"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_speed_rev_per_min","text":"constexpr double TO_SPEED_REV_PER_MIN = 0.111 ;","title":"variable TO_SPEED_REV_PER_MIN"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_speed_rad_per_sec","text":"constexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0 ;","title":"variable TO_SPEED_RAD_PER_SEC"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_speed_rad_per_min","text":"constexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI ;","title":"variable TO_SPEED_RAD_PER_MIN"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_radians","text":"constexpr double TO_RADIANS = ( DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION ) * M_PI / 180.0 ;","title":"variable TO_RADIANS"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_load_percent","text":"constexpr double TO_LOAD_PERCENT = 0.1 ;","title":"variable TO_LOAD_PERCENT"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_dxl_pos","text":"constexpr double TO_DXL_POS = 1.0 / TO_RADIANS ;","title":"variable TO_DXL_POS"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-pulse_resolution","text":"constexpr double PULSE_RESOLUTION = 4096 ;","title":"variable PULSE_RESOLUTION"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-protocol_version","text":"constexpr double PROTOCOL_VERSION = 2.0 ;","title":"variable PROTOCOL_VERSION"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-dxl_max_position_degrees","text":"constexpr double DXL_MAX_POSITION_DEGREES = 300.0 ;","title":"variable DXL_MAX_POSITION_DEGREES"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-dxl_max_position","text":"constexpr double DXL_MAX_POSITION = 1023.0 ;","title":"variable DXL_MAX_POSITION"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-dxl_home_position","text":"constexpr int DXL_HOME_POSITION = 0 ; Updated on 5 May 2021 at 09:17:41 UTC","title":"variable DXL_HOME_POSITION"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1address__tables/","text":"dynamixel_hardware_interface::address_tables # Classes # Name class dynamixel_hardware_interface::address_tables::XW540_T260 Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface::address_tables"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1address__tables/#dynamixel_hardware_interfaceaddress_tables","text":"","title":"dynamixel_hardware_interface::address_tables"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1address__tables/#classes","text":"Name class dynamixel_hardware_interface::address_tables::XW540_T260 Updated on 5 May 2021 at 09:17:41 UTC","title":"Classes"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1motors/","text":"dynamixel_hardware_interface::motors # Classes # Name class dynamixel_hardware_interface::motors::XW540_T260 Updated on 5 May 2021 at 09:17:41 UTC","title":"dynamixel_hardware_interface::motors"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1motors/#dynamixel_hardware_interfacemotors","text":"","title":"dynamixel_hardware_interface::motors"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1motors/#classes","text":"Name class dynamixel_hardware_interface::motors::XW540_T260 Updated on 5 May 2021 at 09:17:41 UTC","title":"Classes"},{"location":"doxygen/markdown/Pages/","text":"Pages # Updated on 5 May 2021 at 09:17:41 UTC","title":"Pages"},{"location":"doxygen/markdown/Pages/#pages","text":"Updated on 5 May 2021 at 09:17:41 UTC","title":"Pages"}]}