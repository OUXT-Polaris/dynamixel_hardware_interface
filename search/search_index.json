{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dynamixel Hardware Interface","text":"<p>ROS2 hardware interface for Dynamixel Motors. You can control Dynamixel motors like below.</p> <p>\u3044\u3048\u30fc\u3044 pic.twitter.com/PPQaBwk8uZ</p>\u2014 \u7247\u5ca1\u5927\u54c9 (@hakuturu583) May 5, 2021"},{"location":"#how-to-use","title":"How to use","text":""},{"location":"#write-urdfxacro-file-for-your-robot","title":"Write URDF/XACRO file for your robot","text":"<p>Example is here. You can use dynamixel hardware interface by writing URDF like below.</p> <pre><code>&lt;xacro:macro name=\"azimuth_thruster_control\" params=\"left_joint right_joint enable_dummy\"&gt;\n&lt;ros2_control name=\"azimuth_thruster_control\" type=\"system\"&gt;\n&lt;hardware&gt;\n&lt;plugin&gt;dynamixel_hardware_interface/DynamixelHardwareInterface&lt;/plugin&gt;\n&lt;param name=\"port_name\"&gt;/dev/ttyUSB0&lt;/param&gt;\n&lt;param name=\"baudrate\"&gt;9600&lt;/param&gt;\n&lt;param name=\"enable_dummy\"&gt;${enable_dummy}&lt;/param&gt;\n&lt;/hardware&gt;\n&lt;joint name=\"${left_joint}\"&gt;\n&lt;param name=\"id\"&gt;1&lt;/param&gt;\n&lt;param name=\"motor_type\"&gt;XW540-T260&lt;/param&gt;\n&lt;command_interface name=\"position\"/&gt;\n&lt;state_interface name=\"position\"/&gt;\n&lt;/joint&gt;\n&lt;joint name=\"${right_joint}\"&gt;\n&lt;param name=\"id\"&gt;2&lt;/param&gt;\n&lt;param name=\"motor_type\"&gt;XW540-T260&lt;/param&gt;\n&lt;command_interface name=\"position\"/&gt;\n&lt;state_interface name=\"position\"/&gt;\n&lt;/joint&gt;\n&lt;/ros2_control&gt;\n&lt;/xacro:macro&gt;\n</code></pre>"},{"location":"#hardware-parameters-in-urdfxacro","title":"Hardware parameters in URDF/XACRO","text":"Name Type Description port_name string USB port name of the U2D2 baudrate int baudrate of the RS485 communication enable_dummy bool If true, this hardware interface runs without real dynamixel hardwre."},{"location":"#joint-parameters-in-urdfxacro","title":"Joint parameters in URDF/XACRO","text":"Name Type Description id int id of the dynamixel motor attached to the joint motor_type string type of the dynamixel motor"},{"location":"#connect-motors-to-the-u2d2","title":"Connect motors to the U2D2","text":"<p>Connect motors to the U2D2. Power cable is also required.</p>"},{"location":"#setup-motors","title":"Setup motors","text":"<p>Use dynamixel wizard and configure motor ID and baudrate</p>"},{"location":"#support-status","title":"Support Status","text":""},{"location":"#state-interface","title":"State Interface","text":"Motor Position Interface Velocity Interface Effort Interface Temperature Interface XW540-T260 \u2714 \u2714 \u2714"},{"location":"#command-interface","title":"Command Interface","text":"Motor Position Interface Velocity Interface Effort Interface XW540-T260 \u2714"},{"location":"doxygen/markdown/Classes/","title":"Classes","text":"<ul> <li>namespace dynamixel_hardware_interface <ul> <li>class Address </li> <li>class AddressTableBase base class for address table class </li> <li>class DynamixelDiagnosticController </li> <li>class DynamixelHardwareInterface Hardware interface for the dynamixel motor. </li> <li>class MotorBase Base class for controlling dynamixel motor. </li> <li>struct Result Struct describes the command result. </li> <li>namespace address_tables <ul> <li>class XW540_T260 </li> </ul> </li> <li>namespace motors <ul> <li>class XW540_T260 </li> </ul> </li> </ul> </li> </ul> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/","title":"dynamixel_hardware_interface::Address","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#public-functions","title":"Public Functions","text":"Name bool exists() const Address(uint16_t address, PacketByteSize byte_size) Address()"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#public-attributes","title":"Public Attributes","text":"Name const PacketByteSize byte_size const uint16_t address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#function-exists","title":"function exists","text":"<pre><code>inline bool exists() const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#function-address","title":"function Address","text":"<pre><code>inline Address(\nuint16_t address,\nPacketByteSize byte_size\n)\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#function-address_1","title":"function Address","text":"<pre><code>inline Address()\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#variable-byte_size","title":"variable byte_size","text":"<pre><code>const PacketByteSize byte_size;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address/#variable-address","title":"variable address","text":"<pre><code>const uint16_t address;\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/","title":"dynamixel_hardware_interface::AddressTableBase","text":"<p>base class for address table class </p> <p><code>#include &lt;address_table_base.hpp&gt;</code></p> <p>Inherited by dynamixel_hardware_interface::address_tables::XW540_T260</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#public-functions","title":"Public Functions","text":"Name Address getAddress(const Operation &amp; operaiton) const Get address of which operation you want to execute. bool addressExists(const Operation &amp; operation) const Check the address exists or not. AddressTableBase(Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE, Address ADDR_MAX_POSITION_LIMIT, Address ADDR_MIN_POSITION_LIMIT) Construct a new Address Table Base object, each parameter describes the address of the operation."},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#function-getaddress","title":"function getAddress","text":"<pre><code>inline Address getAddress(\nconst Operation &amp; operaiton\n) const\n</code></pre> <p>Get address of which operation you want to execute. </p> <p>Parameters: </p> <ul> <li>operaiton operation you want to execute </li> </ul> <p>Returns: </p> <ul> <li>boost::none operation is not supported </li> <li>uint16_t address of the operation you want to execute </li> </ul>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#function-addressexists","title":"function addressExists","text":"<pre><code>inline bool addressExists(\nconst Operation &amp; operation\n) const\n</code></pre> <p>Check the address exists or not. </p> <p>Parameters: </p> <ul> <li>operation operation you want to execute </li> </ul> <p>Return: </p> <ul> <li>true address exist </li> <li>false address does not exist </li> </ul>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase/#function-addresstablebase","title":"function AddressTableBase","text":"<pre><code>inline explicit AddressTableBase(\nAddress ADDR_TORQUE_ENABLE,\nAddress ADDR_GOAL_POSITION,\nAddress ADDR_MOVING_SPEED,\nAddress ADDR_PRESENT_POSITION,\nAddress ADDR_PRESENT_SPEED,\nAddress ADDR_PRESENT_LOAD,\nAddress ADDR_PRESENT_VOLTAGE,\nAddress ADDR_PRESENT_TEMPERATURE,\nAddress ADDR_MAX_POSITION_LIMIT,\nAddress ADDR_MIN_POSITION_LIMIT\n)\n</code></pre> <p>Construct a new Address Table Base object, each parameter describes the address of the operation. </p> <p>Parameters: </p> <ul> <li>ADDR_TORQUE_ENABLE If this value is boost::none, writing torque_enable command address exists. </li> <li>ADDR_GOAL_POSITION If this value is boost::none, writing goal_position command address exists. </li> <li>ADDR_MOVING_SPEED If this value is boost::none, writing moving_speed command address exists. </li> <li>ADDR_PRESENT_POSITION If this value is boost::none, reading present_position command address exists. </li> <li>ADDR_PRESENT_SPEED If this value is boost::none, reading present_speed command address exists. </li> <li>ADDR_PRESENT_LOAD If this value is boost::none, reading present_load command address exists. </li> <li>ADDR_PRESENT_VOLTAGE If this value is boost::none, reading present_voltage command address exists. </li> <li>ADDR_PRESENT_TEMPERATURE If this value is boost::none, reading present_temperature command address exists. </li> <li>ADDR_MAX_POSITION_LIMIT </li> <li>ADDR_MIN_POSITION_LIMIT </li> </ul> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/","title":"dynamixel_hardware_interface::DynamixelDiagnosticController","text":"<p>Inherits from ControllerInterface</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/#public-functions","title":"Public Functions","text":"Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::return_type update() override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::InterfaceConfiguration state_interface_configuration() const override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_deactivate(const rclcpp_lifecycle::State &amp; ) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_configure(const rclcpp_lifecycle::State &amp; ) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_activate(const rclcpp_lifecycle::State &amp; ) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::return_type init(const std::string &amp; controller_name, const std::string &amp; namespace_ =\"\", const rclcpp::NodeOptions &amp; node_options =rclcpp::NodeOptions() .allow_undeclared_parameters(true) .automatically_declare_parameters_from_overrides(true)) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::InterfaceConfiguration command_interface_configuration() const override"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/#function-update","title":"function update","text":"<pre><code>DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::return_type update() override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/#function-state_interface_configuration","title":"function state_interface_configuration","text":"<pre><code>inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::InterfaceConfiguration state_interface_configuration() const override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/#function-on_deactivate","title":"function on_deactivate","text":"<pre><code>inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_deactivate(\nconst rclcpp_lifecycle::State &amp; ) override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/#function-on_configure","title":"function on_configure","text":"<pre><code>DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_configure(\nconst rclcpp_lifecycle::State &amp; ) override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/#function-on_activate","title":"function on_activate","text":"<pre><code>inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_activate(\nconst rclcpp_lifecycle::State &amp; ) override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/#function-init","title":"function init","text":"<pre><code>DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::return_type init(\nconst std::string &amp; controller_name,\nconst std::string &amp; namespace_ =\"\",\nconst rclcpp::NodeOptions &amp; node_options =rclcpp::NodeOptions() .allow_undeclared_parameters(true) .automatically_declare_parameters_from_overrides(true)\n) override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController/#function-command_interface_configuration","title":"function command_interface_configuration","text":"<pre><code>inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::InterfaceConfiguration command_interface_configuration() const override\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/","title":"dynamixel_hardware_interface::DynamixelHardwareInterface","text":"<p>Hardware interface for the dynamixel motor. </p> <p><code>#include &lt;dynamixel_hardware_interface.hpp&gt;</code></p> <p>Inherits from hardware_interface::BaseInterface&lt; hardware_interface::SystemInterface &gt;</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#public-functions","title":"Public Functions","text":"Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type write(const rclcpp::Time &amp; time, const rclcpp::Duration &amp; period) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type read(const rclcpp::Time &amp; time, const rclcpp::Duration &amp; period) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector&lt; hardware_interface::StateInterface &gt; export_state_interfaces() override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector&lt; hardware_interface::CommandInterface &gt; export_command_interfaces() override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type configure(const hardware_interface::HardwareInfo &amp; info) override"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-write","title":"function write","text":"<pre><code>DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type write(\nconst rclcpp::Time &amp; time,\nconst rclcpp::Duration &amp; period\n) override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-read","title":"function read","text":"<pre><code>DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type read(\nconst rclcpp::Time &amp; time,\nconst rclcpp::Duration &amp; period\n) override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-export_state_interfaces","title":"function export_state_interfaces","text":"<pre><code>DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector&lt; hardware_interface::StateInterface &gt; export_state_interfaces() override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-export_command_interfaces","title":"function export_command_interfaces","text":"<pre><code>DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector&lt; hardware_interface::CommandInterface &gt; export_command_interfaces() override\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface/#function-configure","title":"function configure","text":"<pre><code>DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type configure(\nconst hardware_interface::HardwareInfo &amp; info\n) override\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/","title":"dynamixel_hardware_interface::MotorBase","text":"<p>Base class for controlling dynamixel motor. </p> <p><code>#include &lt;motor_base.hpp&gt;</code></p> <p>Inherited by dynamixel_hardware_interface::motors::XW540_T260</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#public-functions","title":"Public Functions","text":"Name ~MotorBase() Destroy the Motor Base object. virtual Result updatePresentTemperature() Execute update present temperature command to the motor. virtual Result updateJointVelocity() Execute update joint velocity command to the motor. virtual Result updateJointPosition() Execute update joint position command to the motor. virtual Result torqueEnable(bool enable) Execute torqu_enabled command to the motor. virtual Result setJointPositionLimit(double max_joint_limit, double min_joint_limit) virtual Result setGoalPosition(double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition() Execute goal_position command to the motor without update current goal position. bool operationSupports(const Operation &amp; operation) Check the operation is support in your motor. virtual std::vector&lt; Operation &gt; getSupportedOperations() Get list of supported Operations in your motor. virtual double getJointPosition() const Get current joint position of the motor. virtual double getGoalPosition() const Get current goal position of the motor. virtual Result configure() Configure dynamixel motor. virtual void appendStateInterfaces(std::vector&lt; hardware_interface::StateInterface &gt; &amp; interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces(std::vector&lt; hardware_interface::CommandInterface &gt; &amp; interfaces) Append command interface described in the URDF file. template \\&lt;typename AddressTable &gt; MotorBase(const SupportedMotors &amp; motor_type, const std::string &amp; joint_name, const bool enable_dummy, const AddressTable &amp; table, int baudrate, uint8_t id, double max_joint_limit, double min_joint_limit, std::shared_ptr&lt; dynamixel::PortHandler &gt; port_handler, std::shared_ptr&lt; dynamixel::PacketHandler &gt; packet_handler) Construct a new Motor Base object."},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#protected-functions","title":"Protected Functions","text":"Name virtual double valueToTemperature(uint8_t value) const virtual double valueToTemperature(uint16_t value) const virtual double valueToTemperature(uint32_t value) const virtual double valueToRpm(uint8_t value) const virtual double valueToRpm(uint16_t value) const virtual double valueToRpm(uint32_t value) const void rpmToVelocity(double rpm, double &amp; radian) const template \\&lt;typename T &gt;T radianToPosition(double radian) const uint16_t radianToPosition(double radian) const virtual void radianToPosition(double radian, uint8_t &amp; value) const virtual void radianToPosition(double radian, uint16_t &amp; value) const virtual void radianToPosition(double radian, uint32_t &amp; value) const virtual double positionToRadian(const uint8_t position) const virtual double positionToRadian(const uint16_t position) const virtual double positionToRadian(const uint32_t position) const Result getResult(int communication_result, uint8_t packet_error) MotorBase() Construct a new Motor Base object."},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#public-attributes","title":"Public Attributes","text":"Name const SupportedMotors motor_type Describe the type of the motor. const double min_joint_limit const double max_joint_limit const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication."},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#protected-attributes","title":"Protected Attributes","text":"Name double present_temperature_ std::shared_ptr&lt; dynamixel::PortHandler &gt; port_handler_ std::shared_ptr&lt; dynamixel::PacketHandler &gt; packet_handler_ double joint_velocity_ double joint_position_ double goal_velocity_ double goal_position_ std::shared_ptr&lt; AddressTableBase &gt; address_table_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-motorbase","title":"function ~MotorBase","text":"<pre><code>~MotorBase()\n</code></pre> <p>Destroy the Motor Base object. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-updatepresenttemperature","title":"function updatePresentTemperature","text":"<pre><code>virtual Result updatePresentTemperature()\n</code></pre> <p>Execute update present temperature command to the motor. </p> <p>Return: Result</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-updatejointvelocity","title":"function updateJointVelocity","text":"<pre><code>virtual Result updateJointVelocity()\n</code></pre> <p>Execute update joint velocity command to the motor. </p> <p>Return: Result</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-updatejointposition","title":"function updateJointPosition","text":"<pre><code>virtual Result updateJointPosition()\n</code></pre> <p>Execute update joint position command to the motor. </p> <p>Return: Result result of the command. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-torqueenable","title":"function torqueEnable","text":"<pre><code>virtual Result torqueEnable(\nbool enable\n)\n</code></pre> <p>Execute torqu_enabled command to the motor. </p> <p>Parameters: </p> <ul> <li>enable if true, enable torque. </li> </ul> <p>Return: Result result of the command. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-setjointpositionlimit","title":"function setJointPositionLimit","text":"<pre><code>virtual Result setJointPositionLimit(\ndouble max_joint_limit,\ndouble min_joint_limit\n)\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-setgoalposition","title":"function setGoalPosition","text":"<pre><code>virtual Result setGoalPosition(\ndouble goal_position\n)\n</code></pre> <p>Execute goal_position command to the motor. </p> <p>Parameters: </p> <ul> <li>goal_position goal position angle in radian. </li> </ul> <p>Return: Result result of the command. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-setcurrentgoalposition","title":"function setCurrentGoalPosition","text":"<pre><code>inline virtual Result setCurrentGoalPosition()\n</code></pre> <p>Execute goal_position command to the motor without update current goal position. </p> <p>Return: Result result of the command. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-operationsupports","title":"function operationSupports","text":"<pre><code>bool operationSupports(\nconst Operation &amp; operation\n)\n</code></pre> <p>Check the operation is support in your motor. </p> <p>Parameters: </p> <ul> <li>operation Operation which you want to execute. </li> </ul> <p>Return: </p> <ul> <li>true Operation supports. </li> <li>false Operation does not support. </li> </ul>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-getsupportedoperations","title":"function getSupportedOperations","text":"<pre><code>virtual std::vector&lt; Operation &gt; getSupportedOperations()\n</code></pre> <p>Get list of supported Operations in your motor. </p> <p>Return: std::vector List of supported operations."},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-getjointposition","title":"function getJointPosition","text":"<pre><code>inline virtual double getJointPosition() const\n</code></pre> <p>Get current joint position of the motor. </p> <p>Return: double Current joint position of the motor in radian. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-getgoalposition","title":"function getGoalPosition","text":"<pre><code>inline virtual double getGoalPosition() const\n</code></pre> <p>Get current goal position of the motor. </p> <p>Return: double Current goal position of the motor in radian. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-configure","title":"function configure","text":"<pre><code>virtual Result configure()\n</code></pre> <p>Configure dynamixel motor. </p> <p>Return: Result result of the configuration. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-appendstateinterfaces","title":"function appendStateInterfaces","text":"<pre><code>virtual void appendStateInterfaces(\nstd::vector&lt; hardware_interface::StateInterface &gt; &amp; interfaces\n)\n</code></pre> <p>Append state interface described in the URDF file. </p> <p>Parameters: </p> <ul> <li>interfaces List of state interface. </li> </ul>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-appendcommandinterfaces","title":"function appendCommandInterfaces","text":"<pre><code>virtual void appendCommandInterfaces(\nstd::vector&lt; hardware_interface::CommandInterface &gt; &amp; interfaces\n)\n</code></pre> <p>Append command interface described in the URDF file. </p> <p>Parameters: </p> <ul> <li>interfaces List of command interface. </li> </ul>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-motorbase_1","title":"function MotorBase","text":"<pre><code>template &lt;typename AddressTable &gt;\ninline MotorBase(\nconst SupportedMotors &amp; motor_type,\nconst std::string &amp; joint_name,\nconst bool enable_dummy,\nconst AddressTable &amp; table,\nint baudrate,\nuint8_t id,\ndouble max_joint_limit,\ndouble min_joint_limit,\nstd::shared_ptr&lt; dynamixel::PortHandler &gt; port_handler,\nstd::shared_ptr&lt; dynamixel::PacketHandler &gt; packet_handler\n)\n</code></pre> <p>Construct a new Motor Base object. </p> <p>Parameters: </p> <ul> <li>motor_type Type of the motor. </li> <li>joint_name Name of the joint which the motor is attaching to. </li> <li>enable_dummy If true, you can communicate with virtual dinamixel motor. </li> <li>table address table of the motor. </li> <li>baudrate Baudrate of the serial communication. </li> <li>id Id of the dynamixel motor. </li> <li>max_joint_limit </li> <li>min_joint_limit </li> <li>port_handler Port handler class of the dynamixel sdk. </li> <li>packet_handler Packet handler class of the dynamixel sdk </li> </ul> <p>Template Parameters: </p> <ul> <li>AddressTable address table type of the motor. </li> </ul>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-valuetotemperature","title":"function valueToTemperature","text":"<pre><code>virtual double valueToTemperature(\nuint8_t value\n) const\n</code></pre> <p>Reimplemented by: dynamixel_hardware_interface::motors::XW540_T260::valueToTemperature</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-valuetotemperature_1","title":"function valueToTemperature","text":"<pre><code>virtual double valueToTemperature(\nuint16_t value\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-valuetotemperature_2","title":"function valueToTemperature","text":"<pre><code>virtual double valueToTemperature(\nuint32_t value\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-valuetorpm","title":"function valueToRpm","text":"<pre><code>virtual double valueToRpm(\nuint8_t value\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-valuetorpm_1","title":"function valueToRpm","text":"<pre><code>virtual double valueToRpm(\nuint16_t value\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-valuetorpm_2","title":"function valueToRpm","text":"<pre><code>virtual double valueToRpm(\nuint32_t value\n) const\n</code></pre> <p>Reimplemented by: dynamixel_hardware_interface::motors::XW540_T260::valueToRpm</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-rpmtovelocity","title":"function rpmToVelocity","text":"<pre><code>inline void rpmToVelocity(\ndouble rpm,\ndouble &amp; radian\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition","title":"function radianToPosition","text":"<pre><code>template &lt;typename T &gt;\ninline T radianToPosition(\ndouble radian\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition_1","title":"function radianToPosition","text":"<pre><code>uint16_t radianToPosition(\ndouble radian\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition_2","title":"function radianToPosition","text":"<pre><code>virtual void radianToPosition(\ndouble radian,\nuint8_t &amp; value\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition_3","title":"function radianToPosition","text":"<pre><code>virtual void radianToPosition(\ndouble radian,\nuint16_t &amp; value\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-radiantoposition_4","title":"function radianToPosition","text":"<pre><code>virtual void radianToPosition(\ndouble radian,\nuint32_t &amp; value\n) const\n</code></pre> <p>Reimplemented by: dynamixel_hardware_interface::motors::XW540_T260::radianToPosition</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-positiontoradian","title":"function positionToRadian","text":"<pre><code>virtual double positionToRadian(\nconst uint8_t position\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-positiontoradian_1","title":"function positionToRadian","text":"<pre><code>virtual double positionToRadian(\nconst uint16_t position\n) const\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-positiontoradian_2","title":"function positionToRadian","text":"<pre><code>virtual double positionToRadian(\nconst uint32_t position\n) const\n</code></pre> <p>Reimplemented by: dynamixel_hardware_interface::motors::XW540_T260::positionToRadian</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-getresult","title":"function getResult","text":"<pre><code>Result getResult(\nint communication_result,\nuint8_t packet_error\n)\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#function-motorbase_2","title":"function MotorBase","text":"<pre><code>MotorBase()\n</code></pre> <p>Construct a new Motor Base object. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-motor_type","title":"variable motor_type","text":"<pre><code>const SupportedMotors motor_type;\n</code></pre> <p>Describe the type of the motor. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-min_joint_limit","title":"variable min_joint_limit","text":"<pre><code>const double min_joint_limit;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-max_joint_limit","title":"variable max_joint_limit","text":"<pre><code>const double max_joint_limit;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-joint_name","title":"variable joint_name","text":"<pre><code>const std::string joint_name;\n</code></pre> <p>Name of the joint which the motor is attaching to. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-id","title":"variable id","text":"<pre><code>const uint8_t id;\n</code></pre> <p>Id of the dynamixel motor. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-enable_dummy","title":"variable enable_dummy","text":"<pre><code>const bool enable_dummy;\n</code></pre> <p>If true, you can communicate with virtual dinamixel motor. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-baudrate","title":"variable baudrate","text":"<pre><code>const int baudrate;\n</code></pre> <p>Baudrate of the serial communication. </p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-present_temperature_","title":"variable present_temperature_","text":"<pre><code>double present_temperature_;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-port_handler_","title":"variable port_handler_","text":"<pre><code>std::shared_ptr&lt; dynamixel::PortHandler &gt; port_handler_;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-packet_handler_","title":"variable packet_handler_","text":"<pre><code>std::shared_ptr&lt; dynamixel::PacketHandler &gt; packet_handler_;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-joint_velocity_","title":"variable joint_velocity_","text":"<pre><code>double joint_velocity_;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-joint_position_","title":"variable joint_position_","text":"<pre><code>double joint_position_;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-goal_velocity_","title":"variable goal_velocity_","text":"<pre><code>double goal_velocity_;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-goal_position_","title":"variable goal_position_","text":"<pre><code>double goal_position_;\n</code></pre>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase/#variable-address_table_","title":"variable address_table_","text":"<pre><code>std::shared_ptr&lt; AddressTableBase &gt; address_table_;\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/","title":"dynamixel_hardware_interface::address_tables::XW540_T260","text":"<p>Inherits from dynamixel_hardware_interface::AddressTableBase</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/#public-functions","title":"Public Functions","text":"Name XW540_T260()"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from dynamixel_hardware_interface::AddressTableBase</p> Name Address getAddress(const Operation &amp; operaiton) const Get address of which operation you want to execute. bool addressExists(const Operation &amp; operation) const Check the address exists or not. AddressTableBase(Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE, Address ADDR_MAX_POSITION_LIMIT, Address ADDR_MIN_POSITION_LIMIT) Construct a new Address Table Base object, each parameter describes the address of the operation."},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260/#function-xw540_t260","title":"function XW540_T260","text":"<pre><code>inline XW540_T260()\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/","title":"dynamixel_hardware_interface::motors::XW540_T260","text":"<p>Inherits from dynamixel_hardware_interface::MotorBase</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#public-functions","title":"Public Functions","text":"Name virtual double valueToTemperature(uint8_t value) const override virtual double valueToRpm(uint32_t value) const override virtual void radianToPosition(double radian, uint32_t &amp; value) const override virtual double positionToRadian(const uint32_t position) const override XW540_T260(const std::string joint_name, bool enable_dummy, int baudrate, uint8_t id, double max_joint_limit, double min_joint_limit, std::shared_ptr&lt; dynamixel::PortHandler &gt; port_handler, std::shared_ptr&lt; dynamixel::PacketHandler &gt; packet_handler)"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#additional-inherited-members","title":"Additional inherited members","text":"<p>Public Functions inherited from dynamixel_hardware_interface::MotorBase</p> Name ~MotorBase() Destroy the Motor Base object. virtual Result updatePresentTemperature() Execute update present temperature command to the motor. virtual Result updateJointVelocity() Execute update joint velocity command to the motor. virtual Result updateJointPosition() Execute update joint position command to the motor. virtual Result torqueEnable(bool enable) Execute torqu_enabled command to the motor. virtual Result setJointPositionLimit(double max_joint_limit, double min_joint_limit) virtual Result setGoalPosition(double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition() Execute goal_position command to the motor without update current goal position. bool operationSupports(const Operation &amp; operation) Check the operation is support in your motor. virtual std::vector&lt; Operation &gt; getSupportedOperations() Get list of supported Operations in your motor. virtual double getJointPosition() const Get current joint position of the motor. virtual double getGoalPosition() const Get current goal position of the motor. virtual Result configure() Configure dynamixel motor. virtual void appendStateInterfaces(std::vector&lt; hardware_interface::StateInterface &gt; &amp; interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces(std::vector&lt; hardware_interface::CommandInterface &gt; &amp; interfaces) Append command interface described in the URDF file. MotorBase(const SupportedMotors &amp; motor_type, const std::string &amp; joint_name, const bool enable_dummy, const AddressTable &amp; table, int baudrate, uint8_t id, double max_joint_limit, double min_joint_limit, std::shared_ptr&lt; dynamixel::PortHandler &gt; port_handler, std::shared_ptr&lt; dynamixel::PacketHandler &gt; packet_handler) Construct a new Motor Base object. <p>Protected Functions inherited from dynamixel_hardware_interface::MotorBase</p> Name void rpmToVelocity(double rpm, double &amp; radian) const Result getResult(int communication_result, uint8_t packet_error) MotorBase() Construct a new Motor Base object. <p>Public Attributes inherited from dynamixel_hardware_interface::MotorBase</p> Name const SupportedMotors motor_type Describe the type of the motor. const double min_joint_limit const double max_joint_limit const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication. <p>Protected Attributes inherited from dynamixel_hardware_interface::MotorBase</p> Name double present_temperature_ std::shared_ptr&lt; dynamixel::PortHandler &gt; port_handler_ std::shared_ptr&lt; dynamixel::PacketHandler &gt; packet_handler_ double joint_velocity_ double joint_position_ double goal_velocity_ double goal_position_ std::shared_ptr&lt; AddressTableBase &gt; address_table_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#function-valuetotemperature","title":"function valueToTemperature","text":"<pre><code>inline virtual double valueToTemperature(\nuint8_t value\n) const override\n</code></pre> <p>Reimplements: dynamixel_hardware_interface::MotorBase::valueToTemperature</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#function-valuetorpm","title":"function valueToRpm","text":"<pre><code>inline virtual double valueToRpm(\nuint32_t value\n) const override\n</code></pre> <p>Reimplements: dynamixel_hardware_interface::MotorBase::valueToRpm</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#function-radiantoposition","title":"function radianToPosition","text":"<pre><code>inline virtual void radianToPosition(\ndouble radian,\nuint32_t &amp; value\n) const override\n</code></pre> <p>Reimplements: dynamixel_hardware_interface::MotorBase::radianToPosition</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#function-positiontoradian","title":"function positionToRadian","text":"<pre><code>inline virtual double positionToRadian(\nconst uint32_t position\n) const override\n</code></pre> <p>Reimplements: dynamixel_hardware_interface::MotorBase::positionToRadian</p>"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260/#function-xw540_t260","title":"function XW540_T260","text":"<pre><code>inline explicit XW540_T260(\nconst std::string joint_name,\nbool enable_dummy,\nint baudrate,\nuint8_t id,\ndouble max_joint_limit,\ndouble min_joint_limit,\nstd::shared_ptr&lt; dynamixel::PortHandler &gt; port_handler,\nstd::shared_ptr&lt; dynamixel::PacketHandler &gt; packet_handler\n)\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/","title":"dynamixel_hardware_interface::Result","text":"<p>Struct describes the command result. </p> <p><code>#include &lt;motor_base.hpp&gt;</code></p>"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#public-functions","title":"Public Functions","text":"Name Result(const std::string &amp; description, bool success) Construct a new Result object."},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#public-attributes","title":"Public Attributes","text":"Name const bool success If true, command execute successfully. const std::string description Description of the result."},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#function-result","title":"function Result","text":"<pre><code>inline Result(\nconst std::string &amp; description,\nbool success\n)\n</code></pre> <p>Construct a new Result object. </p> <p>Parameters: </p> <ul> <li>description Description of the result. </li> <li>success If true, command execute successfully. </li> </ul>"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#variable-success","title":"variable success","text":"<pre><code>const bool success;\n</code></pre> <p>If true, command execute successfully. </p>"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result/#variable-description","title":"variable description","text":"<pre><code>const std::string description;\n</code></pre> <p>Description of the result. </p> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Examples/","title":"Examples","text":"<p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/","title":"Files","text":"<ul> <li>dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include <ul> <li>dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface <ul> <li>dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors <ul> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. </li> </ul> </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_diagnostic_controller.hpp </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. </li> </ul> </li> </ul> </li> <li>dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src <ul> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp definition of the dynamixal diagnostic controller class </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. </li> <li>file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. </li> </ul> </li> </ul> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp","text":"<p>Base class for the address tabele.  More...</p>"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/#classes","title":"Classes","text":"Name class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Base class for the address tabele. </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01</p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/address__table__base_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_\n#define DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_\n\n#include &lt;boost/optional.hpp&gt;\n#include &lt;cmath&gt;\n#include &lt;dynamixel_hardware_interface/constants.hpp&gt;\n#include &lt;limits&gt;\n\nnamespace dynamixel_hardware_interface\n{\nclass Address\n{\npublic:\nAddress(uint16_t address, PacketByteSize byte_size) : address(address), byte_size(byte_size) {}\nAddress() : address(0), byte_size(PacketByteSize::INVALID) {}\nconst uint16_t address;\nconst PacketByteSize byte_size;\nbool exists() const\n{\nif (byte_size == PacketByteSize::INVALID) {\nreturn false;\n}\nreturn true;\n}\n};\n\nclass AddressTableBase\n{\npublic:\nexplicit AddressTableBase(\nAddress ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED,\nAddress ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD,\nAddress ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE, Address ADDR_MAX_POSITION_LIMIT,\nAddress ADDR_MIN_POSITION_LIMIT)\n: ADDR_TORQUE_ENABLE(ADDR_TORQUE_ENABLE),\nADDR_GOAL_POSITION(ADDR_GOAL_POSITION),\nADDR_MOVING_SPEED(ADDR_MOVING_SPEED),\nADDR_PRESENT_POSITION(ADDR_PRESENT_POSITION),\nADDR_PRESENT_SPEED(ADDR_PRESENT_SPEED),\nADDR_PRESENT_LOAD(ADDR_PRESENT_LOAD),\nADDR_PRESENT_VOLTAGE(ADDR_PRESENT_VOLTAGE),\nADDR_PRESENT_TEMPERATURE(ADDR_PRESENT_TEMPERATURE),\nADDR_MAX_POSITION_LIMIT(ADDR_MAX_POSITION_LIMIT),\nADDR_MIN_POSITION_LIMIT(ADDR_MIN_POSITION_LIMIT)\n{\n}\nAddress getAddress(const Operation &amp; operaiton) const\n{\nswitch (operaiton) {\ncase Operation::TORQUE_ENABLE:\nreturn ADDR_TORQUE_ENABLE;\ncase Operation::GOAL_POSITION:\nreturn ADDR_GOAL_POSITION;\ncase Operation::MOVING_SPEED:\nreturn ADDR_MOVING_SPEED;\ncase Operation::PRESENT_POSITION:\nreturn ADDR_PRESENT_POSITION;\ncase Operation::PRESENT_SPEED:\nreturn ADDR_PRESENT_SPEED;\ncase Operation::PRESENT_LOAD:\nreturn ADDR_PRESENT_LOAD;\ncase Operation::PRESENT_VOLTAGE:\nreturn ADDR_PRESENT_VOLTAGE;\ncase Operation::PRESENT_TEMPERATURE:\nreturn ADDR_PRESENT_TEMPERATURE;\ncase Operation::MAX_POSITION_LIMIT:\nreturn ADDR_MAX_POSITION_LIMIT;\ncase Operation::MIN_POSITION_LIMIT:\nreturn ADDR_MIN_POSITION_LIMIT;\ndefault:\nreturn Address();\n}\n}\nbool addressExists(const Operation &amp; operation) const { return getAddress(operation).exists(); }\n\nprivate:\nAddressTableBase() = delete;\nconst Address ADDR_TORQUE_ENABLE;\nconst Address ADDR_GOAL_POSITION;\nconst Address ADDR_MOVING_SPEED;\nconst Address ADDR_PRESENT_POSITION;\nconst Address ADDR_PRESENT_SPEED;\nconst Address ADDR_PRESENT_LOAD;\nconst Address ADDR_PRESENT_VOLTAGE;\nconst Address ADDR_PRESENT_TEMPERATURE;\nconst Address ADDR_MAX_POSITION_LIMIT;\nconst Address ADDR_MIN_POSITION_LIMIT;\n};\n}  // namespace dynamixel_hardware_interface\n\n#endif  // DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/constants_8hpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp","text":"<p>Header for defineing constant values.  More...</p>"},{"location":"doxygen/markdown/Files/constants_8hpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/constants_8hpp/#defines","title":"Defines","text":"Name GENERATE_ENUM_ITERATOR(T, LAST_VALUE)"},{"location":"doxygen/markdown/Files/constants_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Header for defineing constant values. </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01</p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/constants_8hpp/#macro-documentation","title":"Macro Documentation","text":""},{"location":"doxygen/markdown/Files/constants_8hpp/#define-generate_enum_iterator","title":"define GENERATE_ENUM_ITERATOR","text":"<pre><code>#define GENERATE_ENUM_ITERATOR(\nT,\nLAST_VALUE\n)   inline T operator++(T &amp; x) { return x = (T)(std::underlying_type&lt;T&gt;::type(x) + 1); } \\\n  inline T operator*(T c) { return c; }                                                \\\n  inline T begin(T) { return static_cast&lt;T&gt;(0); }                                      \\\n  inline T end(T)                                                                      \\\n  {                                                                                    \\\n    T l = T::LAST_VALUE;                                                               \\\n    return l;                                                                          \\\n  }\n</code></pre>"},{"location":"doxygen/markdown/Files/constants_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_\n#define DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_\n\n#include &lt;cmath&gt;\n#include &lt;cstdint&gt;\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace dynamixel_hardware_interface\n{\nconstexpr double PROTOCOL_VERSION = 2.0;\nconstexpr int DXL_HOME_POSITION = 0;  // value range:0 ~ 1023\nconstexpr double DXL_MAX_POSITION = 1023.0;\nconstexpr double DXL_MAX_POSITION_DEGREES = 300.0;\nconstexpr double TO_RADIANS = (DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION) * M_PI / 180.0;\nconstexpr double TO_DXL_POS = 1.0 / TO_RADIANS;\nconstexpr double TO_SPEED_REV_PER_MIN = 0.111;\nconstexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI;\nconstexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0;\nconstexpr double TO_LOAD_PERCENT = 0.1;\nconstexpr double TO_VOLTAGE = 0.1;\nconstexpr double PULSE_RESOLUTION = 4096;\n\n#define GENERATE_ENUM_ITERATOR(T, LAST_VALUE)                                          \\\n  inline T operator++(T &amp; x) { return x = (T)(std::underlying_type&lt;T&gt;::type(x) + 1); } \\\n  inline T operator*(T c) { return c; }                                                \\\n  inline T begin(T) { return static_cast&lt;T&gt;(0); }                                      \\\n  inline T end(T)                                                                      \\\n  {                                                                                    \\\n    T l = T::LAST_VALUE;                                                               \\\n    return l;                                                                          \\\n  }\n\nenum class Operation {\nTORQUE_ENABLE,\nGOAL_POSITION,\nMOVING_SPEED,\nPRESENT_POSITION,\nPRESENT_SPEED,\nPRESENT_LOAD,\nPRESENT_VOLTAGE,\nPRESENT_TEMPERATURE,\nMAX_POSITION_LIMIT,\nMIN_POSITION_LIMIT,\nINVALID\n};\n\nGENERATE_ENUM_ITERATOR(Operation, INVALID)\n\n\nenum class SupportedMotors {\nXW540_T260,\nINVALID\n};\n\nGENERATE_ENUM_ITERATOR(SupportedMotors, INVALID)\n\nenum class PacketByteSize { ONE_BYTE, TWO_BYTE, FOUR_BYTE, INVALID };\n\nGENERATE_ENUM_ITERATOR(PacketByteSize, INVALID)\n\nenum class DiagnosticsType { TEMPERATURE, INVALID };\n\nGENERATE_ENUM_ITERATOR(DiagnosticsType, INVALID)\n\n}  //  namespace dynamixel_hardware_interface\n\n#endif  // DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src","text":""},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba/#files","title":"Files","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp definition of the dynamixal diagnostic controller class <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/dir_928fd2f9e5178dedf5db7221eddd41a5/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors","text":""},{"location":"doxygen/markdown/Files/dir_928fd2f9e5178dedf5db7221eddd41a5/#files","title":"Files","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface","text":""},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b/#directories","title":"Directories","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b/#files","title":"Files","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_diagnostic_controller.hpp /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include","text":""},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23/#directories","title":"Directories","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8cpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp","text":"<p>definition of the dynamixal diagnostic controller class  More...</p>"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8cpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8cpp/#detailed-description","title":"Detailed Description","text":"<p>definition of the dynamixal diagnostic controller class </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-16 </p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p> <p>implementation of the dynamixal diagnostic controller class</p>"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8cpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include &lt;dynamixel_hardware_interface/dynamixel_diagnostic_controller.hpp&gt;\n\nnamespace dynamixel_hardware_interface\n{\ncontroller_interface::return_type DynamixelDiagnosticController::init(\nconst std::string &amp; controller_name, const std::string &amp; /*namespace*/,\nconst rclcpp::NodeOptions &amp; /*node_options*/)\n{\nauto ret = ControllerInterface::init(controller_name);\nif (ret != controller_interface::return_type::OK) {\nreturn ret;\n}\nrclcpp::Parameter joints;\nauto node = get_node();\nstd::vector&lt;std::string&gt; joint_names = {};\nnode-&gt;declare_parameter&lt;std::vector&lt;std::string&gt;&gt;(\"joints\", joint_names);\njoints_ = node-&gt;get_parameter(\"joints\").as_string_array();\nfor (const auto &amp; joint : joints_) {\nrclcpp::Parameter diagnostics;\nstd::vector&lt;std::string&gt; joint_parameters = {};\nnode-&gt;declare_parameter&lt;std::vector&lt;std::string&gt;&gt;(joint, joint_parameters);\nif (!get_node()-&gt;get_parameter(joint, diagnostics)) {\nreturn controller_interface::return_type::ERROR;\n}\nstd::vector&lt;dynamixel_hardware_interface::DiagnosticsType&gt; diag_list;\nconst auto diagnostics_strings = diagnostics.as_string_array();\nfor (const auto &amp; diag_string : diagnostics_strings) {\nif (diag_string == \"temperature\") {\ndiag_list.emplace_back(dynamixel_hardware_interface::DiagnosticsType::TEMPERATURE);\n}\n}\ndiagnostics_[joint] = diag_list;\n}\nreturn controller_interface::return_type::OK;\n}\n\nrclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn\nDynamixelDiagnosticController::on_configure(const rclcpp_lifecycle::State &amp; /*previous_state*/)\n{\nauto node = get_node();\ndiag_pub_ = node-&gt;create_publisher&lt;diagnostic_msgs::msg::DiagnosticArray&gt;(\n\"/diagnostics\", rclcpp::SystemDefaultsQoS());\ndiag_pub_realtime_ =\nstd::make_shared&lt;realtime_tools::RealtimePublisher&lt;diagnostic_msgs::msg::DiagnosticArray&gt;&gt;(\ndiag_pub_);\nreturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;\n}\n\ndouble DynamixelDiagnosticController::getValue(\nconst std::string &amp; joint_name, const std::string &amp; interface_name)\n{\nfor (const auto &amp; interface : state_interfaces_) {\nif (interface.get_name() == joint_name &amp;&amp; interface.get_interface_name() == interface_name) {\nreturn interface.get_value();\n}\n}\nthrow std::runtime_error(\n\"state interface : \" + interface_name + \" does not exist in : \" + joint_name);\n}\n\n#if defined(GALACTIC) || defined(HUMBLE)\ncontroller_interface::return_type DynamixelDiagnosticController::update(\nconst rclcpp::Time &amp; time, const rclcpp::Duration &amp;)\n#else\ncontroller_interface::return_type DynamixelDiagnosticController::update()\n#endif\n{\nif (diag_pub_realtime_-&gt;trylock()) {\nauto msg = diagnostic_msgs::msg::DiagnosticArray();\n#if defined(GALACTIC) || defined(HUMBLE)\nmsg.header.stamp = time;\n#else\nmsg.header.stamp = get_node()-&gt;get_clock()-&gt;now();\n#endif\nfor (const auto &amp; joint : joints_) {\nconst auto diagnostic_types = diagnostics_.at(joint);\nauto diag_msg = diagnostic_msgs::msg::DiagnosticStatus();\ndiag_msg.name = \"dynamixel_diagnostics\";\ndiag_msg.hardware_id = joint;\ndiag_msg.level = diag_msg.OK;\nfor (const auto &amp; diag_type : diagnostic_types) {\nauto keyvalue_msg = diagnostic_msgs::msg::KeyValue();\nswitch (diag_type) {\ncase DiagnosticsType::TEMPERATURE:\nkeyvalue_msg.key = \"temperature\";\nkeyvalue_msg.value = std::to_string(getValue(joint, keyvalue_msg.key));\nbreak;\ndefault:\nthrow std::runtime_error(\"diagnostic type is invalid\");\nbreak;\n}\ndiag_msg.values.emplace_back(keyvalue_msg);\nmsg.status.emplace_back(diag_msg);\n}\n}\ndiag_pub_realtime_-&gt;msg_ = msg;\ndiag_pub_realtime_-&gt;unlockAndPublish();\n}\nreturn controller_interface::return_type::OK;\n}\n}  // namespace dynamixel_hardware_interface\n\n#include \"pluginlib/class_list_macros.hpp\"\n\nPLUGINLIB_EXPORT_CLASS(\ndynamixel_hardware_interface::DynamixelDiagnosticController,\ncontroller_interface::ControllerInterface)\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8hpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_diagnostic_controller.hpp","text":""},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8hpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8hpp/#classes","title":"Classes","text":"Name class dynamixel_hardware_interface::DynamixelDiagnosticController"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include &lt;dynamixel_hardware_interface/visiblity_control.h&gt;\n#include &lt;realtime_tools/realtime_buffer.h&gt;\n#include &lt;realtime_tools/realtime_publisher.h&gt;\n\n#include &lt;controller_interface/controller_interface.hpp&gt;\n#include &lt;diagnostic_msgs/msg/diagnostic_array.hpp&gt;\n#include &lt;dynamixel_hardware_interface/constants.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;rclcpp/subscription.hpp&gt;\n#include &lt;rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp&gt;\n#include &lt;rclcpp_lifecycle/state.hpp&gt;\n#include &lt;string&gt;\n#include &lt;unordered_map&gt;\n#include &lt;vector&gt;\n\nnamespace dynamixel_hardware_interface\n{\nclass DynamixelDiagnosticController : public controller_interface::ControllerInterface\n{\npublic:\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\ncontroller_interface::return_type init(\nconst std::string &amp; controller_name, const std::string &amp; namespace_ = \"\",\nconst rclcpp::NodeOptions &amp; node_options =\nrclcpp::NodeOptions()\n.allow_undeclared_parameters(true)\n.automatically_declare_parameters_from_overrides(true)) override;\n\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\ncontroller_interface::InterfaceConfiguration command_interface_configuration() const override\n{\nreturn controller_interface::InterfaceConfiguration{\ncontroller_interface::interface_configuration_type::NONE};\n}\n\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\ncontroller_interface::InterfaceConfiguration state_interface_configuration() const override\n{\nstd::vector&lt;std::string&gt; interface_names;\nfor (const auto &amp; joint : joints_) {\nconst auto diagnostic_types = diagnostics_.at(joint);\nfor (const auto &amp; diagnostic_type : diagnostic_types) {\nswitch (diagnostic_type) {\ncase DiagnosticsType::TEMPERATURE:\ninterface_names.emplace_back(joint + \"/temperature\");\nbreak;\ndefault:\nbreak;\n}\n}\n}\nreturn controller_interface::InterfaceConfiguration{\ncontroller_interface::interface_configuration_type::INDIVIDUAL, interface_names};\n}\n\n#if defined(GALACTIC) || defined(HUMBLE)\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nrclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_init()\n{\nreturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;\n}\n#endif\n\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nrclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_configure(\nconst rclcpp_lifecycle::State &amp; /*previous_state*/) override;\n\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nrclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_activate(\nconst rclcpp_lifecycle::State &amp; /*previous_state*/) override\n{\nreturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;\n}\n\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nrclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_deactivate(\nconst rclcpp_lifecycle::State &amp; /*previous_state*/) override\n{\nreturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;\n}\n\n#if defined(GALACTIC) || defined(HUMBLE)\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\ncontroller_interface::return_type update(\nconst rclcpp::Time &amp; time, const rclcpp::Duration &amp; period) override;\n#else\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\ncontroller_interface::return_type update() override;\n#endif\n\nprivate:\nstd::vector&lt;std::string&gt; joints_;\nstd::unordered_map&lt;std::string, std::vector&lt;dynamixel_hardware_interface::DiagnosticsType&gt;&gt;\ndiagnostics_;\nrclcpp::Publisher&lt;diagnostic_msgs::msg::DiagnosticArray&gt;::SharedPtr diag_pub_;\nstd::shared_ptr&lt;realtime_tools::RealtimePublisher&lt;diagnostic_msgs::msg::DiagnosticArray&gt;&gt;\ndiag_pub_realtime_;\ndouble getValue(const std::string &amp; joint_name, const std::string &amp; interface);\n};\n}  // namespace dynamixel_hardware_interface\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp","text":"<p>Class implementation of the hardware interface for the Dynamixel motor.  More...</p>"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Class implementation of the hardware interface for the Dynamixel motor. </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01</p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include &lt;dynamixel_hardware_interface/dynamixel_hardware_interface.hpp&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace dynamixel_hardware_interface\n{\n#if defined(GALACTIC) || defined(HUMBLE)\nrclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn\nDynamixelHardwareInterface::on_init(const hardware_interface::HardwareInfo &amp; info)\n#else\nhardware_interface::return_type DynamixelHardwareInterface::configure(\nconst hardware_interface::HardwareInfo &amp; info)\n#endif\n{\n#if defined(GALACTIC) || defined(HUMBLE)\nif (\nSystemInterface::on_init(info) !=\nrclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS) {\nreturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;\n}\n#else\nif (configure_default(info) != hardware_interface::return_type::OK) {\nreturn hardware_interface::return_type::ERROR;\n}\n#endif\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"), \"configure hardware \" &lt;&lt; info.name);\nfor (const auto &amp; hardware_parameter : info_.hardware_parameters) {\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"),\n\"hardware parameter : \" &lt;&lt; hardware_parameter.first &lt;&lt; \" = \" &lt;&lt; hardware_parameter.second);\n}\nport_name_ = getHardwareParameter&lt;std::string&gt;(\"port_name\");\nbaudrate_ = getHardwareParameter&lt;int&gt;(\"baudrate\");\nRCLCPP_INFO(rclcpp::get_logger(\"dynamixel_hardware_interface\"), \"initialize port handler\");\nport_handler_ = std::shared_ptr&lt;dynamixel::PortHandler&gt;(\ndynamixel::PortHandler::getPortHandler(port_name_.c_str()));\nport_handler_-&gt;setBaudRate(baudrate_);\nRCLCPP_INFO(rclcpp::get_logger(\"dynamixel_hardware_interface\"), \"initialize packet handler\");\npacket_handler_ = std::shared_ptr&lt;dynamixel::PacketHandler&gt;(\ndynamixel::PacketHandler::getPacketHandler(PROTOCOL_VERSION));\nif (!getHardwareParameter&lt;bool&gt;(\"enable_dummy\")) {\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"),\n\"serial port : \" &lt;&lt; port_handler_-&gt;getPortName());\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"),\n\"baudrate : \" &lt;&lt; port_handler_-&gt;getBaudRate());\nif (port_handler_-&gt;openPort()) {\nRCLCPP_INFO(rclcpp::get_logger(\"dynamixel_hardware_interface\"), \"open serial port succeed\");\n} else {\nRCLCPP_ERROR(rclcpp::get_logger(\"dynamixel_hardware_interface\"), \"open serial port failed\");\n#if defined(GALACTIC) || defined(HUMBLE)\nreturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;\n#else\nreturn hardware_interface::return_type::ERROR;\n#endif\n}\n}\nRCLCPP_INFO(rclcpp::get_logger(\"dynamixel_hardware_interface\"), \"configure each motors\");\nfor (const auto &amp; joint : info.joints) {\nstd::shared_ptr&lt;MotorBase&gt; motor;\ntry {\nmotor = constructMotorInstance(joint);\n} catch (const std::runtime_error &amp; e) {\nRCLCPP_ERROR_STREAM(rclcpp::get_logger(\"dynamixel_hardware_interface\"), e.what());\n#if defined(GALACTIC) || defined(HUMBLE)\nreturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;\n#else\nreturn hardware_interface::return_type::ERROR;\n#endif\n}\nconst auto result = motor-&gt;configure();\nif (!result.success) {\nRCLCPP_ERROR_STREAM(rclcpp::get_logger(\"dynamixel_hardware_interface\"), result.description);\n#if defined(GALACTIC) || defined(HUMBLE)\nreturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::ERROR;\n#else\nreturn hardware_interface::return_type::ERROR;\n#endif\n}\nmotors_.emplace_back(motor);\n}\n#if defined(GALACTIC) || defined(HUMBLE)\nreturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn::SUCCESS;\n#else\nreturn hardware_interface::return_type::OK;\n#endif\n}\n\nstd::vector&lt;hardware_interface::StateInterface&gt;\nDynamixelHardwareInterface::export_state_interfaces()\n{\nstd::vector&lt;hardware_interface::StateInterface&gt; state_interfaces = {};\nfor (const auto &amp; motor : motors_) {\nmotor-&gt;appendStateInterfaces(state_interfaces);\n}\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"), state_interfaces.size()\n&lt;&lt; \" state interfaces exported.\");\nreturn state_interfaces;\n}\n\nstd::vector&lt;hardware_interface::CommandInterface&gt;\nDynamixelHardwareInterface::export_command_interfaces()\n{\nstd::vector&lt;hardware_interface::CommandInterface&gt; command_interfaces = {};\nfor (const auto &amp; motor : motors_) {\nmotor-&gt;appendCommandInterfaces(command_interfaces);\n}\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"), command_interfaces.size()\n&lt;&lt; \" command interfaces exported.\");\nreturn command_interfaces;\n}\n\nSupportedMotors DynamixelHardwareInterface::strToSupportMotorsEnum(\nconst std::string &amp; motor_type) const\n{\nif (motor_type == \"XW540-T260\") {\nreturn SupportedMotors::XW540_T260;\n}\nreturn SupportedMotors::INVALID;\n}\n\nstd::shared_ptr&lt;MotorBase&gt; DynamixelHardwareInterface::constructMotorInstance(\nconst hardware_interface::ComponentInfo &amp; info) const\n{\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"),\n\"constructing motor instance : \" &lt;&lt; info.name);\nfor (const auto &amp; parameter : info.parameters) {\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"),\n\"parameter \" &lt;&lt; parameter.first &lt;&lt; \" : \" &lt;&lt; parameter.second);\n}\nif (info.type == \"joint\") {\nconst auto motor_type = strToSupportMotorsEnum(getParameter&lt;std::string&gt;(\"motor_type\", info));\nif (motor_type == SupportedMotors::INVALID) {\nthrow std::runtime_error(\"failed to construct motor instance, motor type is invalid\");\n}\nconst auto id = static_cast&lt;uint8_t&gt;(getParameter&lt;int&gt;(\"id\", info));\n\nconst auto max_joint_limit = getParameter&lt;double&gt;(\"max_joint_limit\", info);\nconst auto min_joint_limit = getParameter&lt;double&gt;(\"min_joint_limit\", info);\n\nswitch (motor_type) {\ncase SupportedMotors::XW540_T260:\nreturn std::make_shared&lt;motors::XW540_T260&gt;(\ninfo.name, getHardwareParameter&lt;bool&gt;(\"enable_dummy\"), baudrate_, id, max_joint_limit,\nmin_joint_limit, port_handler_, packet_handler_);\nbreak;\ndefault:\nbreak;\n}\n}\nthrow std::runtime_error(\"failed to construct motor instance\");\n}\n\n// #ifndef GALACTIC\n// hardware_interface::return_type DynamixelHardwareInterface::start()\n// {\n//   status_ = hardware_interface::status::STARTED;\n//   return hardware_interface::return_type::OK;\n// }\n\n// hardware_interface::return_type DynamixelHardwareInterface::stop()\n// {\n//   return hardware_interface::return_type::OK;\n// }\n// #endif\n\nhardware_interface::return_type DynamixelHardwareInterface::read(\nconst rclcpp::Time &amp; /*time*/, const rclcpp::Duration &amp; /*period*/)\n{\nfor (const auto &amp; motor : motors_) {\nif (motor-&gt;operationSupports(Operation::PRESENT_POSITION)) {\nconst auto result = motor-&gt;updateJointPosition();\nif (!result.success) {\nRCLCPP_ERROR_STREAM(rclcpp::get_logger(\"dynamixel_hardware_interface\"), result.description);\nreturn hardware_interface::return_type::ERROR;\n}\n}\nif (motor-&gt;operationSupports(Operation::PRESENT_SPEED)) {\nconst auto result = motor-&gt;updateJointVelocity();\nif (!result.success) {\nRCLCPP_ERROR_STREAM(rclcpp::get_logger(\"dynamixel_hardware_interface\"), result.description);\nreturn hardware_interface::return_type::ERROR;\n}\n}\nif (motor-&gt;operationSupports(Operation::PRESENT_TEMPERATURE)) {\nconst auto result = motor-&gt;updatePresentTemperature();\nif (!result.success) {\nRCLCPP_ERROR_STREAM(rclcpp::get_logger(\"dynamixel_hardware_interface\"), result.description);\nreturn hardware_interface::return_type::ERROR;\n}\n}\n}\nreturn hardware_interface::return_type::OK;\n}\n\nhardware_interface::return_type DynamixelHardwareInterface::write(\nconst rclcpp::Time &amp; /*time*/, const rclcpp::Duration &amp; /*period*/)\n{\nfor (const auto &amp; motor : motors_) {\nif (motor-&gt;operationSupports(Operation::GOAL_POSITION)) {\nmotor-&gt;setCurrentGoalPosition();\n}\n}\nreturn hardware_interface::return_type::OK;\n}\n}  // namespace dynamixel_hardware_interface\n\n#include \"pluginlib/class_list_macros.hpp\"\n\nPLUGINLIB_EXPORT_CLASS(\ndynamixel_hardware_interface::DynamixelHardwareInterface, hardware_interface::SystemInterface)\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp","text":"<p>Hardware interface class for dynamixel motor.  More...</p>"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/#classes","title":"Classes","text":"Name class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor."},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Hardware interface class for dynamixel motor. </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01</p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_\n#define DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_\n\n#include &lt;dynamixel_hardware_interface/visiblity_control.h&gt;\n#include &lt;dynamixel_sdk/dynamixel_sdk.h&gt;\n\n#include &lt;dynamixel_hardware_interface/motors/motors.hpp&gt;\n#if defined(GALACTIC) || defined(HUMBLE)\n#include &lt;hardware_interface/system_interface.hpp&gt;\n#else\n#include &lt;hardware_interface/base_interface.hpp&gt;\n#endif\n#include &lt;hardware_interface/handle.hpp&gt;\n#include &lt;hardware_interface/hardware_info.hpp&gt;\n#include &lt;hardware_interface/system_interface.hpp&gt;\n#include &lt;hardware_interface/types/hardware_interface_return_values.hpp&gt;\n#if defined(GALACTIC) || defined(HUMBLE)\n#include &lt;hardware_interface/types/hardware_interface_type_values.hpp&gt;\n#else\n#include &lt;hardware_interface/types/hardware_interface_status_values.hpp&gt;\n#endif\n#include &lt;memory&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace dynamixel_hardware_interface\n{\nclass DynamixelHardwareInterface\n#if defined(GALACTIC) || defined(HUMBLE)\n: public hardware_interface::SystemInterface\n#else\n: public hardware_interface::BaseInterface&lt;hardware_interface::SystemInterface&gt;\n#endif\n{\npublic:\nRCLCPP_SHARED_PTR_DEFINITIONS(DynamixelHardwareInterface)\n\n#if defined(GALACTIC) || defined(HUMBLE)\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nrclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_init(\nconst hardware_interface::HardwareInfo &amp; info) override;\n#else\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nhardware_interface::return_type configure(const hardware_interface::HardwareInfo &amp; info) override;\n#endif\n\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nstd::vector&lt;hardware_interface::StateInterface&gt; export_state_interfaces() override;\n\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nstd::vector&lt;hardware_interface::CommandInterface&gt; export_command_interfaces() override;\n\n// #if !defined(GALACTIC) || ~defined(HUMBLE)\n// #ifndef GALACTIC\n//   DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\n//   hardware_interface::return_type start() override;\n//   DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\n//   hardware_interface::return_type stop() override;\n// #endif\n\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nhardware_interface::return_type read(\nconst rclcpp::Time &amp; time, const rclcpp::Duration &amp; period) override;\n\nDYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\nhardware_interface::return_type write(\nconst rclcpp::Time &amp; time, const rclcpp::Duration &amp; period) override;\n\nprivate:\nstd::string port_name_;\nint baudrate_;\nSupportedMotors strToSupportMotorsEnum(const std::string &amp; motor_type) const;\n\ntemplate &lt;typename T&gt;\nT getParameter(const std::string key, const hardware_interface::ComponentInfo &amp; info) const\n{\nT param;\ngetParameter(key, info, param);\nreturn param;\n}\nvoid getParameter(\nconst std::string &amp; key, const hardware_interface::ComponentInfo &amp; info,\nstd::string &amp; parameter) const\n{\ntry {\nparameter = info.parameters.at(key);\n} catch (std::out_of_range &amp; e) {\nRCLCPP_ERROR_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"),\n\"parameter : \" &lt;&lt; key &lt;&lt; \" does not exist.\");\n}\n}\nvoid getParameter(\nconst std::string &amp; key, const hardware_interface::ComponentInfo &amp; info, int &amp; parameter) const\n{\nstd::string param_string;\ngetParameter(key, info, param_string);\nparameter = std::stoi(param_string);\n}\nvoid getParameter(\nconst std::string &amp; key, const hardware_interface::ComponentInfo &amp; info,\ndouble &amp; parameter) const\n{\nstd::string param_string;\ngetParameter(key, info, param_string);\nparameter = std::stod(param_string);\n}\nvoid getParameter(\nconst std::string &amp; key, const hardware_interface::ComponentInfo &amp; info, bool &amp; parameter) const\n{\nparameter = false;\nstd::string param_string;\ngetParameter(key, info, param_string);\nif (param_string == \"true\" || param_string == \"True\") {\nparameter = true;\n}\n}\ntemplate &lt;typename T&gt;\nT getHardwareParameter(const std::string key) const\n{\nT param;\ngetHardwareParameter(key, param);\nreturn param;\n}\nvoid getHardwareParameter(const std::string &amp; key, std::string &amp; parameter) const\n{\ntry {\nparameter = info_.hardware_parameters.at(key);\n} catch (std::out_of_range &amp; e) {\nRCLCPP_ERROR_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"),\n\"hardware parameter : \" &lt;&lt; key &lt;&lt; \" does not exist.\");\n}\n}\nvoid getHardwareParameter(const std::string &amp; key, int &amp; parameter) const\n{\nstd::string param_string;\ngetHardwareParameter(key, param_string);\nparameter = std::stoi(param_string);\n}\nvoid getHardwareParameter(const std::string &amp; key, bool &amp; parameter) const\n{\nparameter = false;\nstd::string param_string;\ngetHardwareParameter(key, param_string);\nif (param_string == \"true\" || param_string == \"True\") {\nparameter = true;\n}\n}\nstd::shared_ptr&lt;MotorBase&gt; constructMotorInstance(\nconst hardware_interface::ComponentInfo &amp; info) const;\nstd::vector&lt;std::shared_ptr&lt;MotorBase&gt;&gt; motors_;\nstd::shared_ptr&lt;dynamixel::PortHandler&gt; port_handler_;\nstd::shared_ptr&lt;dynamixel::PacketHandler&gt; packet_handler_;\n};\n}  // namespace dynamixel_hardware_interface\n\n#endif  // DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/motor__base_8cpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp","text":"<p>Implementation of the motor class.  More...</p>"},{"location":"doxygen/markdown/Files/motor__base_8cpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/motor__base_8cpp/#detailed-description","title":"Detailed Description","text":"<p>Implementation of the motor class. </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01</p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/motor__base_8cpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include &lt;dynamixel_hardware_interface/motor_base.hpp&gt;\n#include &lt;dynamixel_hardware_interface/util.hpp&gt;\n#include &lt;hardware_interface/types/hardware_interface_return_values.hpp&gt;\n#include &lt;hardware_interface/types/hardware_interface_type_values.hpp&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace dynamixel_hardware_interface\n{\nMotorBase::~MotorBase()\n{\nif (!enable_dummy) {\ntorqueEnable(false);\n}\n}\n\nbool MotorBase::operationSupports(const Operation &amp; operation)\n{\nconst auto address = address_table_-&gt;getAddress(operation);\nif (!address.exists()) {\nreturn false;\n}\nreturn true;\n}\n\nstd::vector&lt;Operation&gt; MotorBase::getSupportedOperations()\n{\nstd::vector&lt;Operation&gt; ret = {};\nfor (const auto operation : Operation()) {\nconst auto address = address_table_-&gt;getAddress(operation);\nif (address.exists()) {\nret.emplace_back(operation);\n}\n}\nreturn ret;\n}\n\ndouble MotorBase::valueToRpm(uint8_t) const\n{\nthrow std::runtime_error(\"value to rpm function should be implemented for each motor\");\n}\n\ndouble MotorBase::valueToRpm(uint16_t) const\n{\nthrow std::runtime_error(\"value to rpm function should be implemented for each motor\");\n}\n\ndouble MotorBase::valueToRpm(uint32_t) const\n{\nthrow std::runtime_error(\"value to rpm function should be implemented for each motor\");\n}\n\ndouble MotorBase::positionToRadian(const uint8_t) const\n{\nthrow std::runtime_error(\"position to radian function should be implemented for each motor\");\n}\n\ndouble MotorBase::positionToRadian(const uint16_t) const\n{\nthrow std::runtime_error(\"position to radian function should be implemented for each motor\");\n}\n\ndouble MotorBase::positionToRadian(const uint32_t) const\n{\nthrow std::runtime_error(\"position to radian function should be implemented for each motor\");\n}\n\nvoid MotorBase::radianToPosition(double, uint8_t &amp;) const\n{\nthrow std::runtime_error(\"radian to position function should be implemented for each motor\");\n}\n\nvoid MotorBase::radianToPosition(double, uint16_t &amp;) const\n{\nthrow std::runtime_error(\"radian to position function should be implemented for each motor\");\n}\nvoid MotorBase::radianToPosition(double, uint32_t &amp;) const\n{\nthrow std::runtime_error(\"radian to position function should be implemented for each motor\");\n}\n\ndouble MotorBase::valueToTemperature(uint8_t) const\n{\nthrow std::runtime_error(\"value to temperature function should be implemented for each motor\");\n}\n\ndouble MotorBase::valueToTemperature(uint16_t) const\n{\nthrow std::runtime_error(\"value to temperature function should be implemented for each motor\");\n}\n\ndouble MotorBase::valueToTemperature(uint32_t) const\n{\nthrow std::runtime_error(\"value to temperature function should be implemented for each motor\");\n}\n\nResult MotorBase::getResult(int communication_result, uint8_t packet_error)\n{\nif (communication_result != COMM_SUCCESS) {\nreturn Result(std::string(packet_handler_-&gt;getTxRxResult(communication_result)), false);\n}\nif (packet_error != 0) {\nreturn Result(std::string(packet_handler_-&gt;getRxPacketError(packet_error)), true);\n}\nreturn Result(\"\", true);\n}\n\nResult MotorBase::configure()\n{\nif (address_table_-&gt;addressExists(Operation::PRESENT_POSITION)) {\njoint_position_ = 0;\n}\nif (address_table_-&gt;addressExists(Operation::GOAL_POSITION)) {\ngoal_position_ = 0;\n}\n\nif (!enable_dummy) {\nResult joint_limit_result = setJointPositionLimit(max_joint_limit, min_joint_limit);\nif (!joint_limit_result.success) {\nreturn joint_limit_result;\n}\nResult torque_result = torqueEnable(true);\nif (!torque_result.success) {\nreturn torque_result;\n}\n}\nreturn Result(\"\", true);\n}\n\nvoid MotorBase::appendStateInterfaces(std::vector&lt;hardware_interface::StateInterface&gt; &amp; interfaces)\n{\nfor (const auto operation : Operation()) {\nif (address_table_-&gt;addressExists(operation)) {\nswitch (operation) {\ncase Operation::PRESENT_POSITION:\ninterfaces.emplace_back(hardware_interface::StateInterface(\njoint_name, hardware_interface::HW_IF_POSITION, &amp;joint_position_));\nbreak;\ncase Operation::PRESENT_SPEED:\ninterfaces.emplace_back(hardware_interface::StateInterface(\njoint_name, hardware_interface::HW_IF_VELOCITY, &amp;joint_position_));\nbreak;\ncase Operation::PRESENT_TEMPERATURE:\ninterfaces.emplace_back(\nhardware_interface::StateInterface(joint_name, \"temperature\", &amp;present_temperature_));\nbreak;\ndefault:\nbreak;\n}\n}\n}\n}\n\nvoid MotorBase::appendCommandInterfaces(\nstd::vector&lt;hardware_interface::CommandInterface&gt; &amp; interfaces)\n{\nfor (const auto operation : Operation()) {\nif (address_table_-&gt;addressExists(operation)) {\nswitch (operation) {\ncase Operation::GOAL_POSITION:\ninterfaces.emplace_back(hardware_interface::CommandInterface(\njoint_name, hardware_interface::HW_IF_POSITION, &amp;goal_position_));\nbreak;\ncase Operation::MOVING_SPEED:\ninterfaces.emplace_back(hardware_interface::CommandInterface(\njoint_name, hardware_interface::HW_IF_VELOCITY, &amp;goal_velocity_));\ndefault:\nbreak;\n}\n}\n}\n}\n\nResult MotorBase::setJointPositionLimit(double max_joint_limit, double min_joint_limit)\n{\nconst auto address_max_joint_limit = address_table_-&gt;getAddress(Operation::MAX_POSITION_LIMIT);\nconst auto address_min_joint_limit = address_table_-&gt;getAddress(Operation::MIN_POSITION_LIMIT);\n\nif (!address_max_joint_limit.exists()) {\nreturn Result(\n\"MAX_POSITION_LIMIT operation does not support in \" + toString(motor_type), false);\n}\nif (!address_min_joint_limit.exists()) {\nreturn Result(\n\"MIN_POSITION_LIMIT operation does not support in \" + toString(motor_type), false);\n}\nuint8_t error = 0;\nif (address_max_joint_limit.byte_size == PacketByteSize::FOUR_BYTE) {\nconst auto result_max = packet_handler_-&gt;write4ByteTxRx(\nport_handler_.get(), id, address_max_joint_limit.address,\nradianToPosition&lt;uint32_t&gt;(max_joint_limit), &amp;error);\nResult result = getResult(result_max, error);\nif (!result.success) {\nreturn result;\n}\nconst auto result_min = packet_handler_-&gt;write4ByteTxRx(\nport_handler_.get(), id, address_min_joint_limit.address,\nradianToPosition&lt;uint32_t&gt;(min_joint_limit), &amp;error);\nreturn getResult(result_min, error);\n}\nreturn Result(\"Invalid packet size\", false);\n}\n\nResult MotorBase::torqueEnable(bool enable)\n{\nconst auto address = address_table_-&gt;getAddress(Operation::TORQUE_ENABLE);\nif (!address.exists()) {\nreturn Result(\"TORQUE_ENABLE operation does not support in \" + toString(motor_type), false);\n}\nuint8_t error = 0;\nconst auto result =\npacket_handler_-&gt;write1ByteTxRx(port_handler_.get(), id, address.address, enable, &amp;error);\nreturn getResult(result, error);\n}\n\nResult MotorBase::setGoalPosition(double goal_position)\n{\ngoal_position_ = goal_position;\nconst auto address = address_table_-&gt;getAddress(Operation::GOAL_POSITION);\nif (!address.exists()) {\nreturn Result(\"TORQUE_ENABLE operation does not support in \" + toString(motor_type), false);\n}\nif (enable_dummy) {\njoint_position_ = goal_position_;\nreturn Result(\"\", true);\n} else {\nuint8_t error = 0;\nif (address.byte_size == PacketByteSize::ONE_BYTE) {\nconst auto result = packet_handler_-&gt;write1ByteTxRx(\nport_handler_.get(), id, address.address, radianToPosition&lt;uint8_t&gt;(goal_position_),\n&amp;error);\nreturn getResult(result, error);\n}\nif (address.byte_size == PacketByteSize::TWO_BYTE) {\nconst auto result = packet_handler_-&gt;write2ByteTxRx(\nport_handler_.get(), id, address.address, radianToPosition&lt;uint16_t&gt;(goal_position_),\n&amp;error);\nreturn getResult(result, error);\n}\nif (address.byte_size == PacketByteSize::FOUR_BYTE) {\nconst auto result = packet_handler_-&gt;write4ByteTxRx(\nport_handler_.get(), id, address.address, radianToPosition&lt;uint32_t&gt;(goal_position_),\n&amp;error);\nreturn getResult(result, error);\n}\nreturn Result(\"Invalid packet size\", false);\n}\n}\n\nResult MotorBase::updateJointVelocity()\n{\nconst auto address = address_table_-&gt;getAddress(Operation::PRESENT_SPEED);\nif (!address.exists()) {\nreturn Result(\"PRESENT_SPEED operation does not support in \" + toString(motor_type), false);\n}\nif (enable_dummy) {\njoint_velocity_ = goal_velocity_;\nreturn Result(\"\", true);\n} else {\nuint8_t error = 0;\nif (address.byte_size == PacketByteSize::ONE_BYTE) {\nuint8_t present_speed = 0;\nconst auto result = packet_handler_-&gt;read1ByteTxRx(\nport_handler_.get(), id, address.address, &amp;present_speed, &amp;error);\njoint_velocity_ = valueToRpm(present_speed);\nreturn getResult(result, error);\n}\nif (address.byte_size == PacketByteSize::TWO_BYTE) {\nuint16_t present_speed = 0;\nconst auto result = packet_handler_-&gt;read2ByteTxRx(\nport_handler_.get(), id, address.address, &amp;present_speed, &amp;error);\njoint_velocity_ = valueToRpm(present_speed);\nreturn getResult(result, error);\n}\nif (address.byte_size == PacketByteSize::FOUR_BYTE) {\nuint32_t present_speed = 0;\nconst auto result = packet_handler_-&gt;read4ByteTxRx(\nport_handler_.get(), id, address.address, &amp;present_speed, &amp;error);\njoint_velocity_ = valueToRpm(present_speed);\nreturn getResult(result, error);\n}\nreturn Result(\"Invalid packet size\", false);\n}\n}\n\nResult MotorBase::updateJointPosition()\n{\nconst auto address = address_table_-&gt;getAddress(Operation::PRESENT_POSITION);\nif (!address.exists()) {\nreturn Result(\"PRESENT_POSITION operation does not support in \" + toString(motor_type), false);\n}\nif (enable_dummy) {\njoint_position_ = goal_position_;\nreturn Result(\"\", true);\n} else {\nuint8_t error = 0;\nif (address.byte_size == PacketByteSize::ONE_BYTE) {\nuint8_t present_position = 0;\nconst auto result = packet_handler_-&gt;read1ByteTxRx(\nport_handler_.get(), id, address.address, &amp;present_position, &amp;error);\njoint_position_ = positionToRadian(present_position);\nreturn getResult(result, error);\n}\nif (address.byte_size == PacketByteSize::TWO_BYTE) {\nuint16_t present_position = 0;\nconst auto result = packet_handler_-&gt;read2ByteTxRx(\nport_handler_.get(), id, address.address, &amp;present_position, &amp;error);\njoint_position_ = positionToRadian(present_position);\nreturn getResult(result, error);\n}\nif (address.byte_size == PacketByteSize::FOUR_BYTE) {\nuint32_t present_position = 0;\nconst auto result = packet_handler_-&gt;read4ByteTxRx(\nport_handler_.get(), id, address.address, &amp;present_position, &amp;error);\njoint_position_ = positionToRadian(present_position);\nreturn getResult(result, error);\n}\nreturn Result(\"Invalid packet size\", false);\n}\n}\n\nResult MotorBase::updatePresentTemperature()\n{\nconst auto address = address_table_-&gt;getAddress(Operation::PRESENT_TEMPERATURE);\nif (!address.exists()) {\nreturn Result(\n\"PRESENT_TEMPERATURE operation does not support in \" + toString(motor_type), false);\n}\nif (enable_dummy) {\npresent_temperature_ = 0;\nreturn Result(\"\", true);\n} else {\nuint8_t error = 0;\nif (address.byte_size == PacketByteSize::ONE_BYTE) {\nuint8_t present_temperature = 0;\nconst auto result = packet_handler_-&gt;read1ByteTxRx(\nport_handler_.get(), id, address.address, &amp;present_temperature, &amp;error);\npresent_temperature_ = valueToTemperature(present_temperature);\nreturn getResult(result, error);\n}\nif (address.byte_size == PacketByteSize::TWO_BYTE) {\nuint16_t present_temperature = 0;\nconst auto result = packet_handler_-&gt;read2ByteTxRx(\nport_handler_.get(), id, address.address, &amp;present_temperature, &amp;error);\npresent_temperature_ = valueToTemperature(present_temperature);\nreturn getResult(result, error);\n}\nif (address.byte_size == PacketByteSize::FOUR_BYTE) {\nuint32_t present_temperature = 0;\nconst auto result = packet_handler_-&gt;read4ByteTxRx(\nport_handler_.get(), id, address.address, &amp;present_temperature, &amp;error);\npresent_temperature_ = valueToTemperature(present_temperature);\nreturn getResult(result, error);\n}\nreturn Result(\"Invalid packet size\", false);\n}\n}\n}  //  namespace dynamixel_hardware_interface\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/motor__base_8hpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp","text":"<p>base class of the dynamixel motor  More...</p>"},{"location":"doxygen/markdown/Files/motor__base_8hpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/motor__base_8hpp/#classes","title":"Classes","text":"Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor."},{"location":"doxygen/markdown/Files/motor__base_8hpp/#detailed-description","title":"Detailed Description","text":"<p>base class of the dynamixel motor </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01 </p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/motor__base_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_\n#define DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_\n\n#include &lt;dynamixel_sdk/dynamixel_sdk.h&gt;\n\n#include &lt;dynamixel_hardware_interface/address_table_base.hpp&gt;\n#include &lt;dynamixel_hardware_interface/constants.hpp&gt;\n#if defined(GALACTIC) || defined(HUMBLE)\n#include &lt;hardware_interface/system_interface.hpp&gt;\n#else\n#include &lt;hardware_interface/base_interface.hpp&gt;\n#endif\n#include &lt;hardware_interface/handle.hpp&gt;\n#include &lt;hardware_interface/hardware_info.hpp&gt;\n#include &lt;hardware_interface/system_interface.hpp&gt;\n#include &lt;hardware_interface/types/hardware_interface_return_values.hpp&gt;\n#if defined(GALACTIC) || defined(HUMBLE)\n#include &lt;hardware_interface/types/hardware_interface_type_values.hpp&gt;\n#else\n#include &lt;hardware_interface/types/hardware_interface_status_values.hpp&gt;\n#endif\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;string&gt;\n#include &lt;vector&gt;\n\nnamespace dynamixel_hardware_interface\n{\nstruct Result\n{\nconst std::string description;\nconst bool success;\nResult(const std::string &amp; description, bool success) : description(description), success(success)\n{\n}\n};\n\nclass MotorBase\n{\npublic:\nconst SupportedMotors motor_type;\nconst std::string joint_name;\nconst bool enable_dummy;\nconst int baudrate;\nconst uint8_t id;\n\nconst double max_joint_limit;\nconst double min_joint_limit;\ntemplate &lt;typename AddressTable&gt;\nMotorBase(\nconst SupportedMotors &amp; motor_type, const std::string &amp; joint_name, const bool enable_dummy,\nconst AddressTable &amp; table, int baudrate, uint8_t id, double max_joint_limit,\ndouble min_joint_limit, std::shared_ptr&lt;dynamixel::PortHandler&gt; port_handler,\nstd::shared_ptr&lt;dynamixel::PacketHandler&gt; packet_handler)\n: motor_type(motor_type),\njoint_name(joint_name),\nenable_dummy(enable_dummy),\nbaudrate(baudrate),\nid(id),\nmax_joint_limit(max_joint_limit),\nmin_joint_limit(min_joint_limit),\nport_handler_(port_handler),\npacket_handler_(packet_handler),\njoint_position_(std::numeric_limits&lt;double&gt;::quiet_NaN()),\ngoal_position_(std::numeric_limits&lt;double&gt;::quiet_NaN())\n{\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"), \"start constructing motor instance\");\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"), \"joint_name : \" &lt;&lt; joint_name);\naddress_table_ = std::make_shared&lt;AddressTableBase&gt;(table);\nRCLCPP_INFO_STREAM(\nrclcpp::get_logger(\"dynamixel_hardware_interface\"), \"end constructing motor instance\");\n}\n~MotorBase();\nbool operationSupports(const Operation &amp; operation);\nvirtual std::vector&lt;Operation&gt; getSupportedOperations();\nvirtual Result configure();\nvirtual Result torqueEnable(bool enable);\nvirtual Result setGoalPosition(double goal_position);\nvirtual Result setCurrentGoalPosition() { return setGoalPosition(goal_position_); }\nvirtual double getJointPosition() const { return joint_position_; }\nvirtual double getGoalPosition() const { return goal_position_; }\nvirtual Result updateJointPosition();\nvirtual Result updateJointVelocity();\nvirtual Result updatePresentTemperature();\nvirtual void appendStateInterfaces(std::vector&lt;hardware_interface::StateInterface&gt; &amp; interfaces);\nvirtual void appendCommandInterfaces(\nstd::vector&lt;hardware_interface::CommandInterface&gt; &amp; interfaces);\n\nvirtual Result setJointPositionLimit(double max_joint_limit, double min_joint_limit);\n\nprotected:\nMotorBase() = delete;\nResult getResult(int communication_result, uint8_t packet_error);\ntemplate &lt;typename T&gt;\nT radianToPosition(double radian) const\n{\nT value;\nradianToPosition(radian, value);\nreturn value;\n}\nuint16_t radianToPosition(double radian) const;\nvirtual double positionToRadian(const uint8_t position) const;\nvirtual double positionToRadian(const uint16_t position) const;\nvirtual double positionToRadian(const uint32_t position) const;\nvirtual void radianToPosition(double radian, uint8_t &amp; value) const;\nvirtual void radianToPosition(double radian, uint16_t &amp; value) const;\nvirtual void radianToPosition(double radian, uint32_t &amp; value) const;\nvoid rpmToVelocity(double rpm, double &amp; radian) const { radian = rpm / 60.0 * 2 * M_PI; }\nvirtual double valueToRpm(uint8_t value) const;\nvirtual double valueToRpm(uint16_t value) const;\nvirtual double valueToRpm(uint32_t value) const;\nvirtual double valueToTemperature(uint8_t value) const;\nvirtual double valueToTemperature(uint16_t value) const;\nvirtual double valueToTemperature(uint32_t value) const;\n\nstd::shared_ptr&lt;AddressTableBase&gt; address_table_;\nstd::shared_ptr&lt;dynamixel::PortHandler&gt; port_handler_;\nstd::shared_ptr&lt;dynamixel::PacketHandler&gt; packet_handler_;\ndouble joint_position_;\ndouble goal_position_;\ndouble joint_velocity_;\ndouble goal_velocity_;\ndouble present_temperature_;\n};\n}  //  namespace dynamixel_hardware_interface\n\n#endif  // DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/motors_8hpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp","text":"<p>Header for including all motor types.  More...</p>"},{"location":"doxygen/markdown/Files/motors_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Header for including all motor types. </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01</p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/motors_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_\n#define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_\n\n#include &lt;dynamixel_hardware_interface/motors/xw540_t260.hpp&gt;\n\n#endif  // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/util_8cpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp","text":"<p>implementation of the utility function.  More...</p>"},{"location":"doxygen/markdown/Files/util_8cpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/util_8cpp/#detailed-description","title":"Detailed Description","text":"<p>implementation of the utility function. </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01</p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/util_8cpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#include &lt;dynamixel_hardware_interface/util.hpp&gt;\n\nnamespace dynamixel_hardware_interface\n{\nconst std::string toString(const SupportedMotors motor)\n{\nswitch (motor) {\ncase SupportedMotors::XW540_T260:\nreturn \"XW540-T260\";\nbreak;\ncase SupportedMotors::INVALID:\nthrow std::runtime_error(\"invalid moter type\");\nbreak;\n}\nreturn \"\";\n}\n}  //  namespace dynamixel_hardware_interface\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/util_8hpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp","text":"<p>utility functions  More...</p>"},{"location":"doxygen/markdown/Files/util_8hpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/util_8hpp/#detailed-description","title":"Detailed Description","text":"<p>utility functions </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01</p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/util_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_\n#define DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_\n\n#include &lt;dynamixel_hardware_interface/constants.hpp&gt;\n\nnamespace dynamixel_hardware_interface\n{\nconst std::string toString(const SupportedMotors motor);\n}  //  namespace dynamixel_hardware_interface\n\n#endif  // DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/visiblity__control_8h/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h","text":"<p>Header file to control visibility.  More...</p>"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#defines","title":"Defines","text":"Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_LOCAL DYNAMIXEL_HARDWARE_INTERFACE_IMPORT DYNAMIXEL_HARDWARE_INTERFACE_EXPORT"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#detailed-description","title":"Detailed Description","text":"<p>Header file to control visibility. </p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01</p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#macro-documentation","title":"Macro Documentation","text":""},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_public_type","title":"define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE","text":"<pre><code>#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE\n</code></pre>"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_public","title":"define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC","text":"<pre><code>#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\n</code></pre>"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_local","title":"define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL","text":"<pre><code>#define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL\n</code></pre>"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_import","title":"define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT","text":"<pre><code>#define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT\n</code></pre>"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#define-dynamixel_hardware_interface_export","title":"define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT","text":"<pre><code>#define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\")))\n</code></pre>"},{"location":"doxygen/markdown/Files/visiblity__control_8h/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_\n#define DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_\n\n// This logic was borrowed (then namespaced) from the examples on the gcc wiki:\n//     https://gcc.gnu.org/wiki/Visibility\n\n#if defined _WIN32 || defined __CYGWIN__\n#ifdef __GNUC__\n#define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((dllexport))\n#define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __attribute__((dllimport))\n#else\n#define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __declspec(dllexport)\n#define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __declspec(dllimport)\n#endif\n#ifdef DYNAMIXEL_HARDWARE_INTERFACE_BUILDING_DLL\n#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_EXPORT\n#else\n#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_IMPORT\n#endif\n#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\n#define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL\n#else\n#define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\")))\n#define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT\n#if __GNUC__ &gt;= 4\n#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC __attribute__((visibility(\"default\")))\n#define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL __attribute__((visibility(\"hidden\")))\n#else\n#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC\n#define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL\n#endif\n#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE\n#endif\n\n#endif  // DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp","text":"<p>Class definition for the Dynamixel XW540-T260 motor.  More...</p>"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/#classes","title":"Classes","text":"Name class dynamixel_hardware_interface::motors::XW540_T260 class dynamixel_hardware_interface::address_tables::XW540_T260"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Class definition for the Dynamixel XW540-T260 motor. </p> <p>See: https://emanual.robotis.com/docs/en/dxl/x/xw540-t260/</p> <p>Author: Masaya Kataoka (ms.kataoka@gmail.com) </p> <p>Version: 0.1 </p> <p>Date: 2021-05-01 </p> <p>Copyright: Copyright (c) OUXT Polaris 2021 </p>"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp/#source-code","title":"Source code","text":"<pre><code>// Copyright (c) 2021 OUXT Polaris\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_\n#define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_\n\n#include &lt;cmath&gt;\n#include &lt;dynamixel_hardware_interface/address_table_base.hpp&gt;\n#include &lt;dynamixel_hardware_interface/motor_base.hpp&gt;\n#include &lt;limits&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nnamespace dynamixel_hardware_interface\n{\nnamespace address_tables\n{\nclass XW540_T260 : public AddressTableBase\n{\npublic:\nXW540_T260()\n: AddressTableBase(\nAddress(64, PacketByteSize::ONE_BYTE), Address(116, PacketByteSize::FOUR_BYTE), Address(),\nAddress(132, PacketByteSize::FOUR_BYTE), Address(128, PacketByteSize::FOUR_BYTE), Address(),\nAddress(), Address(146, PacketByteSize::ONE_BYTE), Address(48, PacketByteSize::FOUR_BYTE),\nAddress(52, PacketByteSize::FOUR_BYTE))\n{\n}\n};\n}  // namespace address_tables\n\nnamespace motors\n{\nclass XW540_T260 : public MotorBase\n{\npublic:\nexplicit XW540_T260(\nconst std::string joint_name, bool enable_dummy, int baudrate, uint8_t id,\ndouble max_joint_limit, double min_joint_limit,\nstd::shared_ptr&lt;dynamixel::PortHandler&gt; port_handler,\nstd::shared_ptr&lt;dynamixel::PacketHandler&gt; packet_handler)\n: MotorBase(\nSupportedMotors::XW540_T260, joint_name, enable_dummy, address_tables::XW540_T260(), baudrate,\nid, max_joint_limit, min_joint_limit, port_handler, packet_handler)\n{\n}\n\ndouble positionToRadian(const uint32_t position) const override\n{\nreturn static_cast&lt;double&gt;(position) / static_cast&lt;double&gt;(4096) * M_PI * 2;\n}\n\nvoid radianToPosition(double radian, uint32_t &amp; value) const override\n{\nvalue = static_cast&lt;uint32_t&gt;((radian / M_PI) * 4096);\n}\n\ndouble valueToRpm(uint32_t value) const override\n{\nreturn 2.29 * 2 * M_PI / 60 * static_cast&lt;double&gt;(value);\n}\n\ndouble valueToTemperature(uint8_t value) const override { return static_cast&lt;double&gt;(value); }\n};\n}  // namespace motors\n}  // namespace dynamixel_hardware_interface\n\n#endif  // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Modules/","title":"Modules","text":"<p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Namespaces/","title":"Namespaces","text":"<ul> <li>namespace dynamixel_hardware_interface <ul> <li>namespace address_tables </li> <li>namespace motors </li> </ul> </li> </ul> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/","title":"dynamixel_hardware_interface","text":""},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#namespaces","title":"Namespaces","text":"Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#classes","title":"Classes","text":"Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor. class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor. class dynamixel_hardware_interface::DynamixelDiagnosticController class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#types","title":"Types","text":"Name enum SupportedMotors { XW540_T260, INVALID }Enum class of the supported motor. enum PacketByteSize { TWO_BYTE, ONE_BYTE, INVALID, FOUR_BYTE } enum Operation { TORQUE_ENABLE, PRESENT_VOLTAGE, PRESENT_TEMPERATURE, PRESENT_SPEED, PRESENT_POSITION, PRESENT_LOAD, MOVING_SPEED, MIN_POSITION_LIMIT, MAX_POSITION_LIMIT, INVALID, GOAL_POSITION }Enum class of the commands. enum DiagnosticsType { TEMPERATURE, INVALID }"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#functions","title":"Functions","text":"Name const std::string toString(const SupportedMotors motor)"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#attributes","title":"Attributes","text":"Name constexpr double TO_VOLTAGE constexpr double TO_SPEED_REV_PER_MIN constexpr double TO_SPEED_RAD_PER_SEC constexpr double TO_SPEED_RAD_PER_MIN constexpr double TO_RADIANS constexpr double TO_LOAD_PERCENT constexpr double TO_DXL_POS constexpr double PULSE_RESOLUTION constexpr double PROTOCOL_VERSION constexpr double DXL_MAX_POSITION_DEGREES constexpr double DXL_MAX_POSITION constexpr int DXL_HOME_POSITION"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#types-documentation","title":"Types Documentation","text":""},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#enum-supportedmotors","title":"enum SupportedMotors","text":"Enumerator Value Description XW540_T260 Robotis xw540-t260 motor. INVALID Invalid motor type. <p>Enum class of the supported motor. </p>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#enum-packetbytesize","title":"enum PacketByteSize","text":"Enumerator Value Description TWO_BYTE ONE_BYTE INVALID FOUR_BYTE"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#enum-operation","title":"enum Operation","text":"Enumerator Value Description TORQUE_ENABLE PRESENT_VOLTAGE PRESENT_TEMPERATURE PRESENT_SPEED PRESENT_POSITION PRESENT_LOAD MOVING_SPEED MIN_POSITION_LIMIT MAX_POSITION_LIMIT INVALID GOAL_POSITION <p>Enum class of the commands. </p>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#enum-diagnosticstype","title":"enum DiagnosticsType","text":"Enumerator Value Description TEMPERATURE INVALID"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#functions-documentation","title":"Functions Documentation","text":""},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#function-tostring","title":"function toString","text":"<pre><code>const std::string toString(\nconst SupportedMotors motor\n)\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#attributes-documentation","title":"Attributes Documentation","text":""},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_voltage","title":"variable TO_VOLTAGE","text":"<pre><code>constexpr double TO_VOLTAGE = 0.1;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_speed_rev_per_min","title":"variable TO_SPEED_REV_PER_MIN","text":"<pre><code>constexpr double TO_SPEED_REV_PER_MIN = 0.111;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_speed_rad_per_sec","title":"variable TO_SPEED_RAD_PER_SEC","text":"<pre><code>constexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_speed_rad_per_min","title":"variable TO_SPEED_RAD_PER_MIN","text":"<pre><code>constexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_radians","title":"variable TO_RADIANS","text":"<pre><code>constexpr double TO_RADIANS = (DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION) * M_PI / 180.0;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_load_percent","title":"variable TO_LOAD_PERCENT","text":"<pre><code>constexpr double TO_LOAD_PERCENT = 0.1;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-to_dxl_pos","title":"variable TO_DXL_POS","text":"<pre><code>constexpr double TO_DXL_POS = 1.0 / TO_RADIANS;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-pulse_resolution","title":"variable PULSE_RESOLUTION","text":"<pre><code>constexpr double PULSE_RESOLUTION = 4096;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-protocol_version","title":"variable PROTOCOL_VERSION","text":"<pre><code>constexpr double PROTOCOL_VERSION = 2.0;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-dxl_max_position_degrees","title":"variable DXL_MAX_POSITION_DEGREES","text":"<pre><code>constexpr double DXL_MAX_POSITION_DEGREES = 300.0;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-dxl_max_position","title":"variable DXL_MAX_POSITION","text":"<pre><code>constexpr double DXL_MAX_POSITION = 1023.0;\n</code></pre>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface/#variable-dxl_home_position","title":"variable DXL_HOME_POSITION","text":"<pre><code>constexpr int DXL_HOME_POSITION = 0;\n</code></pre> <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1address__tables/","title":"dynamixel_hardware_interface::address_tables","text":""},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1address__tables/#classes","title":"Classes","text":"Name class dynamixel_hardware_interface::address_tables::XW540_T260 <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1motors/","title":"dynamixel_hardware_interface::motors","text":""},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1motors/#classes","title":"Classes","text":"Name class dynamixel_hardware_interface::motors::XW540_T260 <p>Updated on 10 June 2023 at 01:17:48 UTC</p>"},{"location":"doxygen/markdown/Pages/","title":"Pages","text":"<p>Updated on 10 June 2023 at 01:17:48 UTC</p>"}]}