{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Dynamixel Hardware Interface # ROS2 hardware interface for Dynamixel Motors. You can control Dynamixel motors like below. \u3044\u3048\u30fc\u3044 pic.twitter.com/PPQaBwk8uZ \u2014 \u7247\u5ca1\u5927\u54c9 (@hakuturu583) May 5, 2021 How to use # Write URDF/XACRO file for your robot # Example is here . You can use dynamixel hardware interface by writing URDF like below. <xacro:macro name= \"azimuth_thruster_control\" params= \"left_joint right_joint enable_dummy\" > <ros2_control name= \"azimuth_thruster_control\" type= \"system\" > <hardware> <plugin> dynamixel_hardware_interface/DynamixelHardwareInterface </plugin> <param name= \"port_name\" > /dev/ttyUSB0 </param> <param name= \"baudrate\" > 9600 </param> <param name= \"enable_dummy\" > ${enable_dummy} </param> </hardware> <joint name= \"${left_joint}\" > <param name= \"id\" > 1 </param> <param name= \"motor_type\" > XW540-T260 </param> <command_interface name= \"position\" /> <state_interface name= \"position\" /> </joint> <joint name= \"${right_joint}\" > <param name= \"id\" > 2 </param> <param name= \"motor_type\" > XW540-T260 </param> <command_interface name= \"position\" /> <state_interface name= \"position\" /> </joint> </ros2_control> </xacro:macro> Hardware parameters in URDF/XACRO # Name Type Description port_name string USB port name of the U2D2 baudrate int baudrate of the RS485 communication enable_dummy bool If true, this hardware interface runs without real dynamixel hardwre. Joint parameters in URDF/XACRO # Name Type Description id int id of the dynamixel motor attached to the joint motor_type string type of the dynamixel motor Connect motors to the U2D2 # Connect motors to the U2D2 . Power cable is also required. Setup motors # Use dynamixel wizard and configure motor ID and baudrate Support Status # State Interface # Motor Position Interface Velocity Interface Effort Interface Temperature Interface XW540-T260 \u2714 \u2714 \u2714 Command Interface # Motor Position Interface Velocity Interface Effort Interface XW540-T260 \u2714","title":"Home"},{"location":"index.html#dynamixel-hardware-interface","text":"ROS2 hardware interface for Dynamixel Motors. You can control Dynamixel motors like below. \u3044\u3048\u30fc\u3044 pic.twitter.com/PPQaBwk8uZ \u2014 \u7247\u5ca1\u5927\u54c9 (@hakuturu583) May 5, 2021","title":"Dynamixel Hardware Interface"},{"location":"index.html#how-to-use","text":"","title":"How to use"},{"location":"index.html#write-urdfxacro-file-for-your-robot","text":"Example is here . You can use dynamixel hardware interface by writing URDF like below. <xacro:macro name= \"azimuth_thruster_control\" params= \"left_joint right_joint enable_dummy\" > <ros2_control name= \"azimuth_thruster_control\" type= \"system\" > <hardware> <plugin> dynamixel_hardware_interface/DynamixelHardwareInterface </plugin> <param name= \"port_name\" > /dev/ttyUSB0 </param> <param name= \"baudrate\" > 9600 </param> <param name= \"enable_dummy\" > ${enable_dummy} </param> </hardware> <joint name= \"${left_joint}\" > <param name= \"id\" > 1 </param> <param name= \"motor_type\" > XW540-T260 </param> <command_interface name= \"position\" /> <state_interface name= \"position\" /> </joint> <joint name= \"${right_joint}\" > <param name= \"id\" > 2 </param> <param name= \"motor_type\" > XW540-T260 </param> <command_interface name= \"position\" /> <state_interface name= \"position\" /> </joint> </ros2_control> </xacro:macro>","title":"Write URDF/XACRO file for your robot"},{"location":"index.html#hardware-parameters-in-urdfxacro","text":"Name Type Description port_name string USB port name of the U2D2 baudrate int baudrate of the RS485 communication enable_dummy bool If true, this hardware interface runs without real dynamixel hardwre.","title":"Hardware parameters in URDF/XACRO"},{"location":"index.html#joint-parameters-in-urdfxacro","text":"Name Type Description id int id of the dynamixel motor attached to the joint motor_type string type of the dynamixel motor","title":"Joint parameters in URDF/XACRO"},{"location":"index.html#connect-motors-to-the-u2d2","text":"Connect motors to the U2D2 . Power cable is also required.","title":"Connect motors to the U2D2"},{"location":"index.html#setup-motors","text":"Use dynamixel wizard and configure motor ID and baudrate","title":"Setup motors"},{"location":"index.html#support-status","text":"","title":"Support Status"},{"location":"index.html#state-interface","text":"Motor Position Interface Velocity Interface Effort Interface Temperature Interface XW540-T260 \u2714 \u2714 \u2714","title":"State Interface"},{"location":"index.html#command-interface","text":"Motor Position Interface Velocity Interface Effort Interface XW540-T260 \u2714","title":"Command Interface"},{"location":"doxygen/markdown/Classes/index.html","text":"Classes # namespace dynamixel_hardware_interface class Address class AddressTableBase base class for address table class class DynamixelDiagnosticController class DynamixelHardwareInterface Hardware interface for the dynamixel motor. class MotorBase Base class for controlling dynamixel motor. struct Result Struct describes the command result. namespace address_tables class XW540_T260 namespace motors class XW540_T260 Updated on 20 June 2021 at 00:42:23 UTC","title":"Classes"},{"location":"doxygen/markdown/Classes/index.html#classes","text":"namespace dynamixel_hardware_interface class Address class AddressTableBase base class for address table class class DynamixelDiagnosticController class DynamixelHardwareInterface Hardware interface for the dynamixel motor. class MotorBase Base class for controlling dynamixel motor. struct Result Struct describes the command result. namespace address_tables class XW540_T260 namespace motors class XW540_T260 Updated on 20 June 2021 at 00:42:23 UTC","title":"Classes"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html","text":"dynamixel_hardware_interface::Address # Public Functions # Name bool exists () const Address (uint16_t address, PacketByteSize byte_size) Address () Public Attributes # Name const PacketByteSize byte_size const uint16_t address Public Functions Documentation # function exists # inline bool exists () const function Address # inline Address ( uint16_t address , PacketByteSize byte_size ) function Address # inline Address () Public Attributes Documentation # variable byte_size # const PacketByteSize byte_size ; variable address # const uint16_t address ; Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::Address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#dynamixel_hardware_interfaceaddress","text":"","title":"dynamixel_hardware_interface::Address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#public-functions","text":"Name bool exists () const Address (uint16_t address, PacketByteSize byte_size) Address ()","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#public-attributes","text":"Name const PacketByteSize byte_size const uint16_t address","title":"Public Attributes"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#function-exists","text":"inline bool exists () const","title":"function exists"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#function-address","text":"inline Address ( uint16_t address , PacketByteSize byte_size )","title":"function Address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#function-address_1","text":"inline Address ()","title":"function Address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#variable-byte_size","text":"const PacketByteSize byte_size ;","title":"variable byte_size"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1Address.html#variable-address","text":"const uint16_t address ; Updated on 20 June 2021 at 00:42:23 UTC","title":"variable address"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase.html","text":"dynamixel_hardware_interface::AddressTableBase # base class for address table class #include <address_table_base.hpp> Inherited by dynamixel_hardware_interface::address_tables::XW540_T260 Public Functions # Name Address getAddress (const Operation & operaiton) const Get address of which operation you want to execute. bool addressExists (const Operation & operation) const Check the address exists or not. AddressTableBase ( Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE) Construct a new Address Table Base object, each parameter describes the address of the operation. Public Functions Documentation # function getAddress # inline Address getAddress ( const Operation & operaiton ) const Get address of which operation you want to execute. Parameters : operaiton operation you want to execute Returns : boost::none operation is not supported uint16_t address of the operation you want to execute function addressExists # inline bool addressExists ( const Operation & operation ) const Check the address exists or not. Parameters : operation operation you want to execute Return : true address exist false address does not exist function AddressTableBase # inline explicit AddressTableBase ( Address ADDR_TORQUE_ENABLE , Address ADDR_GOAL_POSITION , Address ADDR_MOVING_SPEED , Address ADDR_PRESENT_POSITION , Address ADDR_PRESENT_SPEED , Address ADDR_PRESENT_LOAD , Address ADDR_PRESENT_VOLTAGE , Address ADDR_PRESENT_TEMPERATURE ) Construct a new Address Table Base object, each parameter describes the address of the operation. Parameters : ADDR_TORQUE_ENABLE If this value is boost::none, writing torque_enable command address exists. ADDR_GOAL_POSITION If this value is boost::none, writing goal_position command address exists. ADDR_MOVING_SPEED If this value is boost::none, writing moving_speed command address exists. ADDR_PRESENT_POSITION If this value is boost::none, reading present_position command address exists. ADDR_PRESENT_SPEED If this value is boost::none, reading present_speed command address exists. ADDR_PRESENT_LOAD If this value is boost::none, reading present_load command address exists. ADDR_PRESENT_VOLTAGE If this value is boost::none, reading present_voltage command address exists. ADDR_PRESENT_TEMPERATURE If this value is boost::none, reading present_temperature command address exists. Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::AddressTableBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase.html#dynamixel_hardware_interfaceaddresstablebase","text":"base class for address table class #include <address_table_base.hpp> Inherited by dynamixel_hardware_interface::address_tables::XW540_T260","title":"dynamixel_hardware_interface::AddressTableBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase.html#public-functions","text":"Name Address getAddress (const Operation & operaiton) const Get address of which operation you want to execute. bool addressExists (const Operation & operation) const Check the address exists or not. AddressTableBase ( Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE) Construct a new Address Table Base object, each parameter describes the address of the operation.","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase.html#function-getaddress","text":"inline Address getAddress ( const Operation & operaiton ) const Get address of which operation you want to execute. Parameters : operaiton operation you want to execute Returns : boost::none operation is not supported uint16_t address of the operation you want to execute","title":"function getAddress"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase.html#function-addressexists","text":"inline bool addressExists ( const Operation & operation ) const Check the address exists or not. Parameters : operation operation you want to execute Return : true address exist false address does not exist","title":"function addressExists"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1AddressTableBase.html#function-addresstablebase","text":"inline explicit AddressTableBase ( Address ADDR_TORQUE_ENABLE , Address ADDR_GOAL_POSITION , Address ADDR_MOVING_SPEED , Address ADDR_PRESENT_POSITION , Address ADDR_PRESENT_SPEED , Address ADDR_PRESENT_LOAD , Address ADDR_PRESENT_VOLTAGE , Address ADDR_PRESENT_TEMPERATURE ) Construct a new Address Table Base object, each parameter describes the address of the operation. Parameters : ADDR_TORQUE_ENABLE If this value is boost::none, writing torque_enable command address exists. ADDR_GOAL_POSITION If this value is boost::none, writing goal_position command address exists. ADDR_MOVING_SPEED If this value is boost::none, writing moving_speed command address exists. ADDR_PRESENT_POSITION If this value is boost::none, reading present_position command address exists. ADDR_PRESENT_SPEED If this value is boost::none, reading present_speed command address exists. ADDR_PRESENT_LOAD If this value is boost::none, reading present_load command address exists. ADDR_PRESENT_VOLTAGE If this value is boost::none, reading present_voltage command address exists. ADDR_PRESENT_TEMPERATURE If this value is boost::none, reading present_temperature command address exists. Updated on 20 June 2021 at 00:42:23 UTC","title":"function AddressTableBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html","text":"dynamixel_hardware_interface::DynamixelDiagnosticController # Inherits from ControllerInterface Public Functions # Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::return_type update () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::InterfaceConfiguration state_interface_configuration () const override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_deactivate (const rclcpp_lifecycle::State & ) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_configure (const rclcpp_lifecycle::State & ) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_activate (const rclcpp_lifecycle::State & ) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::return_type init (const std::string & controller_name) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::InterfaceConfiguration command_interface_configuration () const override Public Functions Documentation # function update # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: return_type update () override function state_interface_configuration # inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: InterfaceConfiguration state_interface_configuration () const override function on_deactivate # inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_deactivate ( const rclcpp_lifecycle :: State & ) override function on_configure # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_configure ( const rclcpp_lifecycle :: State & ) override function on_activate # inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_activate ( const rclcpp_lifecycle :: State & ) override function init # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: return_type init ( const std :: string & controller_name ) override function command_interface_configuration # inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: InterfaceConfiguration command_interface_configuration () const override Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::DynamixelDiagnosticController"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#dynamixel_hardware_interfacedynamixeldiagnosticcontroller","text":"Inherits from ControllerInterface","title":"dynamixel_hardware_interface::DynamixelDiagnosticController"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#public-functions","text":"Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::return_type update () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::InterfaceConfiguration state_interface_configuration () const override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_deactivate (const rclcpp_lifecycle::State & ) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_configure (const rclcpp_lifecycle::State & ) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn on_activate (const rclcpp_lifecycle::State & ) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::return_type init (const std::string & controller_name) override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface::InterfaceConfiguration command_interface_configuration () const override","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#function-update","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: return_type update () override","title":"function update"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#function-state_interface_configuration","text":"inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: InterfaceConfiguration state_interface_configuration () const override","title":"function state_interface_configuration"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#function-on_deactivate","text":"inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_deactivate ( const rclcpp_lifecycle :: State & ) override","title":"function on_deactivate"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#function-on_configure","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_configure ( const rclcpp_lifecycle :: State & ) override","title":"function on_configure"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#function-on_activate","text":"inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_activate ( const rclcpp_lifecycle :: State & ) override","title":"function on_activate"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#function-init","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: return_type init ( const std :: string & controller_name ) override","title":"function init"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelDiagnosticController.html#function-command_interface_configuration","text":"inline DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: InterfaceConfiguration command_interface_configuration () const override Updated on 20 June 2021 at 00:42:23 UTC","title":"function command_interface_configuration"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html","text":"dynamixel_hardware_interface::DynamixelHardwareInterface # Hardware interface for the dynamixel motor. #include <dynamixel_hardware_interface.hpp> Inherits from hardware_interface::BaseInterface< hardware_interface::SystemInterface > Public Functions # Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type write () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type stop () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type start () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type read () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector< hardware_interface::StateInterface > export_state_interfaces () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector< hardware_interface::CommandInterface > export_command_interfaces () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type configure (const hardware_interface::HardwareInfo & info) override Public Functions Documentation # function write # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type write () override function stop # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type stop () override function start # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type start () override function read # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type read () override function export_state_interfaces # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: StateInterface > export_state_interfaces () override function export_command_interfaces # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: CommandInterface > export_command_interfaces () override function configure # DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type configure ( const hardware_interface :: HardwareInfo & info ) override Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::DynamixelHardwareInterface"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#dynamixel_hardware_interfacedynamixelhardwareinterface","text":"Hardware interface for the dynamixel motor. #include <dynamixel_hardware_interface.hpp> Inherits from hardware_interface::BaseInterface< hardware_interface::SystemInterface >","title":"dynamixel_hardware_interface::DynamixelHardwareInterface"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#public-functions","text":"Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type write () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type stop () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type start () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type read () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector< hardware_interface::StateInterface > export_state_interfaces () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std::vector< hardware_interface::CommandInterface > export_command_interfaces () override DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface::return_type configure (const hardware_interface::HardwareInfo & info) override","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#function-write","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type write () override","title":"function write"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#function-stop","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type stop () override","title":"function stop"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#function-start","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type start () override","title":"function start"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#function-read","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type read () override","title":"function read"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#function-export_state_interfaces","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: StateInterface > export_state_interfaces () override","title":"function export_state_interfaces"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#function-export_command_interfaces","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: CommandInterface > export_command_interfaces () override","title":"function export_command_interfaces"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1DynamixelHardwareInterface.html#function-configure","text":"DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type configure ( const hardware_interface :: HardwareInfo & info ) override Updated on 20 June 2021 at 00:42:23 UTC","title":"function configure"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html","text":"dynamixel_hardware_interface::MotorBase # Base class for controlling dynamixel motor. #include <motor_base.hpp> Inherited by dynamixel_hardware_interface::motors::XW540_T260 Public Functions # Name ~MotorBase () Destroy the Motor Base object. virtual Result updatePresentTemperature () Execute update present temperature command to the motor. virtual Result updateJointVelocity () Execute update joint velocity command to the motor. virtual Result updateJointPosition () Execute update joint position command to the motor. virtual Result torqueEnable (bool enable) Execute torqu_enabled command to the motor. virtual Result setGoalPosition (double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. bool operationSupports (const Operation & operation) Check the operation is support in your motor. virtual std::vector< Operation > getSupportedOperations () Get list of supported Operations in your motor. virtual double getJointPosition () const Get current joint position of the motor. virtual double getGoalPosition () const Get current goal position of the motor. virtual Result configure () Configure dynamixel motor. virtual void appendStateInterfaces (std::vector< hardware_interface::StateInterface > & interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces (std::vector< hardware_interface::CommandInterface > & interfaces) Append command interface described in the URDF file. template \\<typename AddressTable > MotorBase (const SupportedMotors & motor_type, const std::string & joint_name, const bool enable_dummy, const AddressTable & table, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Construct a new Motor Base object. Protected Functions # Name virtual double valueToTemperature (uint8_t value) const virtual double valueToTemperature (uint16_t value) const virtual double valueToTemperature (uint32_t value) const virtual double valueToRpm (uint8_t value) const virtual double valueToRpm (uint16_t value) const virtual double valueToRpm (uint32_t value) const void rpmToVelocity (double rpm, double & radian) const template \\<typename T > T radianToPosition (double radian) const uint16_t radianToPosition (double radian) const virtual void radianToPosition (double radian, uint8_t & value) const virtual void radianToPosition (double radian, uint16_t & value) const virtual void radianToPosition (double radian, uint32_t & value) const virtual double positionToRadian (const uint8_t position) const virtual double positionToRadian (const uint16_t position) const virtual double positionToRadian (const uint32_t position) const Result getResult (int communication_result, uint8_t packet_error) MotorBase () Construct a new Motor Base object. Public Attributes # Name const SupportedMotors motor_type Describe the type of the motor. const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication. Protected Attributes # Name double present_temperature_ std::shared_ptr< dynamixel::PortHandler > port_handler_ std::shared_ptr< dynamixel::PacketHandler > packet_handler_ double joint_velocity_ double joint_position_ double goal_velocity_ double goal_position_ std::shared_ptr< AddressTableBase > address_table_ Public Functions Documentation # function ~MotorBase # ~ MotorBase () Destroy the Motor Base object. function updatePresentTemperature # virtual Result updatePresentTemperature () Execute update present temperature command to the motor. Return : Result function updateJointVelocity # virtual Result updateJointVelocity () Execute update joint velocity command to the motor. Return : Result function updateJointPosition # virtual Result updateJointPosition () Execute update joint position command to the motor. Return : Result result of the command. function torqueEnable # virtual Result torqueEnable ( bool enable ) Execute torqu_enabled command to the motor. Parameters : enable if true, enable torque. Return : Result result of the command. function setGoalPosition # virtual Result setGoalPosition ( double goal_position ) Execute goal_position command to the motor. Parameters : goal_position goal position angle in radian. Return : Result result of the command. function setCurrentGoalPosition # inline virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. Return : Result result of the command. function operationSupports # bool operationSupports ( const Operation & operation ) Check the operation is support in your motor. Parameters : operation Operation which you want to execute. Return : true Operation supports. false Operation does not support. function getSupportedOperations # virtual std :: vector < Operation > getSupportedOperations () Get list of supported Operations in your motor. Return : std::vector List of supported operations. function getJointPosition # inline virtual double getJointPosition () const Get current joint position of the motor. Return : double Current joint position of the motor in radian. function getGoalPosition # inline virtual double getGoalPosition () const Get current goal position of the motor. Return : double Current goal position of the motor in radian. function configure # virtual Result configure () Configure dynamixel motor. Return : Result result of the configuration. function appendStateInterfaces # virtual void appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ) Append state interface described in the URDF file. Parameters : interfaces List of state interface. function appendCommandInterfaces # virtual void appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ) Append command interface described in the URDF file. Parameters : interfaces List of command interface. function MotorBase # template < typename AddressTable > inline MotorBase ( const SupportedMotors & motor_type , const std :: string & joint_name , const bool enable_dummy , const AddressTable & table , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) Construct a new Motor Base object. Parameters : motor_type Type of the motor. joint_name Name of the joint which the motor is attaching to. enable_dummy If true, you can communicate with virtual dinamixel motor. table address table of the motor. baudrate Baudrate of the serial communication. id Id of the dynamixel motor. port_handler Port handler class of the dynamixel sdk. packet_handler Packet handler class of the dynamixel sdk Template Parameters : AddressTable address table type of the motor. Protected Functions Documentation # function valueToTemperature # virtual double valueToTemperature ( uint8_t value ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::valueToTemperature function valueToTemperature # virtual double valueToTemperature ( uint16_t value ) const function valueToTemperature # virtual double valueToTemperature ( uint32_t value ) const function valueToRpm # virtual double valueToRpm ( uint8_t value ) const function valueToRpm # virtual double valueToRpm ( uint16_t value ) const function valueToRpm # virtual double valueToRpm ( uint32_t value ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::valueToRpm function rpmToVelocity # inline void rpmToVelocity ( double rpm , double & radian ) const function radianToPosition # template < typename T > inline T radianToPosition ( double radian ) const function radianToPosition # uint16_t radianToPosition ( double radian ) const function radianToPosition # virtual void radianToPosition ( double radian , uint8_t & value ) const function radianToPosition # virtual void radianToPosition ( double radian , uint16_t & value ) const function radianToPosition # virtual void radianToPosition ( double radian , uint32_t & value ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::radianToPosition function positionToRadian # virtual double positionToRadian ( const uint8_t position ) const function positionToRadian # virtual double positionToRadian ( const uint16_t position ) const function positionToRadian # virtual double positionToRadian ( const uint32_t position ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::positionToRadian function getResult # Result getResult ( int communication_result , uint8_t packet_error ) function MotorBase # MotorBase () Construct a new Motor Base object. Public Attributes Documentation # variable motor_type # const SupportedMotors motor_type ; Describe the type of the motor. variable joint_name # const std :: string joint_name ; Name of the joint which the motor is attaching to. variable id # const uint8_t id ; Id of the dynamixel motor. variable enable_dummy # const bool enable_dummy ; If true, you can communicate with virtual dinamixel motor. variable baudrate # const int baudrate ; Baudrate of the serial communication. Protected Attributes Documentation # variable present_temperature_ # double present_temperature_ ; variable port_handler_ # std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; variable packet_handler_ # std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; variable joint_velocity_ # double joint_velocity_ ; variable joint_position_ # double joint_position_ ; variable goal_velocity_ # double goal_velocity_ ; variable goal_position_ # double goal_position_ ; variable address_table_ # std :: shared_ptr < AddressTableBase > address_table_ ; Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#dynamixel_hardware_interfacemotorbase","text":"Base class for controlling dynamixel motor. #include <motor_base.hpp> Inherited by dynamixel_hardware_interface::motors::XW540_T260","title":"dynamixel_hardware_interface::MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#public-functions","text":"Name ~MotorBase () Destroy the Motor Base object. virtual Result updatePresentTemperature () Execute update present temperature command to the motor. virtual Result updateJointVelocity () Execute update joint velocity command to the motor. virtual Result updateJointPosition () Execute update joint position command to the motor. virtual Result torqueEnable (bool enable) Execute torqu_enabled command to the motor. virtual Result setGoalPosition (double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. bool operationSupports (const Operation & operation) Check the operation is support in your motor. virtual std::vector< Operation > getSupportedOperations () Get list of supported Operations in your motor. virtual double getJointPosition () const Get current joint position of the motor. virtual double getGoalPosition () const Get current goal position of the motor. virtual Result configure () Configure dynamixel motor. virtual void appendStateInterfaces (std::vector< hardware_interface::StateInterface > & interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces (std::vector< hardware_interface::CommandInterface > & interfaces) Append command interface described in the URDF file. template \\<typename AddressTable > MotorBase (const SupportedMotors & motor_type, const std::string & joint_name, const bool enable_dummy, const AddressTable & table, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Construct a new Motor Base object.","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#protected-functions","text":"Name virtual double valueToTemperature (uint8_t value) const virtual double valueToTemperature (uint16_t value) const virtual double valueToTemperature (uint32_t value) const virtual double valueToRpm (uint8_t value) const virtual double valueToRpm (uint16_t value) const virtual double valueToRpm (uint32_t value) const void rpmToVelocity (double rpm, double & radian) const template \\<typename T > T radianToPosition (double radian) const uint16_t radianToPosition (double radian) const virtual void radianToPosition (double radian, uint8_t & value) const virtual void radianToPosition (double radian, uint16_t & value) const virtual void radianToPosition (double radian, uint32_t & value) const virtual double positionToRadian (const uint8_t position) const virtual double positionToRadian (const uint16_t position) const virtual double positionToRadian (const uint32_t position) const Result getResult (int communication_result, uint8_t packet_error) MotorBase () Construct a new Motor Base object.","title":"Protected Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#public-attributes","text":"Name const SupportedMotors motor_type Describe the type of the motor. const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication.","title":"Public Attributes"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#protected-attributes","text":"Name double present_temperature_ std::shared_ptr< dynamixel::PortHandler > port_handler_ std::shared_ptr< dynamixel::PacketHandler > packet_handler_ double joint_velocity_ double joint_position_ double goal_velocity_ double goal_position_ std::shared_ptr< AddressTableBase > address_table_","title":"Protected Attributes"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-motorbase","text":"~ MotorBase () Destroy the Motor Base object.","title":"function ~MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-updatepresenttemperature","text":"virtual Result updatePresentTemperature () Execute update present temperature command to the motor. Return : Result","title":"function updatePresentTemperature"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-updatejointvelocity","text":"virtual Result updateJointVelocity () Execute update joint velocity command to the motor. Return : Result","title":"function updateJointVelocity"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-updatejointposition","text":"virtual Result updateJointPosition () Execute update joint position command to the motor. Return : Result result of the command.","title":"function updateJointPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-torqueenable","text":"virtual Result torqueEnable ( bool enable ) Execute torqu_enabled command to the motor. Parameters : enable if true, enable torque. Return : Result result of the command.","title":"function torqueEnable"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-setgoalposition","text":"virtual Result setGoalPosition ( double goal_position ) Execute goal_position command to the motor. Parameters : goal_position goal position angle in radian. Return : Result result of the command.","title":"function setGoalPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-setcurrentgoalposition","text":"inline virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. Return : Result result of the command.","title":"function setCurrentGoalPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-operationsupports","text":"bool operationSupports ( const Operation & operation ) Check the operation is support in your motor. Parameters : operation Operation which you want to execute. Return : true Operation supports. false Operation does not support.","title":"function operationSupports"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-getsupportedoperations","text":"virtual std :: vector < Operation > getSupportedOperations () Get list of supported Operations in your motor. Return : std::vector List of supported operations.","title":"function getSupportedOperations"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-getjointposition","text":"inline virtual double getJointPosition () const Get current joint position of the motor. Return : double Current joint position of the motor in radian.","title":"function getJointPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-getgoalposition","text":"inline virtual double getGoalPosition () const Get current goal position of the motor. Return : double Current goal position of the motor in radian.","title":"function getGoalPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-configure","text":"virtual Result configure () Configure dynamixel motor. Return : Result result of the configuration.","title":"function configure"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-appendstateinterfaces","text":"virtual void appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ) Append state interface described in the URDF file. Parameters : interfaces List of state interface.","title":"function appendStateInterfaces"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-appendcommandinterfaces","text":"virtual void appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ) Append command interface described in the URDF file. Parameters : interfaces List of command interface.","title":"function appendCommandInterfaces"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-motorbase_1","text":"template < typename AddressTable > inline MotorBase ( const SupportedMotors & motor_type , const std :: string & joint_name , const bool enable_dummy , const AddressTable & table , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) Construct a new Motor Base object. Parameters : motor_type Type of the motor. joint_name Name of the joint which the motor is attaching to. enable_dummy If true, you can communicate with virtual dinamixel motor. table address table of the motor. baudrate Baudrate of the serial communication. id Id of the dynamixel motor. port_handler Port handler class of the dynamixel sdk. packet_handler Packet handler class of the dynamixel sdk Template Parameters : AddressTable address table type of the motor.","title":"function MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-valuetotemperature","text":"virtual double valueToTemperature ( uint8_t value ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::valueToTemperature","title":"function valueToTemperature"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-valuetotemperature_1","text":"virtual double valueToTemperature ( uint16_t value ) const","title":"function valueToTemperature"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-valuetotemperature_2","text":"virtual double valueToTemperature ( uint32_t value ) const","title":"function valueToTemperature"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-valuetorpm","text":"virtual double valueToRpm ( uint8_t value ) const","title":"function valueToRpm"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-valuetorpm_1","text":"virtual double valueToRpm ( uint16_t value ) const","title":"function valueToRpm"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-valuetorpm_2","text":"virtual double valueToRpm ( uint32_t value ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::valueToRpm","title":"function valueToRpm"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-rpmtovelocity","text":"inline void rpmToVelocity ( double rpm , double & radian ) const","title":"function rpmToVelocity"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-radiantoposition","text":"template < typename T > inline T radianToPosition ( double radian ) const","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-radiantoposition_1","text":"uint16_t radianToPosition ( double radian ) const","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-radiantoposition_2","text":"virtual void radianToPosition ( double radian , uint8_t & value ) const","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-radiantoposition_3","text":"virtual void radianToPosition ( double radian , uint16_t & value ) const","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-radiantoposition_4","text":"virtual void radianToPosition ( double radian , uint32_t & value ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::radianToPosition","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-positiontoradian","text":"virtual double positionToRadian ( const uint8_t position ) const","title":"function positionToRadian"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-positiontoradian_1","text":"virtual double positionToRadian ( const uint16_t position ) const","title":"function positionToRadian"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-positiontoradian_2","text":"virtual double positionToRadian ( const uint32_t position ) const Reimplemented by : dynamixel_hardware_interface::motors::XW540_T260::positionToRadian","title":"function positionToRadian"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-getresult","text":"Result getResult ( int communication_result , uint8_t packet_error )","title":"function getResult"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#function-motorbase_2","text":"MotorBase () Construct a new Motor Base object.","title":"function MotorBase"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-motor_type","text":"const SupportedMotors motor_type ; Describe the type of the motor.","title":"variable motor_type"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-joint_name","text":"const std :: string joint_name ; Name of the joint which the motor is attaching to.","title":"variable joint_name"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-id","text":"const uint8_t id ; Id of the dynamixel motor.","title":"variable id"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-enable_dummy","text":"const bool enable_dummy ; If true, you can communicate with virtual dinamixel motor.","title":"variable enable_dummy"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-baudrate","text":"const int baudrate ; Baudrate of the serial communication.","title":"variable baudrate"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-present_temperature_","text":"double present_temperature_ ;","title":"variable present_temperature_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-port_handler_","text":"std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ;","title":"variable port_handler_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-packet_handler_","text":"std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ;","title":"variable packet_handler_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-joint_velocity_","text":"double joint_velocity_ ;","title":"variable joint_velocity_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-joint_position_","text":"double joint_position_ ;","title":"variable joint_position_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-goal_velocity_","text":"double goal_velocity_ ;","title":"variable goal_velocity_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-goal_position_","text":"double goal_position_ ;","title":"variable goal_position_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1MotorBase.html#variable-address_table_","text":"std :: shared_ptr < AddressTableBase > address_table_ ; Updated on 20 June 2021 at 00:42:23 UTC","title":"variable address_table_"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260.html","text":"dynamixel_hardware_interface::address_tables::XW540_T260 # Inherits from dynamixel_hardware_interface::AddressTableBase Public Functions # Name XW540_T260 () Additional inherited members # Public Functions inherited from dynamixel_hardware_interface::AddressTableBase Name Address getAddress (const Operation & operaiton) const Get address of which operation you want to execute. bool addressExists (const Operation & operation) const Check the address exists or not. AddressTableBase ( Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE) Construct a new Address Table Base object, each parameter describes the address of the operation. Public Functions Documentation # function XW540_T260 # inline XW540_T260 () Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::address_tables::XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260.html#dynamixel_hardware_interfaceaddress_tablesxw540_t260","text":"Inherits from dynamixel_hardware_interface::AddressTableBase","title":"dynamixel_hardware_interface::address_tables::XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260.html#public-functions","text":"Name XW540_T260 ()","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260.html#additional-inherited-members","text":"Public Functions inherited from dynamixel_hardware_interface::AddressTableBase Name Address getAddress (const Operation & operaiton) const Get address of which operation you want to execute. bool addressExists (const Operation & operation) const Check the address exists or not. AddressTableBase ( Address ADDR_TORQUE_ENABLE, Address ADDR_GOAL_POSITION, Address ADDR_MOVING_SPEED, Address ADDR_PRESENT_POSITION, Address ADDR_PRESENT_SPEED, Address ADDR_PRESENT_LOAD, Address ADDR_PRESENT_VOLTAGE, Address ADDR_PRESENT_TEMPERATURE) Construct a new Address Table Base object, each parameter describes the address of the operation.","title":"Additional inherited members"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1address__tables_1_1XW540__T260.html#function-xw540_t260","text":"inline XW540_T260 () Updated on 20 June 2021 at 00:42:23 UTC","title":"function XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html","text":"dynamixel_hardware_interface::motors::XW540_T260 # Inherits from dynamixel_hardware_interface::MotorBase Public Functions # Name virtual double valueToTemperature (uint8_t value) const override virtual double valueToRpm (uint32_t value) const override virtual void radianToPosition (double radian, uint32_t & value) const override virtual double positionToRadian (const uint32_t position) const override XW540_T260 (const std::string joint_name, bool enable_dummy, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Additional inherited members # Public Functions inherited from dynamixel_hardware_interface::MotorBase Name ~MotorBase () Destroy the Motor Base object. virtual Result updatePresentTemperature () Execute update present temperature command to the motor. virtual Result updateJointVelocity () Execute update joint velocity command to the motor. virtual Result updateJointPosition () Execute update joint position command to the motor. virtual Result torqueEnable (bool enable) Execute torqu_enabled command to the motor. virtual Result setGoalPosition (double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. bool operationSupports (const Operation & operation) Check the operation is support in your motor. virtual std::vector< Operation > getSupportedOperations () Get list of supported Operations in your motor. virtual double getJointPosition () const Get current joint position of the motor. virtual double getGoalPosition () const Get current goal position of the motor. virtual Result configure () Configure dynamixel motor. virtual void appendStateInterfaces (std::vector< hardware_interface::StateInterface > & interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces (std::vector< hardware_interface::CommandInterface > & interfaces) Append command interface described in the URDF file. MotorBase (const SupportedMotors & motor_type, const std::string & joint_name, const bool enable_dummy, const AddressTable & table, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Construct a new Motor Base object. Protected Functions inherited from dynamixel_hardware_interface::MotorBase Name void rpmToVelocity (double rpm, double & radian) const Result getResult (int communication_result, uint8_t packet_error) MotorBase () Construct a new Motor Base object. Public Attributes inherited from dynamixel_hardware_interface::MotorBase Name const SupportedMotors motor_type Describe the type of the motor. const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication. Protected Attributes inherited from dynamixel_hardware_interface::MotorBase Name double present_temperature_ std::shared_ptr< dynamixel::PortHandler > port_handler_ std::shared_ptr< dynamixel::PacketHandler > packet_handler_ double joint_velocity_ double joint_position_ double goal_velocity_ double goal_position_ std::shared_ptr< AddressTableBase > address_table_ Public Functions Documentation # function valueToTemperature # inline virtual double valueToTemperature ( uint8_t value ) const override Reimplements : dynamixel_hardware_interface::MotorBase::valueToTemperature function valueToRpm # inline virtual double valueToRpm ( uint32_t value ) const override Reimplements : dynamixel_hardware_interface::MotorBase::valueToRpm function radianToPosition # inline virtual void radianToPosition ( double radian , uint32_t & value ) const override Reimplements : dynamixel_hardware_interface::MotorBase::radianToPosition function positionToRadian # inline virtual double positionToRadian ( const uint32_t position ) const override Reimplements : dynamixel_hardware_interface::MotorBase::positionToRadian function XW540_T260 # inline explicit XW540_T260 ( const std :: string joint_name , bool enable_dummy , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::motors::XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html#dynamixel_hardware_interfacemotorsxw540_t260","text":"Inherits from dynamixel_hardware_interface::MotorBase","title":"dynamixel_hardware_interface::motors::XW540_T260"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html#public-functions","text":"Name virtual double valueToTemperature (uint8_t value) const override virtual double valueToRpm (uint32_t value) const override virtual void radianToPosition (double radian, uint32_t & value) const override virtual double positionToRadian (const uint32_t position) const override XW540_T260 (const std::string joint_name, bool enable_dummy, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler)","title":"Public Functions"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html#additional-inherited-members","text":"Public Functions inherited from dynamixel_hardware_interface::MotorBase Name ~MotorBase () Destroy the Motor Base object. virtual Result updatePresentTemperature () Execute update present temperature command to the motor. virtual Result updateJointVelocity () Execute update joint velocity command to the motor. virtual Result updateJointPosition () Execute update joint position command to the motor. virtual Result torqueEnable (bool enable) Execute torqu_enabled command to the motor. virtual Result setGoalPosition (double goal_position) Execute goal_position command to the motor. virtual Result setCurrentGoalPosition () Execute goal_position command to the motor without update current goal position. bool operationSupports (const Operation & operation) Check the operation is support in your motor. virtual std::vector< Operation > getSupportedOperations () Get list of supported Operations in your motor. virtual double getJointPosition () const Get current joint position of the motor. virtual double getGoalPosition () const Get current goal position of the motor. virtual Result configure () Configure dynamixel motor. virtual void appendStateInterfaces (std::vector< hardware_interface::StateInterface > & interfaces) Append state interface described in the URDF file. virtual void appendCommandInterfaces (std::vector< hardware_interface::CommandInterface > & interfaces) Append command interface described in the URDF file. MotorBase (const SupportedMotors & motor_type, const std::string & joint_name, const bool enable_dummy, const AddressTable & table, int baudrate, uint8_t id, std::shared_ptr< dynamixel::PortHandler > port_handler, std::shared_ptr< dynamixel::PacketHandler > packet_handler) Construct a new Motor Base object. Protected Functions inherited from dynamixel_hardware_interface::MotorBase Name void rpmToVelocity (double rpm, double & radian) const Result getResult (int communication_result, uint8_t packet_error) MotorBase () Construct a new Motor Base object. Public Attributes inherited from dynamixel_hardware_interface::MotorBase Name const SupportedMotors motor_type Describe the type of the motor. const std::string joint_name Name of the joint which the motor is attaching to. const uint8_t id Id of the dynamixel motor. const bool enable_dummy If true, you can communicate with virtual dinamixel motor. const int baudrate Baudrate of the serial communication. Protected Attributes inherited from dynamixel_hardware_interface::MotorBase Name double present_temperature_ std::shared_ptr< dynamixel::PortHandler > port_handler_ std::shared_ptr< dynamixel::PacketHandler > packet_handler_ double joint_velocity_ double joint_position_ double goal_velocity_ double goal_position_ std::shared_ptr< AddressTableBase > address_table_","title":"Additional inherited members"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html#function-valuetotemperature","text":"inline virtual double valueToTemperature ( uint8_t value ) const override Reimplements : dynamixel_hardware_interface::MotorBase::valueToTemperature","title":"function valueToTemperature"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html#function-valuetorpm","text":"inline virtual double valueToRpm ( uint32_t value ) const override Reimplements : dynamixel_hardware_interface::MotorBase::valueToRpm","title":"function valueToRpm"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html#function-radiantoposition","text":"inline virtual void radianToPosition ( double radian , uint32_t & value ) const override Reimplements : dynamixel_hardware_interface::MotorBase::radianToPosition","title":"function radianToPosition"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html#function-positiontoradian","text":"inline virtual double positionToRadian ( const uint32_t position ) const override Reimplements : dynamixel_hardware_interface::MotorBase::positionToRadian","title":"function positionToRadian"},{"location":"doxygen/markdown/Classes/classdynamixel__hardware__interface_1_1motors_1_1XW540__T260.html#function-xw540_t260","text":"inline explicit XW540_T260 ( const std :: string joint_name , bool enable_dummy , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) Updated on 20 June 2021 at 00:42:23 UTC","title":"function XW540_T260"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result.html","text":"dynamixel_hardware_interface::Result # Struct describes the command result. #include <motor_base.hpp> Public Functions # Name Result (const std::string & description, bool success) Construct a new Result object. Public Attributes # Name const bool success If true, command execute successfully. const std::string description Description of the result. Public Functions Documentation # function Result # inline Result ( const std :: string & description , bool success ) Construct a new Result object. Parameters : description Description of the result. success If true, command execute successfully. Public Attributes Documentation # variable success # const bool success ; If true, command execute successfully. variable description # const std :: string description ; Description of the result. Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::Result"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result.html#dynamixel_hardware_interfaceresult","text":"Struct describes the command result. #include <motor_base.hpp>","title":"dynamixel_hardware_interface::Result"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result.html#public-functions","text":"Name Result (const std::string & description, bool success) Construct a new Result object.","title":"Public Functions"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result.html#public-attributes","text":"Name const bool success If true, command execute successfully. const std::string description Description of the result.","title":"Public Attributes"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result.html#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result.html#function-result","text":"inline Result ( const std :: string & description , bool success ) Construct a new Result object. Parameters : description Description of the result. success If true, command execute successfully.","title":"function Result"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result.html#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result.html#variable-success","text":"const bool success ; If true, command execute successfully.","title":"variable success"},{"location":"doxygen/markdown/Classes/structdynamixel__hardware__interface_1_1Result.html#variable-description","text":"const std :: string description ; Description of the result. Updated on 20 June 2021 at 00:42:23 UTC","title":"variable description"},{"location":"doxygen/markdown/Examples/index.html","text":"Examples # Updated on 20 June 2021 at 00:42:23 UTC","title":"Examples"},{"location":"doxygen/markdown/Examples/index.html#examples","text":"Updated on 20 June 2021 at 00:42:23 UTC","title":"Examples"},{"location":"doxygen/markdown/Files/index.html","text":"Files # dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dymanixel_diagnostic_controller.hpp file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp definition of the dynamixal diagnostic controller class file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. Updated on 20 June 2021 at 00:42:23 UTC","title":"Files"},{"location":"doxygen/markdown/Files/index.html#files","text":"dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dymanixel_diagnostic_controller.hpp file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. dir /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp definition of the dynamixal diagnostic controller class file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. file /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. Updated on 20 June 2021 at 00:42:23 UTC","title":"Files"},{"location":"doxygen/markdown/Files/address__table__base_8hpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp # Base class for the address tabele. More... Namespaces # Name dynamixel_hardware_interface Classes # Name class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address Detailed Description # Base class for the address tabele. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ #include <boost/optional.hpp> #include <cmath> #include <dynamixel_hardware_interface/constants.hpp> #include <limits> namespace dynamixel_hardware_interface { class Address { public : Address ( uint16_t address , PacketByteSize byte_size ) : address ( address ), byte_size ( byte_size ) {} Address () : address ( 0 ), byte_size ( PacketByteSize :: INVALID ) {} const uint16_t address ; const PacketByteSize byte_size ; bool exists () const { if ( byte_size == PacketByteSize :: INVALID ) { return false ; } return true ; } }; class AddressTableBase { public : explicit AddressTableBase ( Address ADDR_TORQUE_ENABLE , Address ADDR_GOAL_POSITION , Address ADDR_MOVING_SPEED , Address ADDR_PRESENT_POSITION , Address ADDR_PRESENT_SPEED , Address ADDR_PRESENT_LOAD , Address ADDR_PRESENT_VOLTAGE , Address ADDR_PRESENT_TEMPERATURE ) : ADDR_TORQUE_ENABLE ( ADDR_TORQUE_ENABLE ), ADDR_GOAL_POSITION ( ADDR_GOAL_POSITION ), ADDR_MOVING_SPEED ( ADDR_MOVING_SPEED ), ADDR_PRESENT_POSITION ( ADDR_PRESENT_POSITION ), ADDR_PRESENT_SPEED ( ADDR_PRESENT_SPEED ), ADDR_PRESENT_LOAD ( ADDR_PRESENT_LOAD ), ADDR_PRESENT_VOLTAGE ( ADDR_PRESENT_VOLTAGE ), ADDR_PRESENT_TEMPERATURE ( ADDR_PRESENT_TEMPERATURE ) { } Address getAddress ( const Operation & operaiton ) const { switch ( operaiton ) { case Operation :: TORQUE_ENABLE : return ADDR_TORQUE_ENABLE ; case Operation :: GOAL_POSITION : return ADDR_GOAL_POSITION ; case Operation :: MOVING_SPEED : return ADDR_MOVING_SPEED ; case Operation :: PRESENT_POSITION : return ADDR_PRESENT_POSITION ; case Operation :: PRESENT_SPEED : return ADDR_PRESENT_SPEED ; case Operation :: PRESENT_LOAD : return ADDR_PRESENT_LOAD ; case Operation :: PRESENT_VOLTAGE : return ADDR_PRESENT_VOLTAGE ; case Operation :: PRESENT_TEMPERATURE : return ADDR_PRESENT_TEMPERATURE ; default : return Address (); } } bool addressExists ( const Operation & operation ) const { return getAddress ( operation ). exists (); } private : AddressTableBase () = delete ; const Address ADDR_TORQUE_ENABLE ; const Address ADDR_GOAL_POSITION ; const Address ADDR_MOVING_SPEED ; const Address ADDR_PRESENT_POSITION ; const Address ADDR_PRESENT_SPEED ; const Address ADDR_PRESENT_LOAD ; const Address ADDR_PRESENT_VOLTAGE ; const Address ADDR_PRESENT_TEMPERATURE ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp"},{"location":"doxygen/markdown/Files/address__table__base_8hpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfaceaddress_table_basehpp","text":"Base class for the address tabele. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp"},{"location":"doxygen/markdown/Files/address__table__base_8hpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/address__table__base_8hpp.html#classes","text":"Name class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address","title":"Classes"},{"location":"doxygen/markdown/Files/address__table__base_8hpp.html#detailed-description","text":"Base class for the address tabele. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/address__table__base_8hpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ #include <boost/optional.hpp> #include <cmath> #include <dynamixel_hardware_interface/constants.hpp> #include <limits> namespace dynamixel_hardware_interface { class Address { public : Address ( uint16_t address , PacketByteSize byte_size ) : address ( address ), byte_size ( byte_size ) {} Address () : address ( 0 ), byte_size ( PacketByteSize :: INVALID ) {} const uint16_t address ; const PacketByteSize byte_size ; bool exists () const { if ( byte_size == PacketByteSize :: INVALID ) { return false ; } return true ; } }; class AddressTableBase { public : explicit AddressTableBase ( Address ADDR_TORQUE_ENABLE , Address ADDR_GOAL_POSITION , Address ADDR_MOVING_SPEED , Address ADDR_PRESENT_POSITION , Address ADDR_PRESENT_SPEED , Address ADDR_PRESENT_LOAD , Address ADDR_PRESENT_VOLTAGE , Address ADDR_PRESENT_TEMPERATURE ) : ADDR_TORQUE_ENABLE ( ADDR_TORQUE_ENABLE ), ADDR_GOAL_POSITION ( ADDR_GOAL_POSITION ), ADDR_MOVING_SPEED ( ADDR_MOVING_SPEED ), ADDR_PRESENT_POSITION ( ADDR_PRESENT_POSITION ), ADDR_PRESENT_SPEED ( ADDR_PRESENT_SPEED ), ADDR_PRESENT_LOAD ( ADDR_PRESENT_LOAD ), ADDR_PRESENT_VOLTAGE ( ADDR_PRESENT_VOLTAGE ), ADDR_PRESENT_TEMPERATURE ( ADDR_PRESENT_TEMPERATURE ) { } Address getAddress ( const Operation & operaiton ) const { switch ( operaiton ) { case Operation :: TORQUE_ENABLE : return ADDR_TORQUE_ENABLE ; case Operation :: GOAL_POSITION : return ADDR_GOAL_POSITION ; case Operation :: MOVING_SPEED : return ADDR_MOVING_SPEED ; case Operation :: PRESENT_POSITION : return ADDR_PRESENT_POSITION ; case Operation :: PRESENT_SPEED : return ADDR_PRESENT_SPEED ; case Operation :: PRESENT_LOAD : return ADDR_PRESENT_LOAD ; case Operation :: PRESENT_VOLTAGE : return ADDR_PRESENT_VOLTAGE ; case Operation :: PRESENT_TEMPERATURE : return ADDR_PRESENT_TEMPERATURE ; default : return Address (); } } bool addressExists ( const Operation & operation ) const { return getAddress ( operation ). exists (); } private : AddressTableBase () = delete ; const Address ADDR_TORQUE_ENABLE ; const Address ADDR_GOAL_POSITION ; const Address ADDR_MOVING_SPEED ; const Address ADDR_PRESENT_POSITION ; const Address ADDR_PRESENT_SPEED ; const Address ADDR_PRESENT_LOAD ; const Address ADDR_PRESENT_VOLTAGE ; const Address ADDR_PRESENT_TEMPERATURE ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__ADDRESS_TABLE_BASE_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/constants_8hpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp # Header for defineing constant values. More... Namespaces # Name dynamixel_hardware_interface Defines # Name GENERATE_ENUM_ITERATOR (T, LAST_VALUE) Detailed Description # Header for defineing constant values. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Macro Documentation # define GENERATE_ENUM_ITERATOR # #define GENERATE_ENUM_ITERATOR( T , LAST_VALUE ) inline T operator ++ ( T & x ) { return x = ( T )( std :: underlying_type < T >:: type ( x ) + 1 ); } \\ inline T operator * ( T c ) { return c ; } \\ inline T begin ( T ) { return static_cast < T > ( 0 ); } \\ inline T end ( T ) \\ { \\ T l = T :: LAST_VALUE ; \\ return l ; \\ } Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ #include <cmath> #include <cstdint> #include <stdexcept> #include <string> namespace dynamixel_hardware_interface { constexpr double PROTOCOL_VERSION = 2.0 ; constexpr int DXL_HOME_POSITION = 0 ; // value range:0 ~ 1023 constexpr double DXL_MAX_POSITION = 1023.0 ; constexpr double DXL_MAX_POSITION_DEGREES = 300.0 ; constexpr double TO_RADIANS = ( DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION ) * M_PI / 180.0 ; constexpr double TO_DXL_POS = 1.0 / TO_RADIANS ; constexpr double TO_SPEED_REV_PER_MIN = 0.111 ; constexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI ; constexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0 ; constexpr double TO_LOAD_PERCENT = 0.1 ; constexpr double TO_VOLTAGE = 0.1 ; constexpr double PULSE_RESOLUTION = 4096 ; #define GENERATE_ENUM_ITERATOR(T, LAST_VALUE) \\ inline T operator++(T & x) { return x = (T)(std::underlying_type<T>::type(x) + 1); } \\ inline T operator*(T c) { return c; } \\ inline T begin(T) { return static_cast<T>(0); } \\ inline T end(T) \\ { \\ T l = T::LAST_VALUE; \\ return l; \\ } enum class Operation { TORQUE_ENABLE , GOAL_POSITION , MOVING_SPEED , PRESENT_POSITION , PRESENT_SPEED , PRESENT_LOAD , PRESENT_VOLTAGE , PRESENT_TEMPERATURE , INVALID }; GENERATE_ENUM_ITERATOR ( Operation , INVALID ) enum class SupportedMotors { XW540_T260 , INVALID }; GENERATE_ENUM_ITERATOR ( SupportedMotors , INVALID ) enum class PacketByteSize { ONE_BYTE , TWO_BYTE , FOUR_BYTE , INVALID }; GENERATE_ENUM_ITERATOR ( PacketByteSize , INVALID ) enum class DiagnosticsType { TEMPERATURE , INVALID }; GENERATE_ENUM_ITERATOR ( DiagnosticsType , INVALID ) } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp"},{"location":"doxygen/markdown/Files/constants_8hpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfaceconstantshpp","text":"Header for defineing constant values. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp"},{"location":"doxygen/markdown/Files/constants_8hpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/constants_8hpp.html#defines","text":"Name GENERATE_ENUM_ITERATOR (T, LAST_VALUE)","title":"Defines"},{"location":"doxygen/markdown/Files/constants_8hpp.html#detailed-description","text":"Header for defineing constant values. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/constants_8hpp.html#macro-documentation","text":"","title":"Macro Documentation"},{"location":"doxygen/markdown/Files/constants_8hpp.html#define-generate_enum_iterator","text":"#define GENERATE_ENUM_ITERATOR( T , LAST_VALUE ) inline T operator ++ ( T & x ) { return x = ( T )( std :: underlying_type < T >:: type ( x ) + 1 ); } \\ inline T operator * ( T c ) { return c ; } \\ inline T begin ( T ) { return static_cast < T > ( 0 ); } \\ inline T end ( T ) \\ { \\ T l = T :: LAST_VALUE ; \\ return l ; \\ }","title":"define GENERATE_ENUM_ITERATOR"},{"location":"doxygen/markdown/Files/constants_8hpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ #include <cmath> #include <cstdint> #include <stdexcept> #include <string> namespace dynamixel_hardware_interface { constexpr double PROTOCOL_VERSION = 2.0 ; constexpr int DXL_HOME_POSITION = 0 ; // value range:0 ~ 1023 constexpr double DXL_MAX_POSITION = 1023.0 ; constexpr double DXL_MAX_POSITION_DEGREES = 300.0 ; constexpr double TO_RADIANS = ( DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION ) * M_PI / 180.0 ; constexpr double TO_DXL_POS = 1.0 / TO_RADIANS ; constexpr double TO_SPEED_REV_PER_MIN = 0.111 ; constexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI ; constexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0 ; constexpr double TO_LOAD_PERCENT = 0.1 ; constexpr double TO_VOLTAGE = 0.1 ; constexpr double PULSE_RESOLUTION = 4096 ; #define GENERATE_ENUM_ITERATOR(T, LAST_VALUE) \\ inline T operator++(T & x) { return x = (T)(std::underlying_type<T>::type(x) + 1); } \\ inline T operator*(T c) { return c; } \\ inline T begin(T) { return static_cast<T>(0); } \\ inline T end(T) \\ { \\ T l = T::LAST_VALUE; \\ return l; \\ } enum class Operation { TORQUE_ENABLE , GOAL_POSITION , MOVING_SPEED , PRESENT_POSITION , PRESENT_SPEED , PRESENT_LOAD , PRESENT_VOLTAGE , PRESENT_TEMPERATURE , INVALID }; GENERATE_ENUM_ITERATOR ( Operation , INVALID ) enum class SupportedMotors { XW540_T260 , INVALID }; GENERATE_ENUM_ITERATOR ( SupportedMotors , INVALID ) enum class PacketByteSize { ONE_BYTE , TWO_BYTE , FOUR_BYTE , INVALID }; GENERATE_ENUM_ITERATOR ( PacketByteSize , INVALID ) enum class DiagnosticsType { TEMPERATURE , INVALID }; GENERATE_ENUM_ITERATOR ( DiagnosticsType , INVALID ) } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__CONSTANTS_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src # Files # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp definition of the dynamixal diagnostic controller class Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfacesrc","text":"","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src"},{"location":"doxygen/markdown/Files/dir_68267d1309a1af8e8297ef4c3efbcdba.html#files","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp implementation of the utility function. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp Implementation of the motor class. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp Class implementation of the hardware interface for the Dynamixel motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp definition of the dynamixal diagnostic controller class Updated on 20 June 2021 at 00:42:23 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_928fd2f9e5178dedf5db7221eddd41a5.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors # Files # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors"},{"location":"doxygen/markdown/Files/dir_928fd2f9e5178dedf5db7221eddd41a5.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacemotors","text":"","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors"},{"location":"doxygen/markdown/Files/dir_928fd2f9e5178dedf5db7221eddd41a5.html#files","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp Class definition for the Dynamixel XW540-T260 motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp Header for including all motor types. Updated on 20 June 2021 at 00:42:23 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface # Directories # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors Files # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dymanixel_diagnostic_controller.hpp /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interface","text":"","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b.html#directories","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors","title":"Directories"},{"location":"doxygen/markdown/Files/dir_976ae43b1772298553d21a8261052d8b.html#files","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h Header file to control visibility. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp utility functions /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp base class of the dynamixel motor /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp Hardware interface class for dynamixel motor. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dymanixel_diagnostic_controller.hpp /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/constants.hpp Header for defineing constant values. /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/address_table_base.hpp Base class for the address tabele. Updated on 20 June 2021 at 00:42:23 UTC","title":"Files"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include # Directories # Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceinclude","text":"","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include"},{"location":"doxygen/markdown/Files/dir_d44c64559bbebec7f509842c48db8b23.html#directories","text":"Name /home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface Updated on 20 June 2021 at 00:42:23 UTC","title":"Directories"},{"location":"doxygen/markdown/Files/dymanixel__diagnostic__controller_8hpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dymanixel_diagnostic_controller.hpp # Namespaces # Name dynamixel_hardware_interface Classes # Name class dynamixel_hardware_interface::DynamixelDiagnosticController Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/visiblity_control.h> #include <realtime_tools/realtime_buffer.h> #include <realtime_tools/realtime_publisher.h> #include <controller_interface/controller_interface.hpp> #include <diagnostic_msgs/msg/diagnostic_array.hpp> #include <dynamixel_hardware_interface/constants.hpp> #include <memory> #include <rclcpp/subscription.hpp> #include <rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp> #include <rclcpp_lifecycle/state.hpp> #include <string> #include <unordered_map> #include <vector> namespace dynamixel_hardware_interface { class DynamixelDiagnosticController : public controller_interface :: ControllerInterface { public : DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: return_type init ( const std :: string & controller_name ) override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: InterfaceConfiguration command_interface_configuration () const override { return controller_interface :: InterfaceConfiguration { controller_interface :: interface_configuration_type :: NONE }; } DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: InterfaceConfiguration state_interface_configuration () const override { std :: vector < std :: string > interface_names ; for ( const auto & joint : joints_ ) { const auto diagnostic_types = diagnostics_ . at ( joint ); for ( const auto & diagnostic_type : diagnostic_types ) { switch ( diagnostic_type ) { case DiagnosticsType :: TEMPERATURE : interface_names . emplace_back ( joint + \"/temperature\" ); break ; default : break ; } } } return controller_interface :: InterfaceConfiguration { controller_interface :: interface_configuration_type :: INDIVIDUAL , interface_names }; } DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_configure ( const rclcpp_lifecycle :: State & /*previous_state*/ ) override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_activate ( const rclcpp_lifecycle :: State & /*previous_state*/ ) override { return rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn :: SUCCESS ; } DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_deactivate ( const rclcpp_lifecycle :: State & /*previous_state*/ ) override { return rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn :: SUCCESS ; } DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: return_type update () override ; private : std :: vector < std :: string > joints_ ; std :: unordered_map < std :: string , std :: vector < dynamixel_hardware_interface :: DiagnosticsType >> diagnostics_ ; rclcpp :: Publisher < diagnostic_msgs :: msg :: DiagnosticArray >:: SharedPtr diag_pub_ ; std :: shared_ptr < realtime_tools :: RealtimePublisher < diagnostic_msgs :: msg :: DiagnosticArray >> diag_pub_realtime_ ; double getValue ( const std :: string & joint_name , const std :: string & interface ); }; } // namespace dynamixel_hardware_interface Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dymanixel_diagnostic_controller.hpp"},{"location":"doxygen/markdown/Files/dymanixel__diagnostic__controller_8hpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacedymanixel_diagnostic_controllerhpp","text":"","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dymanixel_diagnostic_controller.hpp"},{"location":"doxygen/markdown/Files/dymanixel__diagnostic__controller_8hpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/dymanixel__diagnostic__controller_8hpp.html#classes","text":"Name class dynamixel_hardware_interface::DynamixelDiagnosticController","title":"Classes"},{"location":"doxygen/markdown/Files/dymanixel__diagnostic__controller_8hpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/visiblity_control.h> #include <realtime_tools/realtime_buffer.h> #include <realtime_tools/realtime_publisher.h> #include <controller_interface/controller_interface.hpp> #include <diagnostic_msgs/msg/diagnostic_array.hpp> #include <dynamixel_hardware_interface/constants.hpp> #include <memory> #include <rclcpp/subscription.hpp> #include <rclcpp_lifecycle/node_interfaces/lifecycle_node_interface.hpp> #include <rclcpp_lifecycle/state.hpp> #include <string> #include <unordered_map> #include <vector> namespace dynamixel_hardware_interface { class DynamixelDiagnosticController : public controller_interface :: ControllerInterface { public : DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: return_type init ( const std :: string & controller_name ) override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: InterfaceConfiguration command_interface_configuration () const override { return controller_interface :: InterfaceConfiguration { controller_interface :: interface_configuration_type :: NONE }; } DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: InterfaceConfiguration state_interface_configuration () const override { std :: vector < std :: string > interface_names ; for ( const auto & joint : joints_ ) { const auto diagnostic_types = diagnostics_ . at ( joint ); for ( const auto & diagnostic_type : diagnostic_types ) { switch ( diagnostic_type ) { case DiagnosticsType :: TEMPERATURE : interface_names . emplace_back ( joint + \"/temperature\" ); break ; default : break ; } } } return controller_interface :: InterfaceConfiguration { controller_interface :: interface_configuration_type :: INDIVIDUAL , interface_names }; } DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_configure ( const rclcpp_lifecycle :: State & /*previous_state*/ ) override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_activate ( const rclcpp_lifecycle :: State & /*previous_state*/ ) override { return rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn :: SUCCESS ; } DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn on_deactivate ( const rclcpp_lifecycle :: State & /*previous_state*/ ) override { return rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn :: SUCCESS ; } DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC controller_interface :: return_type update () override ; private : std :: vector < std :: string > joints_ ; std :: unordered_map < std :: string , std :: vector < dynamixel_hardware_interface :: DiagnosticsType >> diagnostics_ ; rclcpp :: Publisher < diagnostic_msgs :: msg :: DiagnosticArray >:: SharedPtr diag_pub_ ; std :: shared_ptr < realtime_tools :: RealtimePublisher < diagnostic_msgs :: msg :: DiagnosticArray >> diag_pub_realtime_ ; double getValue ( const std :: string & joint_name , const std :: string & interface ); }; } // namespace dynamixel_hardware_interface Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8cpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp # definition of the dynamixal diagnostic controller class More... Namespaces # Name dynamixel_hardware_interface Detailed Description # definition of the dynamixal diagnostic controller class Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-16 Copyright : Copyright (c) OUXT Polaris 2021 implementation of the dynamixal diagnostic controller class Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/dymanixel_diagnostic_controller.hpp> namespace dynamixel_hardware_interface { controller_interface :: return_type DynamixelDiagnosticController::init ( const std :: string & controller_name ) { auto ret = ControllerInterface :: init ( controller_name ); if ( ret != controller_interface :: return_type :: OK ) { return ret ; } rclcpp :: Parameter joints ; auto node = get_node (); node -> declare_parameter < std :: vector < std :: string >> ( \"joints\" , {}); joints_ = node -> get_parameter ( \"joints\" ). as_string_array (); for ( const auto & joint : joints_ ) { rclcpp :: Parameter diagnostics ; node -> declare_parameter < std :: vector < std :: string >> ( joint , {}); if ( ! get_node () -> get_parameter ( joint , diagnostics )) { return controller_interface :: return_type :: ERROR ; } std :: vector < dynamixel_hardware_interface :: DiagnosticsType > diag_list ; const auto diagnostics_strings = diagnostics . as_string_array (); for ( const auto & diag_string : diagnostics_strings ) { if ( diag_string == \"temperature\" ) { diag_list . emplace_back ( dynamixel_hardware_interface :: DiagnosticsType :: TEMPERATURE ); } } diagnostics_ [ joint ] = diag_list ; } return controller_interface :: return_type :: OK ; } rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn DynamixelDiagnosticController::on_configure ( const rclcpp_lifecycle :: State & /*previous_state*/ ) { auto node = get_node (); diag_pub_ = node -> create_publisher < diagnostic_msgs :: msg :: DiagnosticArray > ( \"/diagnostics\" , rclcpp :: SystemDefaultsQoS ()); diag_pub_realtime_ = std :: make_shared < realtime_tools :: RealtimePublisher < diagnostic_msgs :: msg :: DiagnosticArray >> ( diag_pub_ ); return rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn :: SUCCESS ; } double DynamixelDiagnosticController::getValue ( const std :: string & joint_name , const std :: string & interface_name ) { for ( const auto & interface : state_interfaces_ ) { if ( interface . get_name () == joint_name && interface . get_interface_name () == interface_name ) { return interface . get_value (); } } throw std :: runtime_error ( \"state interface : \" + interface_name + \" does not exist in : \" + joint_name ); } controller_interface :: return_type DynamixelDiagnosticController::update () { if ( diag_pub_realtime_ -> trylock ()) { auto msg = diagnostic_msgs :: msg :: DiagnosticArray (); msg . header . stamp = get_node () -> get_clock () -> now (); for ( const auto & joint : joints_ ) { const auto diagnostic_types = diagnostics_ . at ( joint ); auto diag_msg = diagnostic_msgs :: msg :: DiagnosticStatus (); diag_msg . name = \"dynamixel_diagnostics\" ; diag_msg . hardware_id = joint ; diag_msg . level = diag_msg . OK ; for ( const auto & diag_type : diagnostic_types ) { auto keyvalue_msg = diagnostic_msgs :: msg :: KeyValue (); switch ( diag_type ) { case DiagnosticsType :: TEMPERATURE : keyvalue_msg . key = \"temperature\" ; keyvalue_msg . value = std :: to_string ( getValue ( joint , keyvalue_msg . key )); break ; default : throw std :: runtime_error ( \"diagnostic type is invalid\" ); break ; } diag_msg . values . emplace_back ( keyvalue_msg ); msg . status . emplace_back ( diag_msg ); } } diag_pub_realtime_ -> msg_ = msg ; diag_pub_realtime_ -> unlockAndPublish (); } return controller_interface :: return_type :: OK ; } } // namespace dynamixel_hardware_interface #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS ( dynamixel_hardware_interface :: DynamixelDiagnosticController , controller_interface :: ControllerInterface ) Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8cpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfacesrcdynamixel_diagnostic_controllercpp","text":"definition of the dynamixal diagnostic controller class More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_diagnostic_controller.cpp"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8cpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8cpp.html#detailed-description","text":"definition of the dynamixal diagnostic controller class Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-16 Copyright : Copyright (c) OUXT Polaris 2021 implementation of the dynamixal diagnostic controller class","title":"Detailed Description"},{"location":"doxygen/markdown/Files/dynamixel__diagnostic__controller_8cpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/dymanixel_diagnostic_controller.hpp> namespace dynamixel_hardware_interface { controller_interface :: return_type DynamixelDiagnosticController::init ( const std :: string & controller_name ) { auto ret = ControllerInterface :: init ( controller_name ); if ( ret != controller_interface :: return_type :: OK ) { return ret ; } rclcpp :: Parameter joints ; auto node = get_node (); node -> declare_parameter < std :: vector < std :: string >> ( \"joints\" , {}); joints_ = node -> get_parameter ( \"joints\" ). as_string_array (); for ( const auto & joint : joints_ ) { rclcpp :: Parameter diagnostics ; node -> declare_parameter < std :: vector < std :: string >> ( joint , {}); if ( ! get_node () -> get_parameter ( joint , diagnostics )) { return controller_interface :: return_type :: ERROR ; } std :: vector < dynamixel_hardware_interface :: DiagnosticsType > diag_list ; const auto diagnostics_strings = diagnostics . as_string_array (); for ( const auto & diag_string : diagnostics_strings ) { if ( diag_string == \"temperature\" ) { diag_list . emplace_back ( dynamixel_hardware_interface :: DiagnosticsType :: TEMPERATURE ); } } diagnostics_ [ joint ] = diag_list ; } return controller_interface :: return_type :: OK ; } rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn DynamixelDiagnosticController::on_configure ( const rclcpp_lifecycle :: State & /*previous_state*/ ) { auto node = get_node (); diag_pub_ = node -> create_publisher < diagnostic_msgs :: msg :: DiagnosticArray > ( \"/diagnostics\" , rclcpp :: SystemDefaultsQoS ()); diag_pub_realtime_ = std :: make_shared < realtime_tools :: RealtimePublisher < diagnostic_msgs :: msg :: DiagnosticArray >> ( diag_pub_ ); return rclcpp_lifecycle :: node_interfaces :: LifecycleNodeInterface :: CallbackReturn :: SUCCESS ; } double DynamixelDiagnosticController::getValue ( const std :: string & joint_name , const std :: string & interface_name ) { for ( const auto & interface : state_interfaces_ ) { if ( interface . get_name () == joint_name && interface . get_interface_name () == interface_name ) { return interface . get_value (); } } throw std :: runtime_error ( \"state interface : \" + interface_name + \" does not exist in : \" + joint_name ); } controller_interface :: return_type DynamixelDiagnosticController::update () { if ( diag_pub_realtime_ -> trylock ()) { auto msg = diagnostic_msgs :: msg :: DiagnosticArray (); msg . header . stamp = get_node () -> get_clock () -> now (); for ( const auto & joint : joints_ ) { const auto diagnostic_types = diagnostics_ . at ( joint ); auto diag_msg = diagnostic_msgs :: msg :: DiagnosticStatus (); diag_msg . name = \"dynamixel_diagnostics\" ; diag_msg . hardware_id = joint ; diag_msg . level = diag_msg . OK ; for ( const auto & diag_type : diagnostic_types ) { auto keyvalue_msg = diagnostic_msgs :: msg :: KeyValue (); switch ( diag_type ) { case DiagnosticsType :: TEMPERATURE : keyvalue_msg . key = \"temperature\" ; keyvalue_msg . value = std :: to_string ( getValue ( joint , keyvalue_msg . key )); break ; default : throw std :: runtime_error ( \"diagnostic type is invalid\" ); break ; } diag_msg . values . emplace_back ( keyvalue_msg ); msg . status . emplace_back ( diag_msg ); } } diag_pub_realtime_ -> msg_ = msg ; diag_pub_realtime_ -> unlockAndPublish (); } return controller_interface :: return_type :: OK ; } } // namespace dynamixel_hardware_interface #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS ( dynamixel_hardware_interface :: DynamixelDiagnosticController , controller_interface :: ControllerInterface ) Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp # Class implementation of the hardware interface for the Dynamixel motor. More... Namespaces # Name dynamixel_hardware_interface Detailed Description # Class implementation of the hardware interface for the Dynamixel motor. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/dynamixel_hardware_interface.hpp> #include <memory> #include <string> #include <vector> namespace dynamixel_hardware_interface { hardware_interface :: return_type DynamixelHardwareInterface::configure ( const hardware_interface :: HardwareInfo & info ) { if ( configure_default ( info ) != hardware_interface :: return_type :: OK ) { return hardware_interface :: return_type :: ERROR ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"configure hardware \" + info . name ); for ( const auto hardware_parameter : info_ . hardware_parameters ) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"hardware parameter : \" << hardware_parameter . first << \" = \" << hardware_parameter . second ); } port_name_ = getHardwareParameter < std :: string > ( \"port_name\" ); baudrate_ = getHardwareParameter < int > ( \"baudrate\" ); RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"initialize port handler\" ); port_handler_ = std :: shared_ptr < dynamixel :: PortHandler > ( dynamixel :: PortHandler :: getPortHandler ( port_name_ . c_str ())); RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"initialize packet handler\" ); packet_handler_ = std :: shared_ptr < dynamixel :: PacketHandler > ( dynamixel :: PacketHandler :: getPacketHandler ( PROTOCOL_VERSION )); if ( ! getHardwareParameter < bool > ( \"enable_dummy\" )) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"serial port : \" << port_handler_ -> getPortName ()); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"baudrate : \" << port_handler_ -> getBaudRate ()); if ( port_handler_ -> openPort ()) { RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"open serial port succeed\" ); } else { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"open serial port failed\" ); return hardware_interface :: return_type :: ERROR ; } } RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"configure each motors\" ); for ( const auto joint : info . joints ) { std :: shared_ptr < MotorBase > motor ; try { motor = constructMotorInstance ( joint ); } catch ( const std :: runtime_error & e ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), e . what ()); return hardware_interface :: return_type :: ERROR ; } const auto result = motor -> configure (); if ( ! result . success ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } motors_ . emplace_back ( motor ); } return hardware_interface :: return_type :: OK ; } std :: vector < hardware_interface :: StateInterface > DynamixelHardwareInterface :: export_state_interfaces () { std :: vector < hardware_interface :: StateInterface > state_interfaces = {}; for ( const auto motor : motors_ ) { motor -> appendStateInterfaces ( state_interfaces ); } RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), state_interfaces . size () << \" state interfaces exported.\" ); return state_interfaces ; } std :: vector < hardware_interface :: CommandInterface > DynamixelHardwareInterface :: export_command_interfaces () { std :: vector < hardware_interface :: CommandInterface > command_interfaces = {}; for ( const auto motor : motors_ ) { motor -> appendCommandInterfaces ( command_interfaces ); } RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), command_interfaces . size () << \" command interfaces exported.\" ); return command_interfaces ; } SupportedMotors DynamixelHardwareInterface :: strToSupportMotorsEnum ( const std :: string & motor_type ) const { if ( motor_type == \"XW540-T260\" ) { return SupportedMotors :: XW540_T260 ; } return SupportedMotors :: INVALID ; } std :: shared_ptr < MotorBase > DynamixelHardwareInterface :: constructMotorInstance ( const hardware_interface :: ComponentInfo & info ) const { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"constructing motor instance : \" << info . name ); for ( const auto parameter : info . parameters ) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"parameter \" << parameter . first << \" : \" << parameter . second ); } if ( info . type == \"joint\" ) { const auto motor_type = strToSupportMotorsEnum ( getParameter < std :: string > ( \"motor_type\" , info )); if ( motor_type == SupportedMotors :: INVALID ) { throw std :: runtime_error ( \"failed to construct motor instance, motor type is invalid\" ); } const auto id = static_cast < uint8_t > ( getParameter < int > ( \"id\" , info )); switch ( motor_type ) { case SupportedMotors :: XW540_T260 : return std :: make_shared < motors :: XW540_T260 > ( info . name , getHardwareParameter < bool > ( \"enable_dummy\" ), baudrate_ , id , port_handler_ , packet_handler_ ); break ; default : break ; } } throw std :: runtime_error ( \"failed to construct motor instance\" ); } hardware_interface :: return_type DynamixelHardwareInterface :: start () { status_ = hardware_interface :: status :: STARTED ; return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: stop () { return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: read () { for ( const auto motor : motors_ ) { if ( motor -> operationSupports ( Operation :: PRESENT_POSITION )) { const auto result = motor -> updateJointPosition (); if ( ! result . success ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } } if ( motor -> operationSupports ( Operation :: PRESENT_SPEED )) { const auto result = motor -> updateJointVelocity (); if ( ! result . success ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } } if ( motor -> operationSupports ( Operation :: PRESENT_TEMPERATURE )) { const auto result = motor -> updatePresentTemperature (); if ( ! result . success ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } } } return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: write () { for ( const auto motor : motors_ ) { if ( motor -> operationSupports ( Operation :: GOAL_POSITION )) { motor -> setCurrentGoalPosition (); } } return hardware_interface :: return_type :: OK ; } } // namespace dynamixel_hardware_interface #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS ( dynamixel_hardware_interface :: DynamixelHardwareInterface , hardware_interface :: SystemInterface ) Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfacesrcdynamixel_hardware_interfacecpp","text":"Class implementation of the hardware interface for the Dynamixel motor. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/dynamixel_hardware_interface.cpp"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp.html#detailed-description","text":"Class implementation of the hardware interface for the Dynamixel motor. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8cpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/dynamixel_hardware_interface.hpp> #include <memory> #include <string> #include <vector> namespace dynamixel_hardware_interface { hardware_interface :: return_type DynamixelHardwareInterface::configure ( const hardware_interface :: HardwareInfo & info ) { if ( configure_default ( info ) != hardware_interface :: return_type :: OK ) { return hardware_interface :: return_type :: ERROR ; } RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"configure hardware \" + info . name ); for ( const auto hardware_parameter : info_ . hardware_parameters ) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"hardware parameter : \" << hardware_parameter . first << \" = \" << hardware_parameter . second ); } port_name_ = getHardwareParameter < std :: string > ( \"port_name\" ); baudrate_ = getHardwareParameter < int > ( \"baudrate\" ); RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"initialize port handler\" ); port_handler_ = std :: shared_ptr < dynamixel :: PortHandler > ( dynamixel :: PortHandler :: getPortHandler ( port_name_ . c_str ())); RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"initialize packet handler\" ); packet_handler_ = std :: shared_ptr < dynamixel :: PacketHandler > ( dynamixel :: PacketHandler :: getPacketHandler ( PROTOCOL_VERSION )); if ( ! getHardwareParameter < bool > ( \"enable_dummy\" )) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"serial port : \" << port_handler_ -> getPortName ()); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"baudrate : \" << port_handler_ -> getBaudRate ()); if ( port_handler_ -> openPort ()) { RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"open serial port succeed\" ); } else { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"open serial port failed\" ); return hardware_interface :: return_type :: ERROR ; } } RCLCPP_INFO ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"configure each motors\" ); for ( const auto joint : info . joints ) { std :: shared_ptr < MotorBase > motor ; try { motor = constructMotorInstance ( joint ); } catch ( const std :: runtime_error & e ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), e . what ()); return hardware_interface :: return_type :: ERROR ; } const auto result = motor -> configure (); if ( ! result . success ) { RCLCPP_ERROR ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } motors_ . emplace_back ( motor ); } return hardware_interface :: return_type :: OK ; } std :: vector < hardware_interface :: StateInterface > DynamixelHardwareInterface :: export_state_interfaces () { std :: vector < hardware_interface :: StateInterface > state_interfaces = {}; for ( const auto motor : motors_ ) { motor -> appendStateInterfaces ( state_interfaces ); } RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), state_interfaces . size () << \" state interfaces exported.\" ); return state_interfaces ; } std :: vector < hardware_interface :: CommandInterface > DynamixelHardwareInterface :: export_command_interfaces () { std :: vector < hardware_interface :: CommandInterface > command_interfaces = {}; for ( const auto motor : motors_ ) { motor -> appendCommandInterfaces ( command_interfaces ); } RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), command_interfaces . size () << \" command interfaces exported.\" ); return command_interfaces ; } SupportedMotors DynamixelHardwareInterface :: strToSupportMotorsEnum ( const std :: string & motor_type ) const { if ( motor_type == \"XW540-T260\" ) { return SupportedMotors :: XW540_T260 ; } return SupportedMotors :: INVALID ; } std :: shared_ptr < MotorBase > DynamixelHardwareInterface :: constructMotorInstance ( const hardware_interface :: ComponentInfo & info ) const { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"constructing motor instance : \" << info . name ); for ( const auto parameter : info . parameters ) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"parameter \" << parameter . first << \" : \" << parameter . second ); } if ( info . type == \"joint\" ) { const auto motor_type = strToSupportMotorsEnum ( getParameter < std :: string > ( \"motor_type\" , info )); if ( motor_type == SupportedMotors :: INVALID ) { throw std :: runtime_error ( \"failed to construct motor instance, motor type is invalid\" ); } const auto id = static_cast < uint8_t > ( getParameter < int > ( \"id\" , info )); switch ( motor_type ) { case SupportedMotors :: XW540_T260 : return std :: make_shared < motors :: XW540_T260 > ( info . name , getHardwareParameter < bool > ( \"enable_dummy\" ), baudrate_ , id , port_handler_ , packet_handler_ ); break ; default : break ; } } throw std :: runtime_error ( \"failed to construct motor instance\" ); } hardware_interface :: return_type DynamixelHardwareInterface :: start () { status_ = hardware_interface :: status :: STARTED ; return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: stop () { return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: read () { for ( const auto motor : motors_ ) { if ( motor -> operationSupports ( Operation :: PRESENT_POSITION )) { const auto result = motor -> updateJointPosition (); if ( ! result . success ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } } if ( motor -> operationSupports ( Operation :: PRESENT_SPEED )) { const auto result = motor -> updateJointVelocity (); if ( ! result . success ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } } if ( motor -> operationSupports ( Operation :: PRESENT_TEMPERATURE )) { const auto result = motor -> updatePresentTemperature (); if ( ! result . success ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), result . description ); return hardware_interface :: return_type :: ERROR ; } } } return hardware_interface :: return_type :: OK ; } hardware_interface :: return_type DynamixelHardwareInterface :: write () { for ( const auto motor : motors_ ) { if ( motor -> operationSupports ( Operation :: GOAL_POSITION )) { motor -> setCurrentGoalPosition (); } } return hardware_interface :: return_type :: OK ; } } // namespace dynamixel_hardware_interface #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS ( dynamixel_hardware_interface :: DynamixelHardwareInterface , hardware_interface :: SystemInterface ) Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp # Hardware interface class for dynamixel motor. More... Namespaces # Name dynamixel_hardware_interface Classes # Name class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor. Detailed Description # Hardware interface class for dynamixel motor. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ #include <dynamixel_hardware_interface/visiblity_control.h> #include <dynamixel_sdk/dynamixel_sdk.h> #include <dynamixel_hardware_interface/motors/motors.hpp> #include <hardware_interface/base_interface.hpp> #include <hardware_interface/handle.hpp> #include <hardware_interface/hardware_info.hpp> #include <hardware_interface/system_interface.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_status_values.hpp> #include <memory> #include <rclcpp/rclcpp.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { class DynamixelHardwareInterface : public hardware_interface :: BaseInterface < hardware_interface :: SystemInterface > { public : RCLCPP_SHARED_PTR_DEFINITIONS ( DynamixelHardwareInterface ) DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type configure ( const hardware_interface :: HardwareInfo & info ) override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: StateInterface > export_state_interfaces () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: CommandInterface > export_command_interfaces () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type start () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type stop () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type read () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type write () override ; private : std :: string port_name_ ; int baudrate_ ; SupportedMotors strToSupportMotorsEnum ( const std :: string & motor_type ) const ; template < typename T > T getParameter ( const std :: string key , const hardware_interface :: ComponentInfo & info ) const { T param ; getParameter ( key , info , param ); return param ; } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , std :: string & parameter ) const { try { parameter = info . parameters . at ( key ); } catch ( std :: out_of_range & e ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"parameter : \" << key << \" does not exist.\" ); } } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , int & parameter ) const { std :: string param_string ; getParameter ( key , info , param_string ); parameter = std :: stoi ( param_string ); } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , bool & parameter ) const { parameter = false ; std :: string param_string ; getParameter ( key , info , param_string ); if ( param_string == \"true\" || param_string == \"True\" ) { parameter = true ; } } template < typename T > T getHardwareParameter ( const std :: string key ) const { T param ; getHardwareParameter ( key , param ); return param ; } void getHardwareParameter ( const std :: string & key , std :: string & parameter ) const { try { parameter = info_ . hardware_parameters . at ( key ); } catch ( std :: out_of_range & e ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"hardware parameter : \" << key << \" does not exist.\" ); } } void getHardwareParameter ( const std :: string & key , int & parameter ) const { std :: string param_string ; getHardwareParameter ( key , param_string ); parameter = std :: stoi ( param_string ); } void getHardwareParameter ( const std :: string & key , bool & parameter ) const { parameter = false ; std :: string param_string ; getHardwareParameter ( key , param_string ); if ( param_string == \"true\" || param_string == \"True\" ) { parameter = true ; } } std :: shared_ptr < MotorBase > constructMotorInstance ( const hardware_interface :: ComponentInfo & info ) const ; std :: vector < std :: shared_ptr < MotorBase >> motors_ ; std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacedynamixel_hardware_interfacehpp","text":"Hardware interface class for dynamixel motor. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/dynamixel_hardware_interface.hpp"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp.html#classes","text":"Name class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor.","title":"Classes"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp.html#detailed-description","text":"Hardware interface class for dynamixel motor. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/dynamixel__hardware__interface_8hpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ #include <dynamixel_hardware_interface/visiblity_control.h> #include <dynamixel_sdk/dynamixel_sdk.h> #include <dynamixel_hardware_interface/motors/motors.hpp> #include <hardware_interface/base_interface.hpp> #include <hardware_interface/handle.hpp> #include <hardware_interface/hardware_info.hpp> #include <hardware_interface/system_interface.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_status_values.hpp> #include <memory> #include <rclcpp/rclcpp.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { class DynamixelHardwareInterface : public hardware_interface :: BaseInterface < hardware_interface :: SystemInterface > { public : RCLCPP_SHARED_PTR_DEFINITIONS ( DynamixelHardwareInterface ) DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type configure ( const hardware_interface :: HardwareInfo & info ) override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: StateInterface > export_state_interfaces () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC std :: vector < hardware_interface :: CommandInterface > export_command_interfaces () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type start () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type stop () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type read () override ; DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC hardware_interface :: return_type write () override ; private : std :: string port_name_ ; int baudrate_ ; SupportedMotors strToSupportMotorsEnum ( const std :: string & motor_type ) const ; template < typename T > T getParameter ( const std :: string key , const hardware_interface :: ComponentInfo & info ) const { T param ; getParameter ( key , info , param ); return param ; } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , std :: string & parameter ) const { try { parameter = info . parameters . at ( key ); } catch ( std :: out_of_range & e ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"parameter : \" << key << \" does not exist.\" ); } } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , int & parameter ) const { std :: string param_string ; getParameter ( key , info , param_string ); parameter = std :: stoi ( param_string ); } void getParameter ( const std :: string & key , const hardware_interface :: ComponentInfo & info , bool & parameter ) const { parameter = false ; std :: string param_string ; getParameter ( key , info , param_string ); if ( param_string == \"true\" || param_string == \"True\" ) { parameter = true ; } } template < typename T > T getHardwareParameter ( const std :: string key ) const { T param ; getHardwareParameter ( key , param ); return param ; } void getHardwareParameter ( const std :: string & key , std :: string & parameter ) const { try { parameter = info_ . hardware_parameters . at ( key ); } catch ( std :: out_of_range & e ) { RCLCPP_ERROR_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"hardware parameter : \" << key << \" does not exist.\" ); } } void getHardwareParameter ( const std :: string & key , int & parameter ) const { std :: string param_string ; getHardwareParameter ( key , param_string ); parameter = std :: stoi ( param_string ); } void getHardwareParameter ( const std :: string & key , bool & parameter ) const { parameter = false ; std :: string param_string ; getHardwareParameter ( key , param_string ); if ( param_string == \"true\" || param_string == \"True\" ) { parameter = true ; } } std :: shared_ptr < MotorBase > constructMotorInstance ( const hardware_interface :: ComponentInfo & info ) const ; std :: vector < std :: shared_ptr < MotorBase >> motors_ ; std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__DYNAMIXEL_HARDWARE_INTERFACE_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/motor__base_8cpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp # Implementation of the motor class. More... Namespaces # Name dynamixel_hardware_interface Detailed Description # Implementation of the motor class. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/motor_base.hpp> #include <dynamixel_hardware_interface/util.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_type_values.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { MotorBase ::~ MotorBase () { if ( ! enable_dummy ) { torqueEnable ( false ); } } bool MotorBase :: operationSupports ( const Operation & operation ) { const auto address = address_table_ -> getAddress ( operation ); if ( ! address . exists ()) { return false ; } return true ; } std :: vector < Operation > MotorBase :: getSupportedOperations () { std :: vector < Operation > ret = {}; for ( const auto operation : Operation ()) { const auto address = address_table_ -> getAddress ( operation ); if ( address . exists ()) { ret . emplace_back ( operation ); } } return ret ; } double MotorBase :: valueToRpm ( uint8_t ) const { throw std :: runtime_error ( \"value to rpm function should be implemented for each motor\" ); } double MotorBase :: valueToRpm ( uint16_t ) const { throw std :: runtime_error ( \"value to rpm function should be implemented for each motor\" ); } double MotorBase :: valueToRpm ( uint32_t ) const { throw std :: runtime_error ( \"value to rpm function should be implemented for each motor\" ); } double MotorBase :: positionToRadian ( const uint8_t ) const { throw std :: runtime_error ( \"position to radian function should be implemented for each motor\" ); } double MotorBase :: positionToRadian ( const uint16_t ) const { throw std :: runtime_error ( \"position to radian function should be implemented for each motor\" ); } double MotorBase :: positionToRadian ( const uint32_t ) const { throw std :: runtime_error ( \"position to radian function should be implemented for each motor\" ); } void MotorBase :: radianToPosition ( double , uint8_t & ) const { throw std :: runtime_error ( \"radian to position function should be implemented for each motor\" ); } void MotorBase :: radianToPosition ( double , uint16_t & ) const { throw std :: runtime_error ( \"radian to position function should be implemented for each motor\" ); } void MotorBase :: radianToPosition ( double , uint32_t & ) const { throw std :: runtime_error ( \"radian to position function should be implemented for each motor\" ); } double MotorBase :: valueToTemperature ( uint8_t ) const { throw std :: runtime_error ( \"value to temperature function should be implemented for each motor\" ); } double MotorBase :: valueToTemperature ( uint16_t ) const { throw std :: runtime_error ( \"value to temperature function should be implemented for each motor\" ); } double MotorBase :: valueToTemperature ( uint32_t ) const { throw std :: runtime_error ( \"value to temperature function should be implemented for each motor\" ); } Result MotorBase :: getResult ( int communication_result , uint8_t packet_error ) { if ( communication_result != COMM_SUCCESS ) { return Result ( std :: string ( packet_handler_ -> getTxRxResult ( communication_result )), false ); } if ( packet_error != 0 ) { return Result ( std :: string ( packet_handler_ -> getRxPacketError ( packet_error )), true ); } return Result ( \"\" , true ); } Result MotorBase :: configure () { if ( address_table_ -> addressExists ( Operation :: PRESENT_POSITION )) { joint_position_ = 0 ; } if ( address_table_ -> addressExists ( Operation :: GOAL_POSITION )) { goal_position_ = 0 ; } if ( ! enable_dummy ) { return torqueEnable ( true ); } return Result ( \"\" , true ); } void MotorBase :: appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ) { for ( const auto operation : Operation ()) { if ( address_table_ -> addressExists ( operation )) { switch ( operation ) { case Operation :: PRESENT_POSITION : interfaces . emplace_back ( hardware_interface :: StateInterface ( joint_name , hardware_interface :: HW_IF_POSITION , & joint_position_ )); break ; case Operation :: PRESENT_SPEED : interfaces . emplace_back ( hardware_interface :: StateInterface ( joint_name , hardware_interface :: HW_IF_VELOCITY , & joint_position_ )); break ; case Operation :: PRESENT_TEMPERATURE : interfaces . emplace_back ( hardware_interface :: StateInterface ( joint_name , \"temperature\" , & present_temperature_ )); break ; default : break ; } } } } void MotorBase :: appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ) { for ( const auto operation : Operation ()) { if ( address_table_ -> addressExists ( operation )) { switch ( operation ) { case Operation :: GOAL_POSITION : interfaces . emplace_back ( hardware_interface :: CommandInterface ( joint_name , hardware_interface :: HW_IF_POSITION , & goal_position_ )); break ; case Operation :: MOVING_SPEED : interfaces . emplace_back ( hardware_interface :: CommandInterface ( joint_name , hardware_interface :: HW_IF_VELOCITY , & goal_velocity_ )); default : break ; } } } } Result MotorBase :: torqueEnable ( bool enable ) { const auto address = address_table_ -> getAddress ( Operation :: TORQUE_ENABLE ); if ( ! address . exists ()) { return Result ( \"TORQUE_ENABLE operation does not support in \" + toString ( motor_type ), false ); } uint8_t error = 0 ; const auto result = packet_handler_ -> write1ByteTxRx ( port_handler_ . get (), id , address . address , enable , & error ); return getResult ( result , error ); } Result MotorBase :: setGoalPosition ( double goal_position ) { goal_position_ = goal_position ; const auto address = address_table_ -> getAddress ( Operation :: GOAL_POSITION ); if ( ! address . exists ()) { return Result ( \"TORQUE_ENABLE operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_position_ = goal_position_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { const auto result = packet_handler_ -> write1ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint8_t > ( goal_position_ ), & error ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { const auto result = packet_handler_ -> write2ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint16_t > ( goal_position_ ), & error ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { const auto result = packet_handler_ -> write4ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint32_t > ( goal_position_ ), & error ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } Result MotorBase :: updateJointVelocity () { const auto address = address_table_ -> getAddress ( Operation :: PRESENT_SPEED ); if ( ! address . exists ()) { return Result ( \"PRESENT_SPEED operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_velocity_ = goal_velocity_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { uint8_t present_speed = 0 ; const auto result = packet_handler_ -> read1ByteTxRx ( port_handler_ . get (), id , address . address , & present_speed , & error ); joint_velocity_ = valueToRpm ( present_speed ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { uint16_t present_speed = 0 ; const auto result = packet_handler_ -> read2ByteTxRx ( port_handler_ . get (), id , address . address , & present_speed , & error ); joint_velocity_ = valueToRpm ( present_speed ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { uint32_t present_speed = 0 ; const auto result = packet_handler_ -> read4ByteTxRx ( port_handler_ . get (), id , address . address , & present_speed , & error ); joint_velocity_ = valueToRpm ( present_speed ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } Result MotorBase :: updateJointPosition () { const auto address = address_table_ -> getAddress ( Operation :: PRESENT_POSITION ); if ( ! address . exists ()) { return Result ( \"PRESENT_POSITION operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_position_ = goal_position_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { uint8_t present_position = 0 ; const auto result = packet_handler_ -> read1ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { uint16_t present_position = 0 ; const auto result = packet_handler_ -> read2ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { uint32_t present_position = 0 ; const auto result = packet_handler_ -> read4ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } Result MotorBase :: updatePresentTemperature () { const auto address = address_table_ -> getAddress ( Operation :: PRESENT_TEMPERATURE ); if ( ! address . exists ()) { return Result ( \"PRESENT_TEMPERATURE operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { present_temperature_ = 0 ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { uint8_t present_temperature = 0 ; const auto result = packet_handler_ -> read1ByteTxRx ( port_handler_ . get (), id , address . address , & present_temperature , & error ); present_temperature_ = valueToTemperature ( present_temperature ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { uint16_t present_temperature = 0 ; const auto result = packet_handler_ -> read2ByteTxRx ( port_handler_ . get (), id , address . address , & present_temperature , & error ); present_temperature_ = valueToTemperature ( present_temperature ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { uint32_t present_temperature = 0 ; const auto result = packet_handler_ -> read4ByteTxRx ( port_handler_ . get (), id , address . address , & present_temperature , & error ); present_temperature_ = valueToTemperature ( present_temperature ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } } // namespace dynamixel_hardware_interface Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp"},{"location":"doxygen/markdown/Files/motor__base_8cpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfacesrcmotor_basecpp","text":"Implementation of the motor class. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/motor_base.cpp"},{"location":"doxygen/markdown/Files/motor__base_8cpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/motor__base_8cpp.html#detailed-description","text":"Implementation of the motor class. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/motor__base_8cpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/motor_base.hpp> #include <dynamixel_hardware_interface/util.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_type_values.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { MotorBase ::~ MotorBase () { if ( ! enable_dummy ) { torqueEnable ( false ); } } bool MotorBase :: operationSupports ( const Operation & operation ) { const auto address = address_table_ -> getAddress ( operation ); if ( ! address . exists ()) { return false ; } return true ; } std :: vector < Operation > MotorBase :: getSupportedOperations () { std :: vector < Operation > ret = {}; for ( const auto operation : Operation ()) { const auto address = address_table_ -> getAddress ( operation ); if ( address . exists ()) { ret . emplace_back ( operation ); } } return ret ; } double MotorBase :: valueToRpm ( uint8_t ) const { throw std :: runtime_error ( \"value to rpm function should be implemented for each motor\" ); } double MotorBase :: valueToRpm ( uint16_t ) const { throw std :: runtime_error ( \"value to rpm function should be implemented for each motor\" ); } double MotorBase :: valueToRpm ( uint32_t ) const { throw std :: runtime_error ( \"value to rpm function should be implemented for each motor\" ); } double MotorBase :: positionToRadian ( const uint8_t ) const { throw std :: runtime_error ( \"position to radian function should be implemented for each motor\" ); } double MotorBase :: positionToRadian ( const uint16_t ) const { throw std :: runtime_error ( \"position to radian function should be implemented for each motor\" ); } double MotorBase :: positionToRadian ( const uint32_t ) const { throw std :: runtime_error ( \"position to radian function should be implemented for each motor\" ); } void MotorBase :: radianToPosition ( double , uint8_t & ) const { throw std :: runtime_error ( \"radian to position function should be implemented for each motor\" ); } void MotorBase :: radianToPosition ( double , uint16_t & ) const { throw std :: runtime_error ( \"radian to position function should be implemented for each motor\" ); } void MotorBase :: radianToPosition ( double , uint32_t & ) const { throw std :: runtime_error ( \"radian to position function should be implemented for each motor\" ); } double MotorBase :: valueToTemperature ( uint8_t ) const { throw std :: runtime_error ( \"value to temperature function should be implemented for each motor\" ); } double MotorBase :: valueToTemperature ( uint16_t ) const { throw std :: runtime_error ( \"value to temperature function should be implemented for each motor\" ); } double MotorBase :: valueToTemperature ( uint32_t ) const { throw std :: runtime_error ( \"value to temperature function should be implemented for each motor\" ); } Result MotorBase :: getResult ( int communication_result , uint8_t packet_error ) { if ( communication_result != COMM_SUCCESS ) { return Result ( std :: string ( packet_handler_ -> getTxRxResult ( communication_result )), false ); } if ( packet_error != 0 ) { return Result ( std :: string ( packet_handler_ -> getRxPacketError ( packet_error )), true ); } return Result ( \"\" , true ); } Result MotorBase :: configure () { if ( address_table_ -> addressExists ( Operation :: PRESENT_POSITION )) { joint_position_ = 0 ; } if ( address_table_ -> addressExists ( Operation :: GOAL_POSITION )) { goal_position_ = 0 ; } if ( ! enable_dummy ) { return torqueEnable ( true ); } return Result ( \"\" , true ); } void MotorBase :: appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ) { for ( const auto operation : Operation ()) { if ( address_table_ -> addressExists ( operation )) { switch ( operation ) { case Operation :: PRESENT_POSITION : interfaces . emplace_back ( hardware_interface :: StateInterface ( joint_name , hardware_interface :: HW_IF_POSITION , & joint_position_ )); break ; case Operation :: PRESENT_SPEED : interfaces . emplace_back ( hardware_interface :: StateInterface ( joint_name , hardware_interface :: HW_IF_VELOCITY , & joint_position_ )); break ; case Operation :: PRESENT_TEMPERATURE : interfaces . emplace_back ( hardware_interface :: StateInterface ( joint_name , \"temperature\" , & present_temperature_ )); break ; default : break ; } } } } void MotorBase :: appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ) { for ( const auto operation : Operation ()) { if ( address_table_ -> addressExists ( operation )) { switch ( operation ) { case Operation :: GOAL_POSITION : interfaces . emplace_back ( hardware_interface :: CommandInterface ( joint_name , hardware_interface :: HW_IF_POSITION , & goal_position_ )); break ; case Operation :: MOVING_SPEED : interfaces . emplace_back ( hardware_interface :: CommandInterface ( joint_name , hardware_interface :: HW_IF_VELOCITY , & goal_velocity_ )); default : break ; } } } } Result MotorBase :: torqueEnable ( bool enable ) { const auto address = address_table_ -> getAddress ( Operation :: TORQUE_ENABLE ); if ( ! address . exists ()) { return Result ( \"TORQUE_ENABLE operation does not support in \" + toString ( motor_type ), false ); } uint8_t error = 0 ; const auto result = packet_handler_ -> write1ByteTxRx ( port_handler_ . get (), id , address . address , enable , & error ); return getResult ( result , error ); } Result MotorBase :: setGoalPosition ( double goal_position ) { goal_position_ = goal_position ; const auto address = address_table_ -> getAddress ( Operation :: GOAL_POSITION ); if ( ! address . exists ()) { return Result ( \"TORQUE_ENABLE operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_position_ = goal_position_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { const auto result = packet_handler_ -> write1ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint8_t > ( goal_position_ ), & error ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { const auto result = packet_handler_ -> write2ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint16_t > ( goal_position_ ), & error ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { const auto result = packet_handler_ -> write4ByteTxRx ( port_handler_ . get (), id , address . address , radianToPosition < uint32_t > ( goal_position_ ), & error ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } Result MotorBase :: updateJointVelocity () { const auto address = address_table_ -> getAddress ( Operation :: PRESENT_SPEED ); if ( ! address . exists ()) { return Result ( \"PRESENT_SPEED operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_velocity_ = goal_velocity_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { uint8_t present_speed = 0 ; const auto result = packet_handler_ -> read1ByteTxRx ( port_handler_ . get (), id , address . address , & present_speed , & error ); joint_velocity_ = valueToRpm ( present_speed ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { uint16_t present_speed = 0 ; const auto result = packet_handler_ -> read2ByteTxRx ( port_handler_ . get (), id , address . address , & present_speed , & error ); joint_velocity_ = valueToRpm ( present_speed ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { uint32_t present_speed = 0 ; const auto result = packet_handler_ -> read4ByteTxRx ( port_handler_ . get (), id , address . address , & present_speed , & error ); joint_velocity_ = valueToRpm ( present_speed ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } Result MotorBase :: updateJointPosition () { const auto address = address_table_ -> getAddress ( Operation :: PRESENT_POSITION ); if ( ! address . exists ()) { return Result ( \"PRESENT_POSITION operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { joint_position_ = goal_position_ ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { uint8_t present_position = 0 ; const auto result = packet_handler_ -> read1ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { uint16_t present_position = 0 ; const auto result = packet_handler_ -> read2ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { uint32_t present_position = 0 ; const auto result = packet_handler_ -> read4ByteTxRx ( port_handler_ . get (), id , address . address , & present_position , & error ); joint_position_ = positionToRadian ( present_position ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } Result MotorBase :: updatePresentTemperature () { const auto address = address_table_ -> getAddress ( Operation :: PRESENT_TEMPERATURE ); if ( ! address . exists ()) { return Result ( \"PRESENT_TEMPERATURE operation does not support in \" + toString ( motor_type ), false ); } if ( enable_dummy ) { present_temperature_ = 0 ; return Result ( \"\" , true ); } else { uint8_t error = 0 ; if ( address . byte_size == PacketByteSize :: ONE_BYTE ) { uint8_t present_temperature = 0 ; const auto result = packet_handler_ -> read1ByteTxRx ( port_handler_ . get (), id , address . address , & present_temperature , & error ); present_temperature_ = valueToTemperature ( present_temperature ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: TWO_BYTE ) { uint16_t present_temperature = 0 ; const auto result = packet_handler_ -> read2ByteTxRx ( port_handler_ . get (), id , address . address , & present_temperature , & error ); present_temperature_ = valueToTemperature ( present_temperature ); return getResult ( result , error ); } if ( address . byte_size == PacketByteSize :: FOUR_BYTE ) { uint32_t present_temperature = 0 ; const auto result = packet_handler_ -> read4ByteTxRx ( port_handler_ . get (), id , address . address , & present_temperature , & error ); present_temperature_ = valueToTemperature ( present_temperature ); return getResult ( result , error ); } return Result ( \"Invalid packet size\" , false ); } } } // namespace dynamixel_hardware_interface Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/motor__base_8hpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp # base class of the dynamixel motor More... Namespaces # Name dynamixel_hardware_interface Classes # Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor. Detailed Description # base class of the dynamixel motor Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ #include <dynamixel_sdk/dynamixel_sdk.h> #include <dynamixel_hardware_interface/address_table_base.hpp> #include <dynamixel_hardware_interface/constants.hpp> #include <hardware_interface/base_interface.hpp> #include <hardware_interface/handle.hpp> #include <hardware_interface/hardware_info.hpp> #include <hardware_interface/system_interface.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_status_values.hpp> #include <limits> #include <memory> #include <rclcpp/rclcpp.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { struct Result { const std :: string description ; const bool success ; Result ( const std :: string & description , bool success ) : description ( description ), success ( success ) { } }; class MotorBase { public : const SupportedMotors motor_type ; const std :: string joint_name ; const bool enable_dummy ; const int baudrate ; const uint8_t id ; template < typename AddressTable > MotorBase ( const SupportedMotors & motor_type , const std :: string & joint_name , const bool enable_dummy , const AddressTable & table , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) : motor_type ( motor_type ), joint_name ( joint_name ), enable_dummy ( enable_dummy ), baudrate ( baudrate ), id ( id ), port_handler_ ( port_handler ), packet_handler_ ( packet_handler ), joint_position_ ( std :: numeric_limits < double >:: quiet_NaN ()), goal_position_ ( std :: numeric_limits < double >:: quiet_NaN ()) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"start constructing motor instance\" ); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"joint_name : \" << joint_name ); address_table_ = std :: make_shared < AddressTableBase > ( table ); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"end constructing motor instance\" ); } ~ MotorBase (); bool operationSupports ( const Operation & operation ); virtual std :: vector < Operation > getSupportedOperations (); virtual Result configure (); virtual Result torqueEnable ( bool enable ); virtual Result setGoalPosition ( double goal_position ); virtual Result setCurrentGoalPosition () { return setGoalPosition ( goal_position_ ); } virtual double getJointPosition () const { return joint_position_ ; } virtual double getGoalPosition () const { return goal_position_ ; } virtual Result updateJointPosition (); virtual Result updateJointVelocity (); virtual Result updatePresentTemperature (); virtual void appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ); virtual void appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ); protected : MotorBase () = delete ; Result getResult ( int communication_result , uint8_t packet_error ); template < typename T > T radianToPosition ( double radian ) const { T value ; radianToPosition ( radian , value ); return value ; } uint16_t radianToPosition ( double radian ) const ; virtual double positionToRadian ( const uint8_t position ) const ; virtual double positionToRadian ( const uint16_t position ) const ; virtual double positionToRadian ( const uint32_t position ) const ; virtual void radianToPosition ( double radian , uint8_t & value ) const ; virtual void radianToPosition ( double radian , uint16_t & value ) const ; virtual void radianToPosition ( double radian , uint32_t & value ) const ; void rpmToVelocity ( double rpm , double & radian ) const { radian = rpm / 60.0 * 2 * M_PI ; } virtual double valueToRpm ( uint8_t value ) const ; virtual double valueToRpm ( uint16_t value ) const ; virtual double valueToRpm ( uint32_t value ) const ; virtual double valueToTemperature ( uint8_t value ) const ; virtual double valueToTemperature ( uint16_t value ) const ; virtual double valueToTemperature ( uint32_t value ) const ; std :: shared_ptr < AddressTableBase > address_table_ ; std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; double joint_position_ ; double goal_position_ ; double joint_velocity_ ; double goal_velocity_ ; double present_temperature_ ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp"},{"location":"doxygen/markdown/Files/motor__base_8hpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacemotor_basehpp","text":"base class of the dynamixel motor More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motor_base.hpp"},{"location":"doxygen/markdown/Files/motor__base_8hpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/motor__base_8hpp.html#classes","text":"Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor.","title":"Classes"},{"location":"doxygen/markdown/Files/motor__base_8hpp.html#detailed-description","text":"base class of the dynamixel motor Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/motor__base_8hpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ #include <dynamixel_sdk/dynamixel_sdk.h> #include <dynamixel_hardware_interface/address_table_base.hpp> #include <dynamixel_hardware_interface/constants.hpp> #include <hardware_interface/base_interface.hpp> #include <hardware_interface/handle.hpp> #include <hardware_interface/hardware_info.hpp> #include <hardware_interface/system_interface.hpp> #include <hardware_interface/types/hardware_interface_return_values.hpp> #include <hardware_interface/types/hardware_interface_status_values.hpp> #include <limits> #include <memory> #include <rclcpp/rclcpp.hpp> #include <string> #include <vector> namespace dynamixel_hardware_interface { struct Result { const std :: string description ; const bool success ; Result ( const std :: string & description , bool success ) : description ( description ), success ( success ) { } }; class MotorBase { public : const SupportedMotors motor_type ; const std :: string joint_name ; const bool enable_dummy ; const int baudrate ; const uint8_t id ; template < typename AddressTable > MotorBase ( const SupportedMotors & motor_type , const std :: string & joint_name , const bool enable_dummy , const AddressTable & table , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) : motor_type ( motor_type ), joint_name ( joint_name ), enable_dummy ( enable_dummy ), baudrate ( baudrate ), id ( id ), port_handler_ ( port_handler ), packet_handler_ ( packet_handler ), joint_position_ ( std :: numeric_limits < double >:: quiet_NaN ()), goal_position_ ( std :: numeric_limits < double >:: quiet_NaN ()) { RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"start constructing motor instance\" ); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"joint_name : \" << joint_name ); address_table_ = std :: make_shared < AddressTableBase > ( table ); RCLCPP_INFO_STREAM ( rclcpp :: get_logger ( \"dynamixel_hardware_interface\" ), \"end constructing motor instance\" ); } ~ MotorBase (); bool operationSupports ( const Operation & operation ); virtual std :: vector < Operation > getSupportedOperations (); virtual Result configure (); virtual Result torqueEnable ( bool enable ); virtual Result setGoalPosition ( double goal_position ); virtual Result setCurrentGoalPosition () { return setGoalPosition ( goal_position_ ); } virtual double getJointPosition () const { return joint_position_ ; } virtual double getGoalPosition () const { return goal_position_ ; } virtual Result updateJointPosition (); virtual Result updateJointVelocity (); virtual Result updatePresentTemperature (); virtual void appendStateInterfaces ( std :: vector < hardware_interface :: StateInterface > & interfaces ); virtual void appendCommandInterfaces ( std :: vector < hardware_interface :: CommandInterface > & interfaces ); protected : MotorBase () = delete ; Result getResult ( int communication_result , uint8_t packet_error ); template < typename T > T radianToPosition ( double radian ) const { T value ; radianToPosition ( radian , value ); return value ; } uint16_t radianToPosition ( double radian ) const ; virtual double positionToRadian ( const uint8_t position ) const ; virtual double positionToRadian ( const uint16_t position ) const ; virtual double positionToRadian ( const uint32_t position ) const ; virtual void radianToPosition ( double radian , uint8_t & value ) const ; virtual void radianToPosition ( double radian , uint16_t & value ) const ; virtual void radianToPosition ( double radian , uint32_t & value ) const ; void rpmToVelocity ( double rpm , double & radian ) const { radian = rpm / 60.0 * 2 * M_PI ; } virtual double valueToRpm ( uint8_t value ) const ; virtual double valueToRpm ( uint16_t value ) const ; virtual double valueToRpm ( uint32_t value ) const ; virtual double valueToTemperature ( uint8_t value ) const ; virtual double valueToTemperature ( uint16_t value ) const ; virtual double valueToTemperature ( uint32_t value ) const ; std :: shared_ptr < AddressTableBase > address_table_ ; std :: shared_ptr < dynamixel :: PortHandler > port_handler_ ; std :: shared_ptr < dynamixel :: PacketHandler > packet_handler_ ; double joint_position_ ; double goal_position_ ; double joint_velocity_ ; double goal_velocity_ ; double present_temperature_ ; }; } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTOR_BASE_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/motors_8hpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp # Header for including all motor types. More... Detailed Description # Header for including all motor types. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ #include <dynamixel_hardware_interface/motors/xw540_t260.hpp> #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp"},{"location":"doxygen/markdown/Files/motors_8hpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacemotorsmotorshpp","text":"Header for including all motor types. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/motors.hpp"},{"location":"doxygen/markdown/Files/motors_8hpp.html#detailed-description","text":"Header for including all motor types. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/motors_8hpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ #include <dynamixel_hardware_interface/motors/xw540_t260.hpp> #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__MOTORS_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/util_8cpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp # implementation of the utility function. More... Namespaces # Name dynamixel_hardware_interface Detailed Description # implementation of the utility function. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/util.hpp> namespace dynamixel_hardware_interface { const std :: string toString ( const SupportedMotors motor ) { switch ( motor ) { case SupportedMotors :: XW540_T260 : return \"XW540-T260\" ; break ; case SupportedMotors :: INVALID : throw std :: runtime_error ( \"invalid moter type\" ); break ; } return \"\" ; } } // namespace dynamixel_hardware_interface Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp"},{"location":"doxygen/markdown/Files/util_8cpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfacesrcutilcpp","text":"implementation of the utility function. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/src/util.cpp"},{"location":"doxygen/markdown/Files/util_8cpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/util_8cpp.html#detailed-description","text":"implementation of the utility function. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/util_8cpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #include <dynamixel_hardware_interface/util.hpp> namespace dynamixel_hardware_interface { const std :: string toString ( const SupportedMotors motor ) { switch ( motor ) { case SupportedMotors :: XW540_T260 : return \"XW540-T260\" ; break ; case SupportedMotors :: INVALID : throw std :: runtime_error ( \"invalid moter type\" ); break ; } return \"\" ; } } // namespace dynamixel_hardware_interface Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/util_8hpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp # utility functions More... Namespaces # Name dynamixel_hardware_interface Detailed Description # utility functions Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ #include <dynamixel_hardware_interface/constants.hpp> namespace dynamixel_hardware_interface { const std :: string toString ( const SupportedMotors motor ); } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp"},{"location":"doxygen/markdown/Files/util_8hpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfaceutilhpp","text":"utility functions More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/util.hpp"},{"location":"doxygen/markdown/Files/util_8hpp.html#namespaces","text":"Name dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/util_8hpp.html#detailed-description","text":"utility functions Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/util_8hpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ #include <dynamixel_hardware_interface/constants.hpp> namespace dynamixel_hardware_interface { const std :: string toString ( const SupportedMotors motor ); } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__UTIL_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h # Header file to control visibility. More... Defines # Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_LOCAL DYNAMIXEL_HARDWARE_INTERFACE_IMPORT DYNAMIXEL_HARDWARE_INTERFACE_EXPORT Detailed Description # Header file to control visibility. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Macro Documentation # define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE # #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC # #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL # #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT # #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT # #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\"))) Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ #define DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ // This logic was borrowed (then namespaced) from the examples on the gcc wiki: // https://gcc.gnu.org/wiki/Visibility #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((dllexport)) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __attribute__((dllimport)) #else #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __declspec(dllexport) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __declspec(dllimport) #endif #ifdef DYNAMIXEL_HARDWARE_INTERFACE_BUILDING_DLL #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_EXPORT #else #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_IMPORT #endif #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL #else #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\"))) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT #if __GNUC__ >= 4 #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC __attribute__((visibility(\"default\"))) #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL __attribute__((visibility(\"hidden\"))) #else #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL #endif #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE #endif #endif // DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacevisiblity_controlh","text":"Header file to control visibility. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/visiblity_control.h"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#defines","text":"Name DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_LOCAL DYNAMIXEL_HARDWARE_INTERFACE_IMPORT DYNAMIXEL_HARDWARE_INTERFACE_EXPORT","title":"Defines"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#detailed-description","text":"Header file to control visibility. Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#macro-documentation","text":"","title":"Macro Documentation"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#define-dynamixel_hardware_interface_public_type","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE","title":"define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#define-dynamixel_hardware_interface_public","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC","title":"define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#define-dynamixel_hardware_interface_local","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL","title":"define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#define-dynamixel_hardware_interface_import","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT","title":"define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#define-dynamixel_hardware_interface_export","text":"#define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\")))","title":"define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT"},{"location":"doxygen/markdown/Files/visiblity__control_8h.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ #define DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ // This logic was borrowed (then namespaced) from the examples on the gcc wiki: // https://gcc.gnu.org/wiki/Visibility #if defined _WIN32 || defined __CYGWIN__ #ifdef __GNUC__ #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((dllexport)) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __attribute__((dllimport)) #else #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __declspec(dllexport) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT __declspec(dllimport) #endif #ifdef DYNAMIXEL_HARDWARE_INTERFACE_BUILDING_DLL #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_EXPORT #else #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC DYNAMIXEL_HARDWARE_INTERFACE_IMPORT #endif #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL #else #define DYNAMIXEL_HARDWARE_INTERFACE_EXPORT __attribute__((visibility(\"default\"))) #define DYNAMIXEL_HARDWARE_INTERFACE_IMPORT #if __GNUC__ >= 4 #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC __attribute__((visibility(\"default\"))) #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL __attribute__((visibility(\"hidden\"))) #else #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC #define DYNAMIXEL_HARDWARE_INTERFACE_LOCAL #endif #define DYNAMIXEL_HARDWARE_INTERFACE_PUBLIC_TYPE #endif #endif // DYNAMIXEL_HARDWARE_INTERFACE__VISIBLITY_CONTROL_H_ Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp.html","text":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp # Class definition for the Dynamixel XW540-T260 motor. More... Namespaces # Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables dynamixel_hardware_interface Classes # Name class dynamixel_hardware_interface::motors::XW540_T260 class dynamixel_hardware_interface::address_tables::XW540_T260 Detailed Description # Class definition for the Dynamixel XW540-T260 motor. See : https://emanual.robotis.com/docs/en/dxl/x/xw540-t260/ Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021 Source code # // Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ #include <cmath> #include <dynamixel_hardware_interface/address_table_base.hpp> #include <dynamixel_hardware_interface/motor_base.hpp> #include <limits> #include <memory> #include <string> namespace dynamixel_hardware_interface { namespace address_tables { class XW540_T260 : public AddressTableBase { public : XW540_T260 () : AddressTableBase ( Address ( 64 , PacketByteSize :: ONE_BYTE ), Address ( 116 , PacketByteSize :: FOUR_BYTE ), Address (), Address ( 132 , PacketByteSize :: FOUR_BYTE ), Address ( 128 , PacketByteSize :: FOUR_BYTE ), Address (), Address (), Address ( 146 , PacketByteSize :: ONE_BYTE )) { } }; } // namespace address_tables namespace motors { class XW540_T260 : public MotorBase { public : explicit XW540_T260 ( const std :: string joint_name , bool enable_dummy , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) : MotorBase ( SupportedMotors :: XW540_T260 , joint_name , enable_dummy , address_tables :: XW540_T260 (), baudrate , id , port_handler , packet_handler ) { } double positionToRadian ( const uint32_t position ) const override { return static_cast < double > ( position ) / static_cast < double > ( 4096 ) * M_PI * 2 ; } void radianToPosition ( double radian , uint32_t & value ) const override { value = static_cast < uint32_t > (( radian / M_PI ) * 4096 ); } double valueToRpm ( uint32_t value ) const override { return 2.29 * 2 * M_PI / 60 * static_cast < double > ( value ); } double valueToTemperature ( uint8_t value ) const override { return static_cast < double > ( value ); } }; } // namespace motors } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp.html#homerunnerworkdynamixel_hardware_interfacedynamixel_hardware_interfaceincludedynamixel_hardware_interfacemotorsxw540_t260hpp","text":"Class definition for the Dynamixel XW540-T260 motor. More...","title":"/home/runner/work/dynamixel_hardware_interface/dynamixel_hardware_interface/include/dynamixel_hardware_interface/motors/xw540_t260.hpp"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp.html#namespaces","text":"Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables dynamixel_hardware_interface","title":"Namespaces"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp.html#classes","text":"Name class dynamixel_hardware_interface::motors::XW540_T260 class dynamixel_hardware_interface::address_tables::XW540_T260","title":"Classes"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp.html#detailed-description","text":"Class definition for the Dynamixel XW540-T260 motor. See : https://emanual.robotis.com/docs/en/dxl/x/xw540-t260/ Author : Masaya Kataoka ( ms.kataoka@gmail.com ) Version : 0.1 Date : 2021-05-01 Copyright : Copyright (c) OUXT Polaris 2021","title":"Detailed Description"},{"location":"doxygen/markdown/Files/xw540__t260_8hpp.html#source-code","text":"// Copyright (c) 2021 OUXT Polaris // // Licensed under the Apache License, Version 2.0 (the \"License\"); // you may not use this file except in compliance with the License. // You may obtain a copy of the License at // // http://www.apache.org/licenses/LICENSE-2.0 // // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. // See the License for the specific language governing permissions and // limitations under the License. #ifndef DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ #define DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ #include <cmath> #include <dynamixel_hardware_interface/address_table_base.hpp> #include <dynamixel_hardware_interface/motor_base.hpp> #include <limits> #include <memory> #include <string> namespace dynamixel_hardware_interface { namespace address_tables { class XW540_T260 : public AddressTableBase { public : XW540_T260 () : AddressTableBase ( Address ( 64 , PacketByteSize :: ONE_BYTE ), Address ( 116 , PacketByteSize :: FOUR_BYTE ), Address (), Address ( 132 , PacketByteSize :: FOUR_BYTE ), Address ( 128 , PacketByteSize :: FOUR_BYTE ), Address (), Address (), Address ( 146 , PacketByteSize :: ONE_BYTE )) { } }; } // namespace address_tables namespace motors { class XW540_T260 : public MotorBase { public : explicit XW540_T260 ( const std :: string joint_name , bool enable_dummy , int baudrate , uint8_t id , std :: shared_ptr < dynamixel :: PortHandler > port_handler , std :: shared_ptr < dynamixel :: PacketHandler > packet_handler ) : MotorBase ( SupportedMotors :: XW540_T260 , joint_name , enable_dummy , address_tables :: XW540_T260 (), baudrate , id , port_handler , packet_handler ) { } double positionToRadian ( const uint32_t position ) const override { return static_cast < double > ( position ) / static_cast < double > ( 4096 ) * M_PI * 2 ; } void radianToPosition ( double radian , uint32_t & value ) const override { value = static_cast < uint32_t > (( radian / M_PI ) * 4096 ); } double valueToRpm ( uint32_t value ) const override { return 2.29 * 2 * M_PI / 60 * static_cast < double > ( value ); } double valueToTemperature ( uint8_t value ) const override { return static_cast < double > ( value ); } }; } // namespace motors } // namespace dynamixel_hardware_interface #endif // DYNAMIXEL_HARDWARE_INTERFACE__MOTORS__XW540_T260_HPP_ Updated on 20 June 2021 at 00:42:23 UTC","title":"Source code"},{"location":"doxygen/markdown/Modules/index.html","text":"Modules # Updated on 20 June 2021 at 00:42:23 UTC","title":"Modules"},{"location":"doxygen/markdown/Modules/index.html#modules","text":"Updated on 20 June 2021 at 00:42:23 UTC","title":"Modules"},{"location":"doxygen/markdown/Namespaces/index.html","text":"Namespaces # namespace dynamixel_hardware_interface namespace address_tables namespace motors Updated on 20 June 2021 at 00:42:23 UTC","title":"Namespaces"},{"location":"doxygen/markdown/Namespaces/index.html#namespaces","text":"namespace dynamixel_hardware_interface namespace address_tables namespace motors Updated on 20 June 2021 at 00:42:23 UTC","title":"Namespaces"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html","text":"dynamixel_hardware_interface # Namespaces # Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables Classes # Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor. class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor. class dynamixel_hardware_interface::DynamixelDiagnosticController class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address Types # Name enum SupportedMotors { XW540_T260, INVALID } Enum class of the supported motor. enum PacketByteSize { TWO_BYTE, ONE_BYTE, INVALID, FOUR_BYTE } enum Operation { TORQUE_ENABLE, PRESENT_VOLTAGE, PRESENT_TEMPERATURE, PRESENT_SPEED, PRESENT_POSITION, PRESENT_LOAD, MOVING_SPEED, INVALID, GOAL_POSITION } Enum class of the commands. enum DiagnosticsType { TEMPERATURE, INVALID } Functions # Name const std::string toString (const SupportedMotors motor) Attributes # Name constexpr double TO_VOLTAGE constexpr double TO_SPEED_REV_PER_MIN constexpr double TO_SPEED_RAD_PER_SEC constexpr double TO_SPEED_RAD_PER_MIN constexpr double TO_RADIANS constexpr double TO_LOAD_PERCENT constexpr double TO_DXL_POS constexpr double PULSE_RESOLUTION constexpr double PROTOCOL_VERSION constexpr double DXL_MAX_POSITION_DEGREES constexpr double DXL_MAX_POSITION constexpr int DXL_HOME_POSITION Types Documentation # enum SupportedMotors # Enumerator Value Description XW540_T260 Robotis xw540-t260 motor. INVALID Invalid motor type. Enum class of the supported motor. enum PacketByteSize # Enumerator Value Description TWO_BYTE ONE_BYTE INVALID FOUR_BYTE enum Operation # Enumerator Value Description TORQUE_ENABLE PRESENT_VOLTAGE PRESENT_TEMPERATURE PRESENT_SPEED PRESENT_POSITION PRESENT_LOAD MOVING_SPEED INVALID GOAL_POSITION Enum class of the commands. enum DiagnosticsType # Enumerator Value Description TEMPERATURE INVALID Functions Documentation # function toString # const std :: string toString ( const SupportedMotors motor ) Attributes Documentation # variable TO_VOLTAGE # constexpr double TO_VOLTAGE = 0.1 ; variable TO_SPEED_REV_PER_MIN # constexpr double TO_SPEED_REV_PER_MIN = 0.111 ; variable TO_SPEED_RAD_PER_SEC # constexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0 ; variable TO_SPEED_RAD_PER_MIN # constexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI ; variable TO_RADIANS # constexpr double TO_RADIANS = ( DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION ) * M_PI / 180.0 ; variable TO_LOAD_PERCENT # constexpr double TO_LOAD_PERCENT = 0.1 ; variable TO_DXL_POS # constexpr double TO_DXL_POS = 1.0 / TO_RADIANS ; variable PULSE_RESOLUTION # constexpr double PULSE_RESOLUTION = 4096 ; variable PROTOCOL_VERSION # constexpr double PROTOCOL_VERSION = 2.0 ; variable DXL_MAX_POSITION_DEGREES # constexpr double DXL_MAX_POSITION_DEGREES = 300.0 ; variable DXL_MAX_POSITION # constexpr double DXL_MAX_POSITION = 1023.0 ; variable DXL_HOME_POSITION # constexpr int DXL_HOME_POSITION = 0 ; Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#dynamixel_hardware_interface","text":"","title":"dynamixel_hardware_interface"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#namespaces","text":"Name dynamixel_hardware_interface::motors dynamixel_hardware_interface::address_tables","title":"Namespaces"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#classes","text":"Name struct dynamixel_hardware_interface::Result Struct describes the command result. class dynamixel_hardware_interface::MotorBase Base class for controlling dynamixel motor. class dynamixel_hardware_interface::DynamixelHardwareInterface Hardware interface for the dynamixel motor. class dynamixel_hardware_interface::DynamixelDiagnosticController class dynamixel_hardware_interface::AddressTableBase base class for address table class class dynamixel_hardware_interface::Address","title":"Classes"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#types","text":"Name enum SupportedMotors { XW540_T260, INVALID } Enum class of the supported motor. enum PacketByteSize { TWO_BYTE, ONE_BYTE, INVALID, FOUR_BYTE } enum Operation { TORQUE_ENABLE, PRESENT_VOLTAGE, PRESENT_TEMPERATURE, PRESENT_SPEED, PRESENT_POSITION, PRESENT_LOAD, MOVING_SPEED, INVALID, GOAL_POSITION } Enum class of the commands. enum DiagnosticsType { TEMPERATURE, INVALID }","title":"Types"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#functions","text":"Name const std::string toString (const SupportedMotors motor)","title":"Functions"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#attributes","text":"Name constexpr double TO_VOLTAGE constexpr double TO_SPEED_REV_PER_MIN constexpr double TO_SPEED_RAD_PER_SEC constexpr double TO_SPEED_RAD_PER_MIN constexpr double TO_RADIANS constexpr double TO_LOAD_PERCENT constexpr double TO_DXL_POS constexpr double PULSE_RESOLUTION constexpr double PROTOCOL_VERSION constexpr double DXL_MAX_POSITION_DEGREES constexpr double DXL_MAX_POSITION constexpr int DXL_HOME_POSITION","title":"Attributes"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#types-documentation","text":"","title":"Types Documentation"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#enum-supportedmotors","text":"Enumerator Value Description XW540_T260 Robotis xw540-t260 motor. INVALID Invalid motor type. Enum class of the supported motor.","title":"enum SupportedMotors"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#enum-packetbytesize","text":"Enumerator Value Description TWO_BYTE ONE_BYTE INVALID FOUR_BYTE","title":"enum PacketByteSize"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#enum-operation","text":"Enumerator Value Description TORQUE_ENABLE PRESENT_VOLTAGE PRESENT_TEMPERATURE PRESENT_SPEED PRESENT_POSITION PRESENT_LOAD MOVING_SPEED INVALID GOAL_POSITION Enum class of the commands.","title":"enum Operation"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#enum-diagnosticstype","text":"Enumerator Value Description TEMPERATURE INVALID","title":"enum DiagnosticsType"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#functions-documentation","text":"","title":"Functions Documentation"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#function-tostring","text":"const std :: string toString ( const SupportedMotors motor )","title":"function toString"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#attributes-documentation","text":"","title":"Attributes Documentation"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-to_voltage","text":"constexpr double TO_VOLTAGE = 0.1 ;","title":"variable TO_VOLTAGE"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-to_speed_rev_per_min","text":"constexpr double TO_SPEED_REV_PER_MIN = 0.111 ;","title":"variable TO_SPEED_REV_PER_MIN"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-to_speed_rad_per_sec","text":"constexpr double TO_SPEED_RAD_PER_SEC = TO_SPEED_RAD_PER_MIN / 60.0 ;","title":"variable TO_SPEED_RAD_PER_SEC"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-to_speed_rad_per_min","text":"constexpr double TO_SPEED_RAD_PER_MIN = TO_SPEED_REV_PER_MIN * 2.0 * M_PI ;","title":"variable TO_SPEED_RAD_PER_MIN"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-to_radians","text":"constexpr double TO_RADIANS = ( DXL_MAX_POSITION_DEGREES / DXL_MAX_POSITION ) * M_PI / 180.0 ;","title":"variable TO_RADIANS"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-to_load_percent","text":"constexpr double TO_LOAD_PERCENT = 0.1 ;","title":"variable TO_LOAD_PERCENT"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-to_dxl_pos","text":"constexpr double TO_DXL_POS = 1.0 / TO_RADIANS ;","title":"variable TO_DXL_POS"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-pulse_resolution","text":"constexpr double PULSE_RESOLUTION = 4096 ;","title":"variable PULSE_RESOLUTION"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-protocol_version","text":"constexpr double PROTOCOL_VERSION = 2.0 ;","title":"variable PROTOCOL_VERSION"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-dxl_max_position_degrees","text":"constexpr double DXL_MAX_POSITION_DEGREES = 300.0 ;","title":"variable DXL_MAX_POSITION_DEGREES"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-dxl_max_position","text":"constexpr double DXL_MAX_POSITION = 1023.0 ;","title":"variable DXL_MAX_POSITION"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface.html#variable-dxl_home_position","text":"constexpr int DXL_HOME_POSITION = 0 ; Updated on 20 June 2021 at 00:42:23 UTC","title":"variable DXL_HOME_POSITION"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1address__tables.html","text":"dynamixel_hardware_interface::address_tables # Classes # Name class dynamixel_hardware_interface::address_tables::XW540_T260 Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::address_tables"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1address__tables.html#dynamixel_hardware_interfaceaddress_tables","text":"","title":"dynamixel_hardware_interface::address_tables"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1address__tables.html#classes","text":"Name class dynamixel_hardware_interface::address_tables::XW540_T260 Updated on 20 June 2021 at 00:42:23 UTC","title":"Classes"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1motors.html","text":"dynamixel_hardware_interface::motors # Classes # Name class dynamixel_hardware_interface::motors::XW540_T260 Updated on 20 June 2021 at 00:42:23 UTC","title":"dynamixel_hardware_interface::motors"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1motors.html#dynamixel_hardware_interfacemotors","text":"","title":"dynamixel_hardware_interface::motors"},{"location":"doxygen/markdown/Namespaces/namespacedynamixel__hardware__interface_1_1motors.html#classes","text":"Name class dynamixel_hardware_interface::motors::XW540_T260 Updated on 20 June 2021 at 00:42:23 UTC","title":"Classes"},{"location":"doxygen/markdown/Pages/index.html","text":"Pages # Updated on 20 June 2021 at 00:42:23 UTC","title":"Pages"},{"location":"doxygen/markdown/Pages/index.html#pages","text":"Updated on 20 June 2021 at 00:42:23 UTC","title":"Pages"}]}